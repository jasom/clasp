xIndex: Jamfile.jam
===================================================================
--- Jamfile.jam	(revision 4739)
+++ Jamfile.jam	(working copy)
@@ -42,6 +42,12 @@
       all.cc ;
 
 local sources = 
+      bind.cc
+	    cons.cc
+      serialize.cc
+      sexpLoadArchive.cc
+      sexpSaveArchive.cc
+	    readtable.cc
       debugger.cc
       float_to_digits.cc
       num_arith.cc
@@ -114,7 +120,6 @@
 	    singleDispatchMethod.cc
 	    structureObject.cc
 	    structureClass.cc
-	    readtable.cc
 	    null.cc
 	    forwardReferencedClass.cc
 	    lispList.cc
@@ -145,7 +150,6 @@
 		externalObject.cc
 		myReadLine.cc
 		specialForm.cc
-	    cons.cc
 	    bignum.cc
       genericFunction.cc
 	    instance.cc
@@ -188,6 +192,7 @@
 cando.bundle $(dir) :
 	     $(sources) 
 	     /externals//boostAndExpatLibs :
+	     <link>static
 	     <implicit-dependency>meta
 	     ;
 
Index: TODO
===================================================================
--- TODO	(revision 4737)
+++ TODO	(working copy)
@@ -1,8 +1,2 @@
-
-Change Value cells of Symbols to single values again - they don't need to have a stack because the saved values are now stored in ValueEnvironment_O.
-
-
-
-
-
-
+Working on compiler.lsp
+compile-arguments
Index: activationFrame.cc
===================================================================
--- activationFrame.cc	(revision 4737)
+++ activationFrame.cc	(working copy)
@@ -52,6 +52,41 @@
 	SUBIMP();
     }
 
+
+
+
+    bool ActivationFrame_O::_findTag(Symbol_sp sym, int& depth, int& index ) const
+    {_G();
+	Environment_sp parent = nilCheck_currentVisibleEnvironment(this->getParentEnvironment());
+	++depth;
+	return nilCheck_findTag(parent,sym,depth,index);
+    }
+
+
+
+    bool ActivationFrame_O::_findValue(Symbol_sp sym, int& depth, int& index, bool& special,T_sp& value) const
+    {_G();
+	Environment_sp parent = nilCheck_currentVisibleEnvironment(this->getParentEnvironment());
+	++depth;
+	return nilCheck_findValue(parent,sym,depth,index,special,value);
+    }
+
+
+    bool ActivationFrame_O::_findFunction(T_sp functionName, int& depth, int& index, Function_sp& func) const
+    {
+	Environment_sp parent = nilCheck_currentVisibleEnvironment(this->getParentEnvironment());
+	++depth;
+	return nilCheck_findFunction(parent,functionName,depth,index,func);
+    }
+
+
+
+
+
+
+
+
+
 	    
 	
 
@@ -207,7 +242,6 @@
 	    {
 		SIMPLE_ERROR(BF("Out of range index[%d] for ValueFrame with %d entries") % index % this->_NumArgs );
 	    }
-	    WATCH_POINTER(this->_Args[index]);
 	    return((this->_Args[index]));
 	}
 	--depth;
@@ -306,6 +340,31 @@
     }
 
 
+
+    /*! Update a value in the frame based on it's name
+     This is only used by the interpreter and so it isn't expected to be fast
+    */
+    bool ValueFrame_O::updateValue(Symbol_sp sym, T_sp obj)
+    {
+	if ( this->_DebuggingInfo.nilp() )
+	{
+	    return this->Base::updateValue(sym,obj);
+	}
+	Vector_sp debuggingInfo = this->_DebuggingInfo.as<Vector_O>();
+	for ( int i(0), iEnd(this->length()); i<iEnd; i++ ) {
+	    if ( debuggingInfo->elt(i).as<Symbol_O>() == sym ) {
+		this->_Args[i] = obj;
+		return true;
+	    }
+	}
+	if ( this->parentFrame().nilp() ) return false;
+	return this->parentFrame()->updateValue(sym,obj);
+    }
+
+
+    /*! Find the value bound to a symbol based on the symbol name.
+       This is only used by the interpreter and shouldn't be expected to be fast.
+    */
     bool ValueFrame_O::_findValue(Symbol_sp sym, int& depth, int& index, bool& special, T_sp& value ) const
     {_G();
 	if ( this->_DebuggingInfo.nilp() )
Index: activationFrame.h
===================================================================
--- activationFrame.h	(revision 4737)
+++ activationFrame.h	(working copy)
@@ -14,26 +14,25 @@
 {
 
 
-#define WATCH_POINTER(_tsp_)  
-
     /*! Types of ActivationFrame */
 //    typedef enum { variables_frame=0, functions_frame=1, block_frame=2, tagbody_frame=3 } ActivationFrameType;
 
     // TODO: ActivationFrame should adopt the _findValue behaviors of RuntimeVisibleEnvironment 
     // TODO: and it should inherit from Environment_O not RuntimeVisibleEnvironment_O
-    class ActivationFrame_O : public RuntimeVisibleEnvironment_O
+    class ActivationFrame_O : public Environment_O // RuntimeVisibleEnvironment_O
     {
-	LISP_BASE1(RuntimeVisibleEnvironment_O);
+	LISP_BASE1( Environment_O ); // RuntimeVisibleEnvironment_O);
 	LISP_VIRTUAL_CLASS(core,CorePkg,ActivationFrame_O,"ActivationFrame");
     protected:
-	ActivationFrame_sp	_ParentFrame;
     public:
 	static string nilCheck_asString(ActivationFrame_sp af);
     public:
 	ActivationFrame_O() : Base() {};
 	virtual ~ActivationFrame_O() {};
 
+	virtual T_sp* argArray() {SUBIMP();};
 
+
 	virtual T_sp& operator[](int idx) {SUBIMP();};
 	virtual T_sp& operator[](int idx) const{SUBIMP();};
 
@@ -47,16 +46,20 @@
 	virtual T_sp lookupTagbodyId(int depth, int index) const;
 
 
+	virtual bool _findTag(Symbol_sp tag, int& depth, int& index) const;
+	virtual bool _findValue(Symbol_sp sym, int& depth, int& index, bool& special, T_sp& value) const;
+	virtual bool _findFunction(T_sp functionName, int& depth, int& index, Function_sp& value) const;
+
+
+	virtual ActivationFrame_sp& parentFrameRef() { SUBIMP(); };
+	virtual ActivationFrame_sp parentFrame() const { SUBIMP(); };
+
 	/*! Methods for interogating ActivationFrames as Environments */
-	Environment_sp getParentEnvironment() const { return this->_ParentFrame;};
+	Environment_sp getParentEnvironment() const { return this->parentFrame(); };
 	/*! Method for interogating ActivationFrames as Environments */
 	virtual string summaryOfContents() const;
 
-	/*! Get the next ActivationFrame pointer */
-	ActivationFrame_sp parentFrame() const { return this->_ParentFrame;};
-	ActivationFrame_sp& parentFrameRef() { return this->_ParentFrame;};
-
-	void setParentFrame(ActivationFrame_sp parent) { this->_ParentFrame = parent;};
+	void setParentFrame(ActivationFrame_sp parent) { this->parentFrameRef() = parent;};
 	/*! Return the number of arguments */
 	virtual uint length() const {SUBIMP();};
 
@@ -103,11 +106,13 @@
 
 
 
+
     class ValueFrame_O : public ActivationFrame_O
     {
 	LISP_BASE1(ActivationFrame_O);
 	LISP_CLASS(core,CorePkg,ValueFrame_O,"ValueFrame");
     protected:
+	ActivationFrame_sp	_ParentFrame;
 	int				_NumArgs;
 	core::T_op*			_Args;
 	core::T_op 			_DebuggingInfo;
@@ -143,119 +148,42 @@
 
 	static ValueFrame_sp createForLambdaListHandler(LambdaListHandler_sp llh,ActivationFrame_sp parent);
 
-	static ValueFrame_sp create_fill(T_sp arg1,ActivationFrame_sp parent)
+	template <class ... ARGS>
+	static ValueFrame_sp create_fill(ActivationFrame_sp parent, ARGS... args)
 	{_G();
-	    ValueFrame_sp vf(ValueFrame_O::create(parent));
-	    vf->allocateStorage(1);
-	    vf->set_entry(0,arg1);
+	    GC_RESERVE_BEGIN(ValueFrame_O,vf) {
+		GC_RESERVE_GET(ValueFrame_O,vf);
+		vf->_ParentFrame = parent;
+	    } GC_RESERVE_END(vf);
+	    vf->_NumArgs = sizeof...(ARGS);
+	    vf->_Args = new T_sp[sizeof...(ARGS)]{args...};
 	    return vf;
 	}
 
-	static ValueFrame_sp create_fill(T_sp arg1,T_sp arg2,ActivationFrame_sp parent)
-	{_G();
-	    ValueFrame_sp vf(ValueFrame_O::create(parent));
-	    vf->allocateStorage(2);
-	    vf->set_entry(0,arg1);
-	    vf->set_entry(1,arg2);
-	    return vf;
-	}
 
-	static ValueFrame_sp create_fill(T_sp arg1,T_sp arg2,T_sp arg3,ActivationFrame_sp parent)
+	template <class ... ARGS>
+	static ValueFrame_sp create_fill(int nargs, ActivationFrame_sp parent, ARGS... args)
 	{_G();
-	    ValueFrame_sp vf(ValueFrame_O::create(parent));
-	    vf->allocateStorage(3);
-	    vf->set_entry(0,arg1);
-	    vf->set_entry(1,arg2);
-	    vf->set_entry(2,arg3);
+	    GC_RESERVE_BEGIN(ValueFrame_O,vf) {
+		GC_RESERVE_GET(ValueFrame_O,vf);
+		vf->_ParentFrame = parent;
+	    } GC_RESERVE_END(vf);
+	    vf->_NumArgs = nargs;
+	    vf->_Args = new T_sp[nargs]{args...};
 	    return vf;
 	}
 
-	static ValueFrame_sp create_fill(T_sp arg1,T_sp arg2,T_sp arg3,T_sp arg4,ActivationFrame_sp parent)
-	{_G();
-	    ValueFrame_sp vf(ValueFrame_O::create(parent));
-	    vf->allocateStorage(4);
-	    vf->set_entry(0,arg1);
-	    vf->set_entry(1,arg2);
-	    vf->set_entry(2,arg3);
-	    vf->set_entry(3,arg4);
-	    return vf;
-	}
 
-	static ValueFrame_sp create_fill(T_sp arg1,T_sp arg2,T_sp arg3,T_sp arg4,T_sp arg5, ActivationFrame_sp parent)
-	{_G();
-	    ValueFrame_sp vf(ValueFrame_O::create(parent));
-	    vf->allocateStorage(5);
-	    vf->set_entry(0,arg1);
-	    vf->set_entry(1,arg2);
-	    vf->set_entry(2,arg3);
-	    vf->set_entry(3,arg4);
-	    vf->set_entry(4,arg5);
-	    return vf;
-	}
 
-	static ValueFrame_sp create_fill(T_sp arg1,T_sp arg2,T_sp arg3,T_sp arg4,T_sp arg5,T_sp arg6, ActivationFrame_sp parent)
-	{_G();
-	    ValueFrame_sp vf(ValueFrame_O::create(parent));
-	    vf->allocateStorage(6);
-	    vf->set_entry(0,arg1);
-	    vf->set_entry(1,arg2);
-	    vf->set_entry(2,arg3);
-	    vf->set_entry(3,arg4);
-	    vf->set_entry(4,arg5);
-	    vf->set_entry(5,arg6);
-	    return vf;
-	}
 
-	static ValueFrame_sp create_fill(T_sp arg1,T_sp arg2,T_sp arg3,T_sp arg4,T_sp arg5,T_sp arg6,T_sp arg7, ActivationFrame_sp parent)
-	{_G();
-	    ValueFrame_sp vf(ValueFrame_O::create(parent));
-	    vf->allocateStorage(7);
-	    vf->set_entry(0,arg1);
-	    vf->set_entry(1,arg2);
-	    vf->set_entry(2,arg3);
-	    vf->set_entry(3,arg4);
-	    vf->set_entry(4,arg5);
-	    vf->set_entry(5,arg6);
-	    vf->set_entry(6,arg7);
-	    return vf;
-	}
-
-	static ValueFrame_sp create_fill(T_sp arg1,T_sp arg2,T_sp arg3,T_sp arg4,T_sp arg5,T_sp arg6,T_sp arg7, T_sp arg8, ActivationFrame_sp parent)
-	{_G();
-	    ValueFrame_sp vf(ValueFrame_O::create(parent));
-	    vf->allocateStorage(8);
-	    vf->set_entry(0,arg1);
-	    vf->set_entry(1,arg2);
-	    vf->set_entry(2,arg3);
-	    vf->set_entry(3,arg4);
-	    vf->set_entry(4,arg5);
-	    vf->set_entry(5,arg6);
-	    vf->set_entry(6,arg7);
-	    vf->set_entry(7,arg8);
-	    return vf;
-	}
-
-	static ValueFrame_sp create_fill(T_sp arg1,T_sp arg2,T_sp arg3,T_sp arg4,T_sp arg5,T_sp arg6,T_sp arg7, T_sp arg8, T_sp arg9, ActivationFrame_sp parent)
-	{_G();
-	    ValueFrame_sp vf(ValueFrame_O::create(parent));
-	    vf->allocateStorage(9);
-	    vf->set_entry(0,arg1);
-	    vf->set_entry(1,arg2);
-	    vf->set_entry(2,arg3);
-	    vf->set_entry(3,arg4);
-	    vf->set_entry(4,arg5);
-	    vf->set_entry(5,arg6);
-	    vf->set_entry(6,arg7);
-	    vf->set_entry(7,arg8);
-	    vf->set_entry(8,arg9);
-	    return vf;
-	}
-
-
 	ValueFrame_O() : Base(), _DebuggingInfo(_Nil<T_O>()) {};
 	virtual ~ValueFrame_O();
 
     public:
+
+	virtual ActivationFrame_sp& parentFrameRef() { return this->_ParentFrame; };
+	virtual ActivationFrame_sp parentFrame() const { return this->_ParentFrame; };
+
 	void attachDebuggingInfo(core::T_sp debuggingInfo)
 	{_G();
 	    this->_DebuggingInfo = debuggingInfo;
@@ -271,6 +199,7 @@
 	virtual T_sp& operator[](int idx);
 	virtual T_sp& operator[](int idx) const;
 
+	T_sp* argArray() { return this->_Args; };
 
 	/*! Return the number of arguments */
 	virtual uint length() const { return this->_NumArgs; };
@@ -279,6 +208,7 @@
 	T_sp lookupValue(int depth, int index) const;
 	T_sp& lookupValueReference(int depth, int index) const;
 
+	virtual bool updateValue(Symbol_sp sym, T_sp obj );
 	virtual bool _findValue(Symbol_sp sym, int& depth, int& index, bool& special, T_sp& value) const;
 
 
@@ -294,21 +224,18 @@
 	void set_entry(uint idx, T_sp obj)
 	{_G();
 	    ASSERTF((int)idx < this->_NumArgs,BF("index[%d] out of range for writing to activation frame with %d slots") % idx% this->_NumArgs );
-	    WATCH_POINTER(this->_Args[idx]);
 	    this->_Args[idx] = obj;
 	}
 
 	T_sp entry(int idx) const
 	{_G();
-	    ASSERTF(idx < this->_NumArgs,BF("index[%d] out of range for writing to activation frame with %d slots") % idx% this->_NumArgs );
-	    WATCH_POINTER(this->_Args[idx]);
+	    ASSERTF(idx < this->_NumArgs,BF("index[%d] out of range for reading from activation frame with %d slots") % idx% this->_NumArgs );
 	    return this->_Args[idx];
 	}
 
 	virtual T_sp& entryReference(int idx) const
 	{_G();
 	    ASSERTF(idx < this->_NumArgs,BF("index[%d] out of range for writing to activation frame with %d slots") % idx% this->_NumArgs );
-	    WATCH_POINTER(this->_Args[idx]);
 	    return this->_Args[idx];
 	}
 
@@ -336,6 +263,7 @@
 	LISP_BASE1(ActivationFrame_O);
 	LISP_CLASS(core,CorePkg,FunctionFrame_O,"FunctionFrame");
     private:
+	ActivationFrame_sp	_ParentFrame;
 	int			_NumArgs;
 	core::T_sp*		_Args;
     public:
@@ -388,45 +316,20 @@
 	    return vf;
 	}
 
-	static FunctionFrame_sp create_fill(T_sp arg1,ActivationFrame_sp parent)
-	{_G();
-	    FunctionFrame_sp vf(FunctionFrame_O::create(parent));
-	    vf->allocateStorage(1);
-	    new (&(vf->_Args[0])) T_sp(arg1);
-	    return vf;
-	}
 
-	static FunctionFrame_sp create_fill(T_sp arg1,T_sp arg2,ActivationFrame_sp parent)
+	template <class ... ARGS>
+	static FunctionFrame_sp create_fill(ActivationFrame_sp parent, ARGS... args)
 	{_G();
-	    FunctionFrame_sp vf(FunctionFrame_O::create(parent));
-	    vf->allocateStorage(2);
-	    new (&(vf->_Args[0])) T_sp(arg1);
-	    new (&(vf->_Args[1])) T_sp(arg2);
+	    GC_RESERVE_BEGIN(FunctionFrame_O,vf) {
+		GC_RESERVE_GET(FunctionFrame_O,vf);
+		vf->_ParentFrame = parent;
+	    } GC_RESERVE_END(vf);
+	    vf->_NumArgs = sizeof...(ARGS);
+	    vf->_Args = new T_sp[sizeof...(ARGS)]{args...};
 	    return vf;
 	}
 
-	static FunctionFrame_sp create_fill(T_sp arg1,T_sp arg2,T_sp arg3,ActivationFrame_sp parent)
-	{_G();
-	    FunctionFrame_sp vf(FunctionFrame_O::create(parent));
-	    vf->allocateStorage(3);
-	    new (&(vf->_Args[0])) T_sp(arg1);
-	    new (&(vf->_Args[1])) T_sp(arg2);
-	    new (&(vf->_Args[2])) T_sp(arg3);
-	    return vf;
-	}
 
-	static FunctionFrame_sp create_fill(T_sp arg1,T_sp arg2,T_sp arg3,T_sp arg4,ActivationFrame_sp parent)
-	{_G();
-	    FunctionFrame_sp vf(FunctionFrame_O::create(parent));
-	    vf->allocateStorage(4);
-	    new (&(vf->_Args[0])) T_sp(arg1);
-	    new (&(vf->_Args[1])) T_sp(arg2);
-	    new (&(vf->_Args[2])) T_sp(arg3);
-	    new (&(vf->_Args[3])) T_sp(arg4);
-	    return vf;
-	}
-
-
 	FunctionFrame_O() : Base() {};
 	virtual ~FunctionFrame_O()
 	{
@@ -438,8 +341,12 @@
 	}
 
     public:
+	virtual ActivationFrame_sp& parentFrameRef() { return this->_ParentFrame; };
+	virtual ActivationFrame_sp parentFrame() const { return this->_ParentFrame; };
+
 	/*! Return the number of arguments */
 	virtual uint length() const { return this->_NumArgs; };
+	T_sp* argArray() { return this->_Args; };
 
 	bool boundp_entry(uint idx) const
 	{_G();
@@ -482,10 +389,13 @@
 	LISP_BASE1(ActivationFrame_O);
 	LISP_CLASS(core,CorePkg,TagbodyFrame_O,"TagbodyFrame");
     private:
+	ActivationFrame_sp	_ParentFrame;
 	T_sp 	_TagbodyId;
     public:
 	static TagbodyFrame_sp create(ActivationFrame_sp parent);
 
+	virtual ActivationFrame_sp& parentFrameRef() { return this->_ParentFrame; };
+	virtual ActivationFrame_sp parentFrame() const { return this->_ParentFrame; };
 	T_sp tagbodyId() const { return this->_TagbodyId;};
 
 	virtual string summaryOfContents() const;
@@ -504,56 +414,6 @@
 
 
 
-#if 0 // depreciated
 
-namespace core
-{
-    c l a s s BlockFrame_O : public ActivationFrame_O
-    {
-	L I S P_BASE1(ActivationFrame_O);
-	L I S P_CLASS(CorePkg,BlockFrame_O,"BlockFrame");
-    private:
-	Symbol_sp 		_BlockSymbol;
-    public:
-	static BlockFrame_sp create(ActivationFrame_sp parent)
-	{_G();
-	    GC_RESERVE_BEGIN(BlockFrame_O,vf) {
-		vf->_ParentFrame = parent;
-	    } GC_RESERVE_END(vf);
-	    return vf;
-	}
 
-	static BlockFrame_sp create(Symbol_sp blockSymbol,ActivationFrame_sp parent)
-	{_G();
-	    BlockFrame_sp vf(BlockFrame_O::create(parent));
-	    vf->_BlockSymbol = blockSymbol;
-	    return vf;
-	}
-
-
-	BlockFrame_O() : Base() {};
-	virtual ~BlockFrame_O() {};
-
-    public:
-
-	Symbol_sp getBlockSymbol() const { return this->_BlockSymbol;};
-	void setBlockSymbol(Symbol_sp sym) { this->_BlockSymbol = sym; };
-
-	string asString() const;
-    };
-};
-
-
-
-
-
-
-
-
-
 #endif
-
-
-
-
-#endif
Index: arguments.cc
===================================================================
--- arguments.cc	(revision 4737)
+++ arguments.cc	(working copy)
@@ -22,10 +22,10 @@
     {_G();
 	if ( this->_ArgTargetFrameIndex == SPECIAL_TARGET )
 	{
-	    return((Cons_O::create(_sym_specialVar,this->_ArgTarget,_lisp)));
+	    return((Cons_O::create(ext::_sym_specialVar,this->_ArgTarget,_lisp)));
 	} else if ( this->_ArgTargetFrameIndex >= 0 )
 	{
-	    return((Cons_O::create(_sym_lexicalVar,Cons_O::create(this->_ArgTarget,Fixnum_O::create(this->_ArgTargetFrameIndex),_lisp),_lisp)));
+	    return((Cons_O::create(ext::_sym_lexicalVar,Cons_O::create(this->_ArgTarget,Fixnum_O::create(this->_ArgTargetFrameIndex),_lisp),_lisp)));
 	} else if ( this->_ArgTargetFrameIndex == UNDEFINED_TARGET )
 	{
 	    return((_Nil<Cons_O>()));
@@ -194,6 +194,10 @@
 	SIMPLE_ERROR(BF("DynamicScopeManager doesn't bind anything other than SPECIAL_TARGET bindings - you gave it a binding to[%s] index[%d]") % _rep_(arg._ArgTarget) % arg._ArgTargetFrameIndex);
     }
 
+    Environment_sp DynamicScopeManager::lexenv() const
+    {
+	SIMPLE_ERROR(BF("A ValueEnvironment was requested from a DynamicScopeManager - only ValueEnvironmentDynamicScopeManagers have those"));
+    }
 
     DynamicScopeManager::~DynamicScopeManager()
     {
@@ -237,12 +241,12 @@
     void ValueEnvironmentDynamicScopeManager::new_variable(Cons_sp classified, T_sp val)
     {
 	Symbol_sp type = oCar(classified).as<Symbol_O>();
-	if ( type == _sym_specialVar )
+	if ( type == ext::_sym_specialVar )
 	{
 	    Symbol_sp sym = oCdr(classified).as<Symbol_O>();
 	    this->DynamicScopeManager::pushSpecialVariableAndSet(sym,val);
 	    return;
-	} else if ( type == _sym_lexicalVar )
+	} else if ( type == ext::_sym_lexicalVar )
 	{
 	    Symbol_sp sym = oCadr(classified).as<Symbol_O>();
 	    int idx = oCddr(classified).as<Fixnum_O>()->get();
@@ -290,7 +294,19 @@
     }
 
 
+    Environment_sp ActivationFrameDynamicScopeManager::lexenv() const
+    {
+//	SIMPLE_ERROR(BF("A ValueEnvironment was requested from a DynamicScopeManager... \n but only ValueEnvironmentDynamicScopeManagers have those.   \n On the other hand, ActivationFrameDynamicScopeManager::lexenv() \n should only be called when evaluating lambda-list init-forms \n (&optional,&key,&aux) and those should be evaluated in an environment \n that only has the lambda-list bindings in the top-level-environment \n - Since we attach the binding symbol names to the ActivationFrame we \n could just use the ActivationFrame of this ActivationFrameDynamicScopeManager \n as the environment that lexenv returns"));
+	// I'm going to return the ActivationFrame here and ASSERT that it must have debugging info
+	// attached.  I don't think the caller should be evaluating expressions in the environment
+	// represented by this->_Frame unless it has symbol names attached to it.
+	// I'm not sure the ActivationFrames with debugging information honor all of the
+	// variable/function lookup and update functions though so even with debugging information
+	// providing symbol names of variables it may not work - meister Nov 2013
+	return this->_Frame;
+    }
 
 
+
 	
 };
Index: arguments.h
===================================================================
--- arguments.h	(revision 4737)
+++ arguments.h	(working copy)
@@ -116,6 +116,9 @@
 	explicit DynamicScopeManager(Symbol_sp sym,T_sp newVal);
 
 	void dump() const;
+
+	virtual Environment_sp lexenv() const;
+
 	virtual ~DynamicScopeManager();
     };
 
@@ -133,7 +136,7 @@
 	void new_variable(Cons_sp classifiedVariable, T_sp val);
 	void new_special(Cons_sp classifiedVariable);
 	virtual bool lexicalElementBoundP(const Argument& argument);
-	ValueEnvironment_sp lexenv() const { return this->_Environment; };
+	virtual /*Value*/Environment_sp lexenv() const { return this->_Environment; };
     };
 
 
@@ -149,6 +152,7 @@
 	virtual void new_binding(const Argument& argument, T_sp val);
 	virtual bool lexicalElementBoundP(const Argument& argument);
 	ActivationFrame_sp activationFrame() const { return this->_Frame; };
+	virtual Environment_sp lexenv() const;
     };
 
 
Index: array.cc
===================================================================
--- array.cc	(revision 4737)
+++ array.cc	(working copy)
@@ -168,10 +168,12 @@
 
     int Array_O::index_val(Cons_sp indices,bool last_value_is_val, Cons_sp& val_cons) const
     {_OF();
+#ifdef DEBUG_ON
 	int indices_passed = af_length(indices) - (last_value_is_val ? 1 : 0 );
 	ASSERTF(indices_passed==(int)this->rank(),
 		BF("Wrong number of indices[%d] must match rank[%d]")
 		% indices_passed % this->rank() );
+#endif
 	int offset = 0;
 	int idx = -1;
 	Cons_sp cur;
@@ -295,7 +297,7 @@
 	    .def("fill-array-with-elt",&Array_O::fillArrayWithElt)
 	      .def("svref",&Array_O::svref)
 	      .def("setf-svref",&Array_O::setf_svref)
-	      .def("setf_rowMajorAref",&Array_O::setf_rowMajorAref)
+	      .def("rowMajorAset",&Array_O::rowMajorAset)
 	      .def("rowMajorAref",&Array_O::rowMajorAref)
 	      .def("arrayRowMajorIndex",&Array_O::arrayRowMajorIndex)
 	      .def("arrayHasFillPointerP",&Array_O::arrayHasFillPointerP)
Index: array.h
===================================================================
--- array.h	(revision 4737)
+++ array.h	(working copy)
@@ -38,7 +38,7 @@
     virtual bool arrayHasFillPointerP() const { return false;};
     virtual int arrayTotalSize() const;
 
-    virtual void setf_rowMajorAref( int idx, T_sp value) {SUBIMP();};
+    virtual void rowMajorAset( int idx, T_sp value) {SUBIMP();};
     virtual T_sp rowMajorAref(int idx) const {SUBIMP();};
     virtual int arrayRowMajorIndex(Cons_sp indices) const;
 
Index: arrayObjects.cc
===================================================================
--- arrayObjects.cc	(revision 4737)
+++ arrayObjects.cc	(working copy)
@@ -87,7 +87,7 @@
 
 
 
-    void ArrayObjects_O::setf_rowMajorAref(int idx, T_sp value)
+    void ArrayObjects_O::rowMajorAset(int idx, T_sp value)
     {_G();
 	ASSERTF(idx<this->_Values.size(),BF("Illegal row-major-aref index %d - must be less than %d") % idx % this->_Values.size() );
 	this->_Values[idx] = value;
Index: arrayObjects.h
===================================================================
--- arrayObjects.h	(revision 4737)
+++ arrayObjects.h	(working copy)
@@ -37,7 +37,7 @@
     virtual T_sp asetUnsafe(int j, T_sp val);
     T_sp elementType() const { return this->_ElementType;};
 
-	virtual void setf_rowMajorAref( int idx, T_sp value);
+	virtual void rowMajorAset( int idx, T_sp value);
 	virtual T_sp rowMajorAref(int idx) const;
 
     virtual int rank() const { return this->_Dimensions.size();};
Index: backquote.cc
===================================================================
--- backquote.cc	(revision 4737)
+++ backquote.cc	(working copy)
@@ -22,6 +22,7 @@
 #include "multipleValues.h"
 #include "environment.h"
 #include "backquote.h"
+#include "evaluator.h"
 #include "lispList.h"
 #include "primitives.h"
 #include "sequence.h"
Index: bformat.cc
===================================================================
--- bformat.cc	(revision 4737)
+++ bformat.cc	(working copy)
@@ -4,6 +4,7 @@
 #include "core/environment.h"
 #include "core/str.h"
 #include "core/symbolTable.h"
+#include "core/evaluator.h"
 #include "core/lispStream.h"
 #include "bformat.h"
 #include "bignum.h"
@@ -77,7 +78,9 @@
 		  }
 	if ( output == _lisp->_true() )
 	{
-	    eval::funcall(cl::_sym_write,Str_O::create(fmter_str));
+	    eval::funcall(cl::_sym_write,
+			  Str_O::create(fmter_str),
+			  kw::_sym_escape, _Nil<T_O>());
 	    return(Values(_Nil<T_O>()));
 	} else
 	{
Index: binder.cc
===================================================================
--- binder.cc	(revision 4737)
+++ binder.cc	(working copy)
@@ -5,6 +5,7 @@
 #include "core/common.h"
 #include "stringSet.h"
 #include "symbolTable.h"
+#include "serialize.h"
 #include "binder.h"
 #include "lambdaListHandler.h"
 #include "standardObject.h"
@@ -129,35 +130,13 @@
 
 
 
-#if defined(XML_ARCHIVE)
 void	Binder_O::archiveBase(ArchiveP node)
     {_G();
-	if ( node->saving() )
-	{ _BLOCK_TRACEF(BF("Saving %d entries") % this->_Bindings.size() );
-	    Binder_O::iterator	oi;
-	    for ( oi=this->_Bindings.begin(); oi!=this->_Bindings.end(); oi++ )
-	    { _BLOCK_TRACEF(BF("Archiving map entry with name(%s)") % _rep_(oi->first) );
-		T_sp val = this->indexed_value(oi->second);
-		node->archiveObject(oi->first->fullName(),val);
-	    }
-	} else
-	{ _BLOCK_TRACE("Loading node");
-	    this->_Bindings.clear();
-	    VectorNodes::iterator	ci;
-	    string	key;
-	    T_sp object;
-	    for ( ci=node->begin_Children(); ci!=node->end_Children(); ci++ )
-	    {
-		object = node->loadObjectDirectly(*ci);
-		ASSERTNOTNULL(object);
-		key = (*ci)->getUniqueIdCharactersIfMissingThrow();
-		Symbol_sp sym = _lisp->intern(key);
-		this->_Bindings.set(sym,object);
-		(*ci)->setRecognized(true);
-	    }
-	}
+	node->attributeIndexedSymbolMap(KW("data"),this->_Bindings);
     }
-#endif // defined(XML_ARCHIVE)
+
+
+
 #if 0
     Render_sp Binder_O::rendered(Cons_sp kargs)
     {_G();
Index: binder.h
===================================================================
--- binder.h	(revision 4737)
+++ binder.h	(working copy)
@@ -72,9 +72,7 @@
 	DECLARE_SERIALIZE();
 #endif // defined(OLD_SERIALIZE)
     public:
-#if defined(XML_ARCHIVE)
 	void archiveBase(ArchiveP node);
-#endif // defined(XML_ARCHIVE)
     private:
 	IndexedSymbolMap<T_O>	_Bindings;
     public:
Index: bitVector.cc
===================================================================
--- bitVector.cc	(revision 4737)
+++ bitVector.cc	(working copy)
@@ -30,11 +30,12 @@
 
 
 
-    SimpleBitVector_sp SimpleBitVector_O::create(int size, Lisp_sp lisp)
+    SimpleBitVector_sp SimpleBitVector_O::create(int size)
     {_G();
 	GC_RESERVE_BEGIN(SimpleBitVector_O,sbv ){
 	    GC_RESERVE_GET(SimpleBitVector_O,sbv );
 	} GC_RESERVE_END(sbv );
+	sbv->_Length = size;
 	sbv->bits.resize(((size-1)/CHAR_BIT)+1,0);
 	return((sbv));
     }
@@ -52,6 +53,7 @@
     SimpleBitVector_O::SimpleBitVector_O(const SimpleBitVector_O& bv) : T_O(bv), BitVector_O(bv)
     {_OF();
 	uint	i;
+	this->_Length = bv._Length;
 	this->bits.resize(bv.bits.size());
 	for (i=0; i<this->bits.size(); i++ ) {
 	    this->bits[i] = bv.bits[i];
@@ -65,6 +67,21 @@
 
 
 
+    void SimpleBitVector_O::rowMajorAset(int idx, T_sp value)
+    {_G();
+	ASSERTF(idx<this->length(),BF("Index %d is out of range (<%d)") % idx % this->length() );
+	this->setBit(idx,value.isTrue());
+    }
+
+    T_sp SimpleBitVector_O::rowMajorAref(int idx) const
+    {_G();
+	ASSERTF(idx<this->length(),BF("Index %d is out of range (<%d)") % idx % this->length() );
+	uint val = this->testBit(idx);
+	return (val!=0) ? _lisp->_true() : _Nil<T_O>();
+    }
+
+
+
 void SimpleBitVector_O::getOnIndices(vector<uint>& res)
 {_G();
 uint		i;
Index: bitVector.h
===================================================================
--- bitVector.h	(revision 4737)
+++ bitVector.h	(working copy)
@@ -43,11 +43,14 @@
     LISP_BASE1(BitVector_O);
     LISP_CLASS(core,ClPkg,SimpleBitVector_O,"simple-bit-vector");
 private:
-	vector<unsigned char>		bits;
+    uint 				_Length;
+    vector<unsigned char>		bits;
 public:
-    static SimpleBitVector_sp create(int size,Lisp_sp lisp);
+    static SimpleBitVector_sp create(int size);
 public:
 
+    uint dimension() const { return this->_Length;};
+
     void	getOnIndices(vector<uint>& vals);
 	void		setOnIndices(const vector<uint>& indices );
 
@@ -96,6 +99,12 @@
     virtual T_sp setElementObject(uint index, T_sp val);
 #endif
 
+    virtual void rowMajorAset( int idx, T_sp value);
+    virtual T_sp rowMajorAref(int idx) const;
+
+
+
+
     explicit SimpleBitVector_O(): T_O(), BitVector_O() {} ;
     SimpleBitVector_O(const SimpleBitVector_O& bv);
     virtual ~SimpleBitVector_O() {};
Index: bundle.cc
===================================================================
--- bundle.cc	(revision 4737)
+++ bundle.cc	(working copy)
@@ -210,7 +210,7 @@
 	char* lispdir = getenv("BRCL_LISP_SOURCE_DIR");
 	if ( lispdir != NULL )
 	{
-	    printf("Using BRCL_LISP_SOURCE_DIR --> %s\n", lispdir );
+//	    printf("Using BRCL_LISP_SOURCE_DIR --> %s\n", lispdir );
 	    this->_LispDir = boost_filesystem::path(lispdir);
 	}
     }
Index: character.cc
===================================================================
--- character.cc	(revision 4738)
+++ character.cc	(working copy)
@@ -258,9 +258,9 @@
 #define LOCK_af_charEqual 1
 #define ARGS_af_charEqual "(&rest args)"
 #define DECL_af_charEqual ""
-    T_mv af_charEqual(Cons_sp args)
+    bool af_charEqual(Cons_sp args)
     {_G();
-	if ( args.nilp() ) return(Values(_lisp->_true()));
+	if ( args.nilp() ) return true;
 	int a = oCar(args).as<Character_O>()->get();
 	a = toupper(a);
 	args = cCdr(args);
@@ -268,10 +268,10 @@
 	{
 	    int b = oCar(args).as<Character_O>()->get();
 	    b = toupper(b);
-	    if ( a!=b ) return(Values(_Nil<T_O>()));
+	    if ( a!=b ) return false;
 	    args = cCdr(args);
 	}
-	return(Values(_lisp->_true()));
+	return true;
     };
 
 
@@ -551,14 +551,14 @@
 
 
 
-#define DOCS_af_char_name "char_name"
-#define LOCK_af_char_name 1
-#define ARGS_af_char_name "(och)"
-#define DECL_af_char_name ""
-    T_mv af_char_name(Character_sp och)
+#define DOCS_cl_char_name "char_name"
+#define LOCK_cl_char_name 1
+#define ARGS_cl_char_name "(och)"
+#define DECL_cl_char_name ""
+    Str_sp cl_char_name(Character_sp och)
 	{_G();
 	    char ch = och->asChar();
-	    return(Values(static_CharacterInfo->gCharacterNames[ch]));
+	    return(static_CharacterInfo->gCharacterNames[ch]);
 	};
 
 
@@ -586,7 +586,7 @@
 	SYMBOL_EXPORT_SC_(ClPkg,name_char);
 	Defun(name_char);
 	SYMBOL_EXPORT_SC_(ClPkg,char_name);
-	Defun(char_name);
+	ClDefun(char_name);
 	SYMBOL_EXPORT_SC_(ClPkg,alpha_char_p);
 	Defun(alpha_char_p);
 	SYMBOL_EXPORT_SC_(ClPkg,standard_char_p);
@@ -690,6 +690,15 @@
     {_OF();
 	return this->eql(other);
     }
+
+
+    bool Character_O::equalp(T_sp other) const
+    {_OF();
+	if ( Character_sp cother = other.as<Character_O>() ) {
+	    return ( toupper(cother->asChar()) == toupper(this->asChar()) );
+	}
+	return false;
+    }
     
 
 
@@ -812,7 +821,7 @@
 	    ss << this->_Value;
 	} else
 	{
-	    ss << af_char_name(this->const_sharedThis<StandardChar_O>());
+	    ss << cl_char_name(this->const_sharedThis<StandardChar_O>());
 	}
 	return ss.str();
     }
Index: character.h
===================================================================
--- character.h	(revision 4738)
+++ character.h	(working copy)
@@ -7,6 +7,8 @@
 #include "core/character.fwd.h"
 namespace core
 {
+    Str_sp cl_char_name(Character_sp och);
+
     int brcl_string_case(Str_sp s);
 
     bool af_standard_char_p(Character_sp ch);
@@ -49,6 +51,7 @@
 	virtual bool alphanumericp() const {SUBIMP();};
 	virtual bool graphicCharP() const {SUBIMP();};
 	virtual bool equal(T_sp other) const;
+	virtual bool equalp(T_sp other) const;
 	virtual int toInt() const {SUBIMP();};
 	int charCode() const { return this->toInt(); };
 	void __write__(Stream_sp sout) const; // Look in write_ugly.cc
Index: closPackage.cc
===================================================================
--- closPackage.cc	(revision 4737)
+++ closPackage.cc	(working copy)
@@ -24,8 +24,7 @@
     void initialize_closPackage()
     {
 	list<string> lnicknames;
-	list<core::Package_sp> luse;
-	luse.push_front(_lisp->findPackage("COMMON-LISP"));
+	list<string> luse = {"COMMON-LISP"};
 	_lisp->makePackage("CLOS",lnicknames,luse);
 	// We don't have to create the CLOS symbols here - it's done in bootStrapCoreSymbolMap
     }
Index: commandLineOptions.cc
===================================================================
--- commandLineOptions.cc	(revision 4737)
+++ commandLineOptions.cc	(working copy)
@@ -12,7 +12,8 @@
 								     _ExecCode(""),
 								     _GotRandomNumberSeed(false),
 								     _RandomNumberSeed(0),
-								     _Interactive(true)
+								     _Version(false),
+								     _SilentStartup(true)
 
 #if 0   // uses boost::program_options which is broken on OS X with -std=c++11
     {
@@ -156,8 +157,27 @@
 	int iarg = 1;
 	while (iarg<argc) {
 	    string arg = argv[iarg];
-	    if ( arg == "-I" || arg == "--image" ) {
+	    if ( arg == "-h" || arg == "--help" ) {
+		printf("brcl options\n"
+		       "-I/--ignore-image  - ignore the boot image\n"
+		       "-v/--version       - print version\n"
+		       "-s/--verbose       - print more info as booting\n"
+		       "-f/--feature feature - Add the feature to *features*\n"
+		       "-e/--exec cmd        - Execute a command\n"
+		       "-l/--load file       - LOAD the file\n"
+		       "-n/--noload          - Don't load the init.lsp (very bare start)\n"
+		       "-s/--seed #          - Seed the random number generator\n"
+		       "{ARGS}*              - Add arguments to core:*command-line-arguments*\n"
+		       "Run with brcl -I -f ecl-min to bootstrap minimal image\n"
+		       "Run with brcl -f ecl-min to load minimal image and compile full image\n"
+		       "Run with brcl to run and load full image\n");
+		exit(1);
+	    } else if ( arg == "-I" || arg == "--ignore-mage" ) {
 		this->_IgnoreInitImage = true;
+	    } else if ( arg == "-v" || arg == "--version" ) {
+		this->_Version = true;
+	    } else if ( arg == "-s" || arg == "--verbose" ) {
+		this->_SilentStartup = false;
 	    } else if ( arg == "-f" || arg == "--feature" ) {
 		ASSERTF(iarg<(argc+1),BF("Missing argument for --feature,-f"));
 		this->_Features.push_back(argv[iarg+1]);
@@ -166,13 +186,15 @@
 		ASSERTF(iarg<(argc+1),BF("Missing argument for --exec,-e"));
 		this->_ExecCode = argv[iarg+1];
 		iarg++;
+	    } else if ( arg == "-l" || arg == "--load" ) {
+		ASSERTF(iarg<(argc+1),BF("Missing argument for --load,-l"));
+		this->_LoadFile = argv[iarg+1];
+		iarg++;
 	    } else if ( arg == "-n" || arg == "--noload") {
 		this->_DontLoadInit = true;
 	    } else if ( arg == "-s" || arg == "--seed") {
 		this->_RandomNumberSeed = atoi(argv[iarg+1]);
 		iarg++;
-	    } else if ( arg == "-i" || arg == "--not-interactive" ) {
-		this->_Interactive = false;
 	    } else {
 		this->_Args.push_back(arg);
 	    }
Index: commandLineOptions.h
===================================================================
--- commandLineOptions.h	(revision 4737)
+++ commandLineOptions.h	(working copy)
@@ -11,9 +11,12 @@
     bool 		_IgnoreInitImage;
     std::vector<std::string>	_Features;
     std::string 		_ExecCode;
+    std::string 		_LoadFile;
     bool 		_GotRandomNumberSeed;
     long		_RandomNumberSeed;
     bool		_Interactive;
+    bool 		_Version;
+    bool 		_SilentStartup;
     std::vector<std::string>	_Args;
 };
 
Index: commonLispPackage.cc
===================================================================
--- commonLispPackage.cc	(revision 4737)
+++ commonLispPackage.cc	(working copy)
@@ -32,10 +32,9 @@
 
     core::Package_sp initialize_commonLispPackage()
     {
-	list<string> lnicknames;
-	list<core::Package_sp> luse;
-	lnicknames.push_front("CL");
-	return _lisp->makePackage("COMMON-LISP",lnicknames,luse);
+	list<string> lnicknames = {"COMMON-LISP"};
+	list<string> luse;
+	return _lisp->makePackage("CL",lnicknames,luse);
     }
 
 
Index: commonLispPackage.fwd.h
===================================================================
--- commonLispPackage.fwd.h	(revision 4737)
+++ commonLispPackage.fwd.h	(working copy)
@@ -1,7 +1,7 @@
 #ifndef commonLispPackage_fwd_H
 #define commonLispPackage_fwd_H
 
-NAMESPACE_PACKAGE_ASSOCIATION(cl,ClPkg,"COMMON-LISP")
+NAMESPACE_PACKAGE_ASSOCIATION(cl,ClPkg,"CL")
 
 
 
Index: commonLispUserPackage.cc
===================================================================
--- commonLispUserPackage.cc	(revision 4737)
+++ commonLispUserPackage.cc	(working copy)
@@ -22,11 +22,8 @@
 
     void initialize_commonLispUserPackage()
     {
-	list<string> lnicknames;
-	list<core::Package_sp> luse;
-	luse.push_front(_lisp->findPackage("COMMON-LISP"));
-	lnicknames.push_front("USER");
-	lnicknames.push_front("CL-USER");
+	list<string> lnicknames = { "USER", "CL-USER" };
+	list<string> luse = { "COMMON-LISP"};
 	_lisp->makePackage("COMMON-LISP-USER",lnicknames,luse);
 	// We don't have to create the COMMONLISPUSER symbols here - it's done in bootStrapCoreSymbolMap
     }
Index: compPackage.cc
===================================================================
--- compPackage.cc	(revision 4737)
+++ compPackage.cc	(working copy)
@@ -23,10 +23,8 @@
 
     void initialize_compPackage()
     {
-	list<string> lnicknames;
-	lnicknames.push_front("CMP");
-	list<core::Package_sp> luse;
-	luse.push_front(_lisp->findPackage("COMMON-LISP"));
+	list<string> lnicknames = { "CMP" };
+	list<string> luse = {"COMMON-LISP", "EXT"};
 	_lisp->makePackage("COMPILER",lnicknames,luse);
 	// We don't have to create the COMPILER symbols here - it's done in bootStrapCoreSymbolMap
     }
Index: compiler.cc
===================================================================
--- compiler.cc	(revision 4737)
+++ compiler.cc	(working copy)
@@ -5,6 +5,7 @@
 #include "core/environment.h"
 #include "fileSystem.h"
 #include "designators.h"
+#include "evaluator.h"
 #include "symbolTable.h"
 #include "core/str.h"
 #include "compiler.h"
@@ -32,7 +33,23 @@
 
 
 
+    T_sp varArgsList(int n_args, ... )
+    {
+	va_list ap;
+	va_start(ap, n_args);
+	Cons_O::CdrType_sp first = _Nil<Cons_O::CdrType_O>();
+	Cons_O::CdrType_sp* cur = &first;
+	for(int i = 1; i <= n_args; i++) {
+	    T_sp obj = *(va_arg(ap, const T_sp*));
+	    Cons_sp one = Cons_O::create(obj);
+	    *cur = one;
+	    cur = one->cdrPtr();
+	}
+	va_end(ap);
+	return first;
+    }
 
+
     
     
 #define ARGS_af_loadBundle "(name &optional init-fn-name)"
@@ -88,7 +105,7 @@
 	{
 	    SIMPLE_ERROR(BF("Could not find initialization function %s") % mainName );
 	}
-	printf("Found function %s at address %p\n", mainName.c_str(), fnP);
+//	printf("Found function %s at address %p\n", mainName.c_str(), fnP);
 	T_mv result;
 	ActivationFrame_sp frame = _Nil<ActivationFrame_O>();
 	(*fnP)(&result,&frame);
@@ -144,7 +161,7 @@
 		SIMPLE_ERROR(BF("Could not find initialization function %s or %s") % kernelInitName % userInitName );
 	    }
 	}
-	printf("Found function %s at address %p\n", initName.c_str(), fnP);
+//	printf("Found function %s at address %p\n", initName.c_str(), fnP);
 	T_mv result;
 	ActivationFrame_sp frame = _Nil<ActivationFrame_O>();
 	(*fnP)(&result,&frame);
Index: compiler.h
===================================================================
--- compiler.h	(revision 4737)
+++ compiler.h	(working copy)
@@ -8,6 +8,11 @@
 {
 
 
+    T_sp varArgsList(int numArgs, ... );
+
+
+
+
     T_mv af_implicit_compile_hook_default(T_sp form, Environment_sp env);
 
     void initialize_compiler_primitives(Lisp_sp lisp);
Index: conditions.cc
===================================================================
--- conditions.cc	(revision 4737)
+++ conditions.cc	(working copy)
@@ -19,6 +19,7 @@
 #include "symbolTable.h"
 #include "lispStream.h"
 #include "bformat.h"
+#include "evaluator.h"
 #include "str.h"
 #include "object.h"
 #include "lisp.h"
Index: config.h
===================================================================
--- config.h	(revision 4739)
+++ config.h	(working copy)
@@ -58,4 +58,9 @@
 //#define BRCL_LONG_FLOAT 1
 
 
+#define BRCL_ARRAY_DIMENSION_LIMIT (1024*1024)
+
+/*! Maximum number of arguments that can be passed */
+#define CALL_ARGUMENTS_LIMIT	64
+
 #endif
Index: cons.cc
===================================================================
--- cons.cc	(revision 4738)
+++ cons.cc	(working copy)
@@ -9,6 +9,8 @@
 #include "cons.h"
 #include "core/predicates.h"
 #include "symbolTable.h"
+#include "serialize.h"
+#include "evaluator.h"
 #include "environment.h"
 #include "designators.h"
 #include "executables.h"
@@ -270,11 +272,11 @@
 		{
 		    SIMPLE_ERROR(BF("both test and test-not were defined"));
 		}
-		this->_test_func = coerce::functionDesignator(testNot,_lisp);
+		this->_test_func = coerce::functionDesignator(testNot);
 		this->_test_pass = false;
 	    } else if ( test.notnilp() )
 	    {
-		this->_test_func = coerce::functionDesignator(test,_lisp);
+		this->_test_func = coerce::functionDesignator(test);
 	    } else
 	    {
 		this->_test_func = cl::_sym_eql->symbolFunction();
@@ -283,7 +285,7 @@
 	    if ( key.notnilp() )
 	    {
 		this->_use_key_func = true;
-		this->_key_func = coerce::functionDesignator(key,_lisp);
+		this->_key_func = coerce::functionDesignator(key);
 	    } else this->_key_func = _Nil<Function_O>();
 	    this->_item = item;
 	    if ( apply_key_to_item && this->_key_func.notnilp() )
@@ -507,14 +509,11 @@
 /*! Write out all of the elements of this list as a list to
  * avoid excessive nesting
  */
-#if defined(XML_ARCHIVE)
-void	Cons_O::archiveBase(::core::ArchiveP node)
+    void Cons_O::archiveBase(ArchiveP node)
     {_G();
-	node->archiveObjectIfDefined("car",this->_Car);
-	node->archiveObjectIfDefined("cdr",this->_Cdr);
-	node->attribute("cdrl",this->_CdrLength);
+	node->attributeIfNotNil("A",this->_Car); // use attributeIfNotNil
+	node->attributeIfNotNil("D",this->_Cdr); // use attributeIfNotNil
     }
-#endif // defined(XML_ARCHIVE)
 
     SYMBOL_EXPORT_SC_(ClPkg,getf);
     T_sp Cons_O::getf(T_sp key, T_sp defVal) const
@@ -534,8 +533,8 @@
     void Cons_O::serialize(serialize::SNode node)
     {_OF();
 	node->attribute("cdrl",this->_CdrLength);
-	node->archiveObjectIfDefined("car",this->_Car);
-	node->archiveObjectIfDefined("cdr",this->_Cdr);
+	node->attributeIfNotNil("car",this->_Car);
+	node->attributeIfNotNil("cdr",this->_Cdr);
     }
 #endif
 
@@ -1450,7 +1449,7 @@
     }
 
 
-    CompiledBody_sp CompiledBody_O::create(Functoid* functoid, T_sp compiledFuncs, Lisp_sp lisp)
+    CompiledBody_sp CompiledBody_O::create(Functoid* functoid, T_sp compiledFuncs)
     {_G();
 	GC_RESERVE_BEGIN(CompiledBody_O,cb ){
 	    GC_RESERVE_GET(CompiledBody_O,cb );
Index: cons.h
===================================================================
--- cons.h	(revision 4738)
+++ cons.h	(working copy)
@@ -101,13 +101,16 @@
 	friend Cons_sp cCdddr(T_sp o);
 	friend Cons_sp cCddddr(T_sp o);
     public:
-#if defined(XML_ARCHIVE)
 	void	archiveBase(ArchiveP node);
-#endif // defined(XML_ARCHIVE)
 	void	initialize();
+    public:
+	typedef T_O	CarType_O;
+	typedef T_O	CdrType_O;
+	typedef T_sp 	CarType_sp;
+	typedef T_sp 	CdrType_sp;
     protected:
-	T_sp	_Car;
-	T_sp	_Cdr;
+	CarType_sp	_Car;
+	CdrType_sp	_Cdr;
 	/*! Keep track of the length of the cons along the cdr chain
 	 * every time the cdr is set add 1 to the length of the cons
 	 * being added and store that here.  This will keep a running
@@ -196,6 +199,10 @@
 
 	T_sp elt(int index) const;
 	T_sp setf_elt(int index, T_sp value);
+
+
+	CdrType_sp* cdrPtr() { return &(this->_Cdr);};
+
 	/* TODO:
 	   Remove the following member functions and replace them
 	   with the real functions  oCar, oCdr, cCdr etc */
@@ -660,7 +667,7 @@
 	explicit CompiledBody_O();
 	virtual ~CompiledBody_O();
     public:
-	static CompiledBody_sp create(Functoid* functoid, T_sp compiledFunctions, Lisp_sp lisp);
+	static CompiledBody_sp create(Functoid* functoid, T_sp compiledFunctions);
     public:
 	void initialize();
     private: // instance variables here
Index: corePackage.cc
===================================================================
--- corePackage.cc	(revision 4739)
+++ corePackage.cc	(working copy)
@@ -46,6 +46,15 @@
 {
     const char* CorePkg_nicknames[] = { "SYSTEM", "sys", "SYS", "si", "SI", "" /*guard*/ };
 
+    SYMBOL_EXPORT_SC_(ExtPkg,truly_the);
+    SYMBOL_EXPORT_SC_(ExtPkg,specialVar);
+    SYMBOL_EXPORT_SC_(ExtPkg,lexicalVar);
+
+    SYMBOL_SC_(CorePkg,STARdebugMonitorSTAR);
+    SYMBOL_SC_(CorePkg,monitorReader);
+    SYMBOL_EXPORT_SC_(CorePkg,STARcommandLineLoadSTAR);
+    SYMBOL_EXPORT_SC_(CorePkg,STARserializerArchiveSTAR);
+    SYMBOL_EXPORT_SC_(KeywordPkg,_uid);
     SYMBOL_EXPORT_SC_(CorePkg,STARihsCurrentSTAR);
     SYMBOL_EXPORT_SC_(ClPkg,logicalPathnameTranslations);
     SYMBOL_EXPORT_SC_(ClPkg,set);
@@ -164,7 +173,7 @@
     SYMBOL_EXPORT_SC_(ClPkg,char);
 
 
-
+    SYMBOL_EXPORT_SC_(KeywordPkg,escape);
     SYMBOL_EXPORT_SC_(ClPkg,write);
     SYMBOL_SC_(KeywordPkg,capitalize);
     SYMBOL_EXPORT_SC_(ClPkg,STARreadDefaultFloatFormatSTAR);
@@ -241,8 +250,6 @@
     SYMBOL_SC_(CorePkg,globalFunction);
     SYMBOL_SC_(CorePkg,globalSetfFunction);
     SYMBOL_SC_(CorePkg,lexicalFunction);
-    SYMBOL_SC_(CorePkg,specialVar);
-    SYMBOL_SC_(CorePkg,lexicalVar);
     SYMBOL_SC_(CorePkg,declaredSpecial);
     SYMBOL_SC_(CorePkg,lexical);
     SYMBOL_EXPORT_SC_(ClPkg,stream);
@@ -382,7 +389,6 @@
     SYMBOL_SC_(KeywordPkg,changed);
     SYMBOL_SC_(CorePkg,dot);
     SYMBOL_EXPORT_SC_(ClPkg,STARfeaturesSTAR);
-    SYMBOL_EXPORT_SC_(ClPkg,STARreadtableSTAR);
     SYMBOL_EXPORT_SC_(ClPkg,STARload_printSTAR);
     SYMBOL_EXPORT_SC_(ClPkg,STARload_verboseSTAR);
     SYMBOL_SC_(CorePkg,ifDoesNotExist);
@@ -442,7 +448,7 @@
 
     CoreExposer::CoreExposer(Lisp_sp lisp) : PackageExposer(lisp,CorePkg,CorePkg_nicknames)
     {
-	this->package()->usePackage(_lisp->findPackage("COMMON-LISP"));
+	this->package()->usePackage(_lisp->findPackage("CL"));
     };
 
 
@@ -674,6 +680,21 @@
 	cl::_sym_char_code_limit->defconstant(Fixnum_O::create(128));
 	cl::_sym_STARgensym_counterSTAR->defparameter(Fixnum_O::create(0));
 	cl::_sym_STARdefaultPathnameDefaultsSTAR->defparameter(_Nil<T_O>());
+	cl::_sym_STARprint_arraySTAR->defparameter(_Nil<T_O>());
+	cl::_sym_STARprint_baseSTAR->defparameter(Fixnum_O::create(10));
+	cl::_sym_STARprint_caseSTAR->defparameter(kw::_sym_upcase);
+	cl::_sym_STARprint_circleSTAR->defparameter(_Nil<T_O>());
+	cl::_sym_STARprint_escapeSTAR->defparameter(_lisp->_true());
+	cl::_sym_STARprint_gensymSTAR->defparameter(_lisp->_true());
+	cl::_sym_STARprint_lengthSTAR->defparameter(_Nil<T_O>());
+	cl::_sym_STARprint_levelSTAR->defparameter(_Nil<T_O>());
+	cl::_sym_STARprint_linesSTAR->defparameter(_Nil<T_O>());
+	cl::_sym_STARprint_miser_widthSTAR->defparameter(_Nil<T_O>());
+	cl::_sym_STARprint_pprint_dispatchSTAR->defparameter(_Nil<T_O>());
+	cl::_sym_STARprint_prettySTAR->defparameter(_Nil<T_O>());
+	cl::_sym_STARprint_radixSTAR->defparameter(_Nil<T_O>());
+	cl::_sym_STARprint_readablySTAR->defparameter(_Nil<T_O>());
+	cl::_sym_STARprint_right_marginSTAR->defparameter(_Nil<T_O>());
 	Stream_sp stdin_stream = FDInStream_O::create(stdin,"*STDIN*",false);
 	Stream_sp stdout_stream = FDOutStream_O::create(stdout,"*STDOUT*",false);
 	_sym_STARstdinSTAR->defparameter(stdin_stream);
@@ -706,21 +727,6 @@
 	cl::_sym_STARdebuggerHookSTAR->defparameter(_Nil<T_O>());
 
 
-	cl::_sym_STARprint_arraySTAR->defparameter(_Nil<T_O>());
-	cl::_sym_STARprint_baseSTAR->defparameter(Fixnum_O::create(10));
-	cl::_sym_STARprint_caseSTAR->defparameter(kw::_sym_upcase);
-	cl::_sym_STARprint_circleSTAR->defparameter(_Nil<T_O>());
-	cl::_sym_STARprint_escapeSTAR->defparameter(_lisp->_true());
-	cl::_sym_STARprint_gensymSTAR->defparameter(_lisp->_true());
-	cl::_sym_STARprint_lengthSTAR->defparameter(_Nil<T_O>());
-	cl::_sym_STARprint_levelSTAR->defparameter(_Nil<T_O>());
-	cl::_sym_STARprint_linesSTAR->defparameter(_Nil<T_O>());
-	cl::_sym_STARprint_miser_widthSTAR->defparameter(_Nil<T_O>());
-	cl::_sym_STARprint_pprint_dispatchSTAR->defparameter(_Nil<T_O>());
-	cl::_sym_STARprint_prettySTAR->defparameter(_Nil<T_O>());
-	cl::_sym_STARprint_radixSTAR->defparameter(_Nil<T_O>());
-	cl::_sym_STARprint_readablySTAR->defparameter(_Nil<T_O>());
-	cl::_sym_STARprint_right_marginSTAR->defparameter(_Nil<T_O>());
 	cl::_sym_MultipleValuesLimit->defconstant(Fixnum_O::create(MultipleValues::MultipleValuesLimit));
 	_sym_STARprintStructureSTAR->defparameter(_Nil<T_O>());
 	_sym_STARprintPackageSTAR->defparameter(_Nil<T_O>());
@@ -735,6 +741,9 @@
 	_sym_STARtopLevelCommandHookSTAR->defparameter(_Nil<T_O>());
 	_sym_STARllvmFunctionNameHookSTAR->defparameter(_Nil<T_O>());
 	_sym_STARihsCurrentSTAR->defparameter(_Nil<T_O>());
+	_sym_STARserializerArchiveSTAR->defparameter(_Nil<T_O>());
+	_sym_STARcommandLineLoadSTAR->defparameter(_Nil<T_O>());
+	_sym_STARdebugMonitorSTAR->defparameter(_Nil<T_O>());
 	Cons_sp hooks = Cons_O::createList(
 	    Cons_O::create(Str_O::create("l"),_sym_loadSource),
 	    Cons_O::create(Str_O::create("L"),_sym_loadSource),
Index: debugger.cc
===================================================================
--- debugger.cc	(revision 4739)
+++ debugger.cc	(working copy)
@@ -9,6 +9,7 @@
 #include "myReadLine.h"
 #include "symbolTable.h"
 #include "sourceFileInfo.h"
+#include "evaluator.h"
 #include "environment.h"
 #include "debugger.h"
 #include "wrappers.h"
@@ -383,6 +384,10 @@
     {
 	Defun(backtrace);
 	Defun(framePointers);
+	SYMBOL_EXPORT_SC_(CorePkg,printCurrentIhsFrameEnvironment);
+	Defun(printCurrentIhsFrameEnvironment);
+
+
     }
 
 };
Index: designators.cc
===================================================================
--- designators.cc	(revision 4738)
+++ designators.cc	(working copy)
@@ -17,7 +17,7 @@
     namespace coerce
     {	
 	
-	Function_sp functionDesignator(T_sp obj, Lisp_sp lisp)
+	Function_sp functionDesignator(T_sp obj)
 	{_G();
 	    if ( obj.nilp() ) {
 		SIMPLE_ERROR(BF("You tried to treat nil as a function designator"));
Index: designators.h
===================================================================
--- designators.h	(revision 4737)
+++ designators.h	(working copy)
@@ -3,6 +3,7 @@
 
 #include "core/object.h"
 #include "corePackage.fwd.h"
+#include "pathname.h"
 
 namespace core
 {
@@ -18,7 +19,7 @@
 	   definition as a function, or it has a global definition as a macro or a special form.
 	   See also extended function designator.
 	*/
-	extern Function_sp functionDesignator(T_sp obj, Lisp_sp lisp);
+	extern Function_sp functionDesignator(T_sp obj);
 
 
 	/*! Return a Path by interpreting a pathname designator */
Index: documentation.cc
===================================================================
--- documentation.cc	(revision 4737)
+++ documentation.cc	(working copy)
@@ -7,6 +7,7 @@
 #include "core/hashTableEql.h"
 #include "core/multipleValues.h"
 #include "core/environment.h"
+#include "core/evaluator.h"
 #include "documentation.h"
 #include "core/wrappers.h"
 namespace core
Index: environment.cc
===================================================================
--- environment.cc	(revision 4737)
+++ environment.cc	(working copy)
@@ -22,7 +22,17 @@
 
 
 
+    
+    
+#define ARGS_af_countFunctionContainerEnvironments "(arg)"
+#define DECL_af_countFunctionContainerEnvironments ""
+#define DOCS_af_countFunctionContainerEnvironments "countFunctionContainerEnvironments"
+    T_mv af_countFunctionContainerEnvironments()
+    {_G();
+	IMPLEMENT_MEF(BF("Implement countFunctionContainerEnvironments"));
+    };
 
+
     
     
 #define ARGS_af_environmentActivationFrame "(env)"
@@ -464,11 +474,11 @@
 	T_sp value;
 	if ( this->findValue(sym,depth,index,special,value) )
 	{
-	    return Cons_O::createList(_sym_lexicalVar,sym,Fixnum_O::create(depth),Fixnum_O::create(index));
+	    return Cons_O::createList(ext::_sym_lexicalVar,sym,Fixnum_O::create(depth),Fixnum_O::create(index));
 	}
 	if ( special )
 	{
-	    return Cons_O::create(_sym_specialVar,sym,_lisp);
+	    return Cons_O::create(ext::_sym_specialVar,sym,_lisp);
 	}
 	// Lexical variable was not found - return nil
 	return _Nil<Cons_O>();
@@ -1021,10 +1031,10 @@
 	{
 	    Cons_sp classifiedSymbol = oCar(cur).as_or_nil<Cons_O>();
 	    Symbol_sp classification = oCar(classifiedSymbol).as<Symbol_O>();
-	    if ( classification == _sym_lexicalVar )
+	    if ( classification == ext::_sym_lexicalVar )
 	    {
 		++numberOfLexicals;
-	    } else if ( classification == _sym_specialVar )
+	    } else if ( classification == ext::_sym_specialVar )
 	    {
 		// handle special declarations
 		Symbol_sp sym = oCdr(classifiedSymbol).as<Symbol_O>();
Index: environment.h
===================================================================
--- environment.h	(revision 4737)
+++ environment.h	(working copy)
@@ -839,7 +839,11 @@
 
 
 
+namespace core {
+    T_sp af_environmentActivationFrame(Environment_sp env);
+	};
 
+
 #endif //]
 
 
Index: evaluator.cc
===================================================================
--- evaluator.cc	(revision 4737)
+++ evaluator.cc	(working copy)
@@ -58,7 +58,7 @@
 	try {_BLOCK_TRACEF(BF("-eval/print stage-"));
 	    ValueFrame_sp vf = ValueFrame_O::create(0,_Nil<ActivationFrame_O>());
 	    
-	    result = eval::apply(thunk,vf);
+	    result = eval::applyToActivationFrame(thunk,vf);
 	    LOG(BF("---result[%s]") % _rep_(result) );
 	}
 	catch (Condition& err)
@@ -131,6 +131,7 @@
 	    }
 	}
 	Function_sp fn = name->symbolFunction();
+	
 	return fn;
     };
 
@@ -291,6 +292,7 @@
 
 	void setq_symbol_value(Symbol_sp symbol, T_sp value, Environment_sp environment)
 	{
+	    Environment_sp localEnv(environment);
 	    if ( symbol->specialP() || (environment.notnilp() && environment->lexicalSpecialP(symbol) ))
 	    {
 		symbol->setf_symbolValue(value);
@@ -757,6 +759,7 @@
 */
 	T_mv sp_progn(Cons_sp args, Environment_sp environment)
 	{_G();
+	    Environment_sp localEnv(environment);
 	    return eval::evaluateListReturnLast(args,environment);
 	}
 
@@ -959,7 +962,6 @@
 
 
 #define DOCS_sp_tagbody "tagbody special form - see CLHS"
-#define ARGS_sp_tagbodyf ""
 	T_mv sp_tagbody( Cons_sp args, Environment_sp env)
 	{_G();
 	    TagbodyEnvironment_sp tagbodyEnv = TagbodyEnvironment_O::make(env);
@@ -1015,7 +1017,6 @@
 	};
 	
 #define DOCS_sp_go "go special form - see CLHS"
-#define ARGS_sp_go ""
 	T_mv sp_go( Cons_sp args, Environment_sp env)
 	{_G();
 	    Symbol_sp tag = oCar(args).as<Symbol_O>();
@@ -1051,11 +1052,11 @@
 		Symbol_sp sym = oCar(cur).as<Symbol_O>();
 		if ( specialsSet->contains(sym) )
 		{
-		    classified << Cons_O::create(core::_sym_specialVar,sym,_lisp);
+		    classified << Cons_O::create(ext::_sym_specialVar,sym,_lisp);
 		    specialInVariables->insert(sym);
 		} else if ( sym->specialP() )
 		{
-		    classified << Cons_O::create(core::_sym_specialVar,sym,_lisp);
+		    classified << Cons_O::create(ext::_sym_specialVar,sym,_lisp);
 		    specialInVariables->insert(sym);
 		} else
 		{
@@ -1068,7 +1069,7 @@
 			indices->hash_table_setf_gethash(sym,Fixnum_O::create(idx));
 			++indicesSize;
 		    }
-		    classified << Cons_O::create(_sym_lexicalVar,
+		    classified << Cons_O::create(ext::_sym_lexicalVar,
 						 Cons_O::create(sym,Fixnum_O::create(idx),_lisp),_lisp);
 		}
 	    }
@@ -1131,7 +1132,7 @@
 	    {
 		Cons_sp classified = oCar(curClassified).as_or_nil<Cons_O>();
 		Symbol_sp shead = oCar(classified).as<Symbol_O>();
-		if ( shead == _sym_specialVar || shead == _sym_lexicalVar )
+		if ( shead == ext::_sym_specialVar || shead == ext::_sym_lexicalVar )
 		{
 		    T_sp expr = oCar(curExp);
 		    T_sp result = eval::evaluate(expr,evaluateEnvironment);
@@ -1141,7 +1142,7 @@
 		{
 		    scope.new_special(classified);
 		}
-		if ( shead == _sym_lexicalVar )
+		if ( shead == ext::_sym_lexicalVar )
 		{
 		    debuggingInfo->setf_elt(debugInfoIndex,oCadr(classified));
 		    debugInfoIndex++;
@@ -1202,16 +1203,10 @@
 	    }
 	    if ( res.isTrue() )
 	    {
-#ifdef DELOC_PUSH
-		PushCodeStack codeStack(args->ocadr(),environment,_lisp);
-#endif
 		return eval::evaluate(oCadr(args),environment);
 	    } else
 	    { if ( cCdr(cCdr(args)).notnilp() )
 		{
-#ifdef DELOC_PUSH
-		    PushCodeStack codeStack(args->ocaddr(),environment,_lisp);
-#endif
 		    return eval::evaluate(oCaddr(args),environment);
 		}
 	    }
@@ -1294,9 +1289,6 @@
 	    T_mv result = Values(_Nil<T_O>());
 	    if ( cCdr(args).notnilp() )
 	    {
-#ifdef DELOC_PUSH
-		PushCodeStack stack(args->ocadr(),environment,_lisp);
-#endif
 		result = eval::evaluate(oCadr(args),environment);
 	    }
 	    if ( environment->recognizesBlockSymbol(blockSymbol) )
@@ -1425,7 +1417,7 @@
 		}
 	    }
 	    ValueFrame_sp vf = ValueFrame_O::create(resultList.cons(),Environment_O::nilCheck_getActivationFrame(env));
-	    T_mv result = eval::apply(func,vf);
+	    T_mv result = eval::applyToActivationFrame(func,vf);
 	    return(result);
 	}
 
@@ -1510,7 +1502,7 @@
 		T_sp fn = af_interpreter_lookup_function(fnSymbol,environment);
 		if (!fn.pointerp())
 		{
-		    SIMPLE_ERROR(BF("Could not find function %s") % _rep_(fnSymbol) );
+		    SIMPLE_ERROR(BF("Could not find function %s args: %s") % _rep_(fnSymbol) % _rep_(args) );
 		}
 		LOG(BF("     Found form: %s") % fn->__repr__() );
 		return(Values(fn));
@@ -1523,7 +1515,7 @@
 		    T_sp fn = af_interpreter_lookup_setf_function(consArg,environment);
 		    if ( fn.nilp() )
 		    {
-			SIMPLE_ERROR(BF("Could not find function %s") % _rep_(consArg) );
+			SIMPLE_ERROR(BF("Could not find function %s args: %s") % _rep_(consArg) % _rep_(args) );
 		    }
 		    return(Values(fn));
 		} else if ( head == cl::_sym_lambda || head == ext::_sym_lambda_block)
@@ -1570,7 +1562,6 @@
 
 
 #if 0
-#define ARGS_sp_lambda_block ""
 #define DOCS_sp_lambda_block "Like lambda but the first argument is a symbol that defines the name of the lambda"
 	T_mv sp_lambda_block( Cons_sp args, Environment_sp env)
 	{_G();
@@ -1581,7 +1572,6 @@
 #endif
 
 #if 0
-#define ARGS_sp_lambda_with_handler ""
 #define DOCS_sp_lambda_with_handler "Like lambda but the first argument is a symbol that defines the name of the lambda and the second argument is a lambda-list-handler rather than a lambda-list"
 	T_mv sp_lambda_with_handler( Cons_sp args, Environment_sp env)
 	{_G();
@@ -1640,11 +1630,7 @@
 					   % _rep_(target) % _rep_(args) );
 		    }
 		    T_sp expr = oCadr(pairs);
-		    T_sp texpr;
-		    T_sp val;
-		    {MULTIPLE_VALUES_CONTEXT();
-			texpr = af_macroexpand(symbol,environment);
-		    }
+		    T_sp texpr = af_macroexpand(symbol,environment);
 		    if ( texpr != symbol )
 		    {
 			// The target symbol was a symbol-macro so we
@@ -1881,250 +1867,40 @@
 
 
 
-	T_mv applyFunctionToActivationFrame(Function_sp head, const_ActivationFrame_spREF args)
-	{_G();
-	    LOG(BF("About to carry out apply head[%s] of class[%s] with functionp(%d) and symbolp(%d) to args: %s")
-		% head->__repr__()
-		% head->__class()->instanceClassName()
-		% af_functionP(head) % af_symbolp(head)
-		% _rep_(args) );
-	    T_mv result;
-	    try
-	    {
-		result = head->INVOKE(args);
-	    } catch (Condition& err)
-	    {
-		THROW_HARD_ERROR(BF("Figure out what to do here"));
-	    }
-	    ASSERTNOTNULL(result);
-	    return(result);
-	}
 
 
 
 
-	T_mv apply(T_sp funcDesig, T_sp arg0, Cons_sp argsRest)
+	Function_sp lookupFunction(T_sp functionDesignator, Environment_sp env)
 	{_G();
-	    ValueFrame_sp vf(ValueFrame_O::create(1+af_length(argsRest),_Nil<ActivationFrame_O>()));
-	    vf->set_entry(0,arg0);
-	    vf->fillRestOfEntries(1,argsRest);
-	    return eval::apply(funcDesig,vf);
+	    ASSERTF(functionDesignator,BF("In apply, the head function designator is UNDEFINED"));
+	    if ( Function_sp exec = functionDesignator.asOrNull<Function_O>() ) return exec;
+	    Symbol_sp shead = functionDesignator.as<Symbol_O>();
+	    Function_sp exec = af_interpreter_lookup_function(shead,env);
+	    return exec;
 	}
 
-	T_mv apply(T_sp funcDesig, T_sp arg0, T_sp arg1, Cons_sp argsRest)
-	{_G();
-	    ValueFrame_sp vf(ValueFrame_O::create( 2 + af_length(argsRest),_Nil<ActivationFrame_O>()));
-	    vf->set_entry(0,arg0);
-	    vf->set_entry(1,arg1);
-	    vf->fillRestOfEntries(2,argsRest);
-	    return eval::apply(funcDesig,vf);
-	}
 
-	T_mv apply(T_sp funcDesig, T_sp arg0, T_sp arg1, T_sp arg2, Cons_sp argsRest)
-	{_G();
-	    ValueFrame_sp vf(ValueFrame_O::create( 3 + af_length(argsRest),_Nil<ActivationFrame_O>()));
-	    vf->set_entry(0,arg0);
-	    vf->set_entry(1,arg1);
-	    vf->set_entry(2,arg2);
-	    vf->fillRestOfEntries(3,argsRest);
-	    return eval::apply(funcDesig,vf);
-	}
 
-
-	T_mv apply(T_sp funcDesig, T_sp arg0, T_sp arg1, T_sp arg2, T_sp arg3, Cons_sp argsRest)
+	T_mv applyToActivationFrame(T_sp head,const_ActivationFrame_spREF args )
 	{_G();
-	    ValueFrame_sp vf(ValueFrame_O::create( 4 + af_length(argsRest),_Nil<ActivationFrame_O>()));
-	    vf->set_entry(0,arg0);
-	    vf->set_entry(1,arg1);
-	    vf->set_entry(2,arg2);
-	    vf->set_entry(3,arg3);
-	    vf->fillRestOfEntries(4,argsRest);
-	    return eval::apply(funcDesig,vf);
-	}
-
-	T_mv apply(T_sp funcDesig, T_sp arg0, T_sp arg1, T_sp arg2, T_sp arg3, T_sp arg4, Cons_sp argsRest)
-	{_G();
-	    ValueFrame_sp vf(ValueFrame_O::create( 5 + af_length(argsRest),_Nil<ActivationFrame_O>()));
-	    vf->set_entry(0,arg0);
-	    vf->set_entry(1,arg1);
-	    vf->set_entry(2,arg2);
-	    vf->set_entry(3,arg3);
-	    vf->set_entry(4,arg4);
-	    vf->fillRestOfEntries(5,argsRest);
-	    return eval::apply(funcDesig,vf);
-	}
-
-	T_mv apply(T_sp funcDesig, T_sp arg0, T_sp arg1, T_sp arg2, T_sp arg3, T_sp arg4, T_sp arg5, Cons_sp argsRest)
-	{_G();
-	    ValueFrame_sp vf(ValueFrame_O::create( 6 + af_length(argsRest),_Nil<ActivationFrame_O>()));
-	    vf->set_entry(0,arg0);
-	    vf->set_entry(1,arg1);
-	    vf->set_entry(2,arg2);
-	    vf->set_entry(3,arg3);
-	    vf->set_entry(4,arg4);
-	    vf->set_entry(5,arg5);
-	    vf->fillRestOfEntries(6,argsRest);
-	    return eval::apply(funcDesig,vf);
-	}
-
-	T_mv apply(T_sp funcDesig, T_sp arg0, T_sp arg1, T_sp arg2, T_sp arg3, T_sp arg4, T_sp arg5, T_sp arg6, Cons_sp argsRest)
-	{_G();
-	    ValueFrame_sp vf(ValueFrame_O::create( 7 + af_length(argsRest),_Nil<ActivationFrame_O>()));
-	    vf->set_entry(0,arg0);
-	    vf->set_entry(1,arg1);
-	    vf->set_entry(2,arg2);
-	    vf->set_entry(3,arg3);
-	    vf->set_entry(4,arg4);
-	    vf->set_entry(5,arg5);
-	    vf->set_entry(6,arg6);
-	    vf->fillRestOfEntries(7,argsRest);
-	    return eval::apply(funcDesig,vf);
-	}
-
-
-	T_mv apply(T_sp funcDesig, T_sp arg0, T_sp arg1, T_sp arg2, T_sp arg3, T_sp arg4, T_sp arg5, T_sp arg6, T_sp arg7, Cons_sp argsRest)
-	{_G();
-	    ValueFrame_sp vf(ValueFrame_O::create( 8 + af_length(argsRest),_Nil<ActivationFrame_O>()));
-	    vf->set_entry(0,arg0);
-	    vf->set_entry(1,arg1);
-	    vf->set_entry(2,arg2);
-	    vf->set_entry(3,arg3);
-	    vf->set_entry(4,arg4);
-	    vf->set_entry(5,arg5);
-	    vf->set_entry(6,arg6);
-	    vf->set_entry(7,arg7);
-	    vf->fillRestOfEntries(8,argsRest);
-	    return eval::apply(funcDesig,vf);
-	}
-
-	T_mv apply(T_sp funcDesig, T_sp arg0, T_sp arg1, T_sp arg2, T_sp arg3, T_sp arg4, T_sp arg5, T_sp arg6, T_sp arg7, T_sp arg8, Cons_sp argsRest)
-	{_G();
-	    ValueFrame_sp vf(ValueFrame_O::create( 9 + af_length(argsRest),_Nil<ActivationFrame_O>()));
-	    vf->set_entry(0,arg0);
-	    vf->set_entry(1,arg1);
-	    vf->set_entry(2,arg2);
-	    vf->set_entry(3,arg3);
-	    vf->set_entry(4,arg4);
-	    vf->set_entry(5,arg5);
-	    vf->set_entry(6,arg6);
-	    vf->set_entry(7,arg7);
-	    vf->set_entry(8,arg8);
-	    vf->fillRestOfEntries(9,argsRest);
-	    return eval::apply(funcDesig,vf);
-	}
-
-
-	T_mv apply(T_sp head,const_ActivationFrame_spREF args )
-	{_G();
-	    ASSERTF(head,BF("In apply, the head function designator is UNDEFINED"));
-	    if ( Symbol_sp shead = head.asOrNull<Symbol_O>() )
+	    Function_sp fn = lookupFunction(head,args);
+	    if ( !fn.pointerp() )
 	    {
-		LOG(BF("About to carry out apply head symbol[%s] to args: %s")
-		    % _rep_(head)
-		    % _rep_(args) );
-		{ _BLOCK_TRACEF(BF("Evaluating form[%s] with args[%s]") % shead->__repr__() % args->__repr__() );
-		    Function_sp exec = af_interpreter_lookup_function(shead,_Nil<Environment_O>());
-		    if ( !exec.pointerp() )
-		    {
-			if ( shead == cl::_sym_findClass )
-			{
-			    // When booting, cl::_sym_findClass may be apply'd but not
-			    // defined yet
-			    return(af_findClass(args->entry(0).as<Symbol_O>(),true,_Nil<Environment_O>()));
-			}
-			SIMPLE_ERROR(BF("Could not find function[%s]") % shead->fullName());
-		    }
-		    T_mv result = applyFunctionToActivationFrame(exec,args);
-		    return(result);
-		}
-	    } else if ( Function_sp exec = head.asOrNull<Function_O>() )
-	    {
-#if 0 // this should only be done in af_apply
-		/* Generic function dispatch - if APPLY gets one argument and its
-		   an ActivationFrame then apply the function to that
-		*/
-		if ( af_length(args) == 1 && args->entry(0).notnilp() )
+		if ( head == cl::_sym_findClass )
 		{
-		    if ( ActivationFrame_sp singleFrameArgument = args->entry(0).asOrNull<ActivationFrame_O>())
-		    {
-			return(applyFunctionToActivationFrame(exec,singleFrameArgument));
-		    }
+		    // When booting, cl::_sym_findClass may be apply'd but not
+		    // defined yet
+		    return(af_findClass(args->entry(0).as<Symbol_O>(),true,_Nil<Environment_O>()));
 		}
-#endif
-		return(applyFunctionToActivationFrame(exec,args));
+		SIMPLE_ERROR(BF("Could not find function %s args: %s") % _rep_(head) % _rep_(args));
 	    }
-	    SIMPLE_ERROR(BF("Illegal head for a form[%s] class(%s)" " - it should be a symbol or function") % _rep_(head) % head->_instanceClass()->classNameAsString() );
+	    return fn->INVOKE(args->length(),args->argArray()); // return applyFunctionToActivationFrame(fn,args);
 	}
 
 
 
-	
-/*! Invoke a function with given arguments */
-	T_mv funcall(T_sp fnDesig)
-	{_G();
-	    ValueFrame_sp frame(ValueFrame_O::create(0,_Nil<ActivationFrame_O>()));
-	    return eval::apply(fnDesig,frame);
-	}
 
-
-/*! Invoke a function with given arguments */
-	T_mv funcall(T_sp fnDesig,T_sp arg1)
-	{_G();
-	    ValueFrame_sp frame(ValueFrame_O::create_fill(arg1,_Nil<ActivationFrame_O>()));
-	    return eval::apply(fnDesig,frame);
-	}
-
-
-/*! Invoke a function with given arguments */
-	T_mv funcall(T_sp fnDesig, T_sp arg1,T_sp arg2 )
-	{
-	    ValueFrame_sp frame(ValueFrame_O::create_fill(arg1,arg2,_Nil<ActivationFrame_O>()));
-	    return eval::apply(fnDesig,frame);
-	}
-/*! Invoke a function with given arguments */
-	T_mv funcall(T_sp fnDesig, T_sp arg1,T_sp arg2,T_sp arg3 )
-	{
-	    ValueFrame_sp frame(ValueFrame_O::create_fill(arg1,arg2,arg3,_Nil<ActivationFrame_O>()));
-	    return eval::apply(fnDesig,frame);
-	}
-/*! Invoke a function with given arguments */
-	T_mv funcall(T_sp fnDesig, T_sp arg1,T_sp arg2,T_sp arg3,T_sp arg4 )
-	{
-	    ValueFrame_sp frame(ValueFrame_O::create_fill(arg1,arg2,arg3,arg4,_Nil<ActivationFrame_O>()));
-	    return eval::apply(fnDesig,frame);
-	}
-
-	T_mv funcall(T_sp fnDesig, T_sp arg1,T_sp arg2,T_sp arg3,T_sp arg4, T_sp arg5 )
-	{
-	    ValueFrame_sp frame(ValueFrame_O::create_fill(arg1,arg2,arg3,arg4,arg5,_Nil<ActivationFrame_O>()));
-	    return eval::apply(fnDesig,frame);
-	}
-
-	T_mv funcall(T_sp fnDesig, T_sp arg1,T_sp arg2,T_sp arg3,T_sp arg4, T_sp arg5, T_sp arg6 )
-	{
-	    ValueFrame_sp frame(ValueFrame_O::create_fill(arg1,arg2,arg3,arg4,arg5,arg6,_Nil<ActivationFrame_O>()));
-	    return eval::apply(fnDesig,frame);
-	}
-
-	T_mv funcall(T_sp fnDesig, T_sp arg1,T_sp arg2,T_sp arg3,T_sp arg4, T_sp arg5, T_sp arg6, T_sp arg7 )
-	{
-	    ValueFrame_sp frame(ValueFrame_O::create_fill(arg1,arg2,arg3,arg4,arg5,arg6,arg7,_Nil<ActivationFrame_O>()));
-	    return eval::apply(fnDesig,frame);
-	}
-
-	T_mv funcall(T_sp fnDesig, T_sp arg1,T_sp arg2,T_sp arg3,T_sp arg4, T_sp arg5, T_sp arg6, T_sp arg7, T_sp arg8 )
-	{
-	    ValueFrame_sp frame(ValueFrame_O::create_fill(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,_Nil<ActivationFrame_O>()));
-	    return eval::apply(fnDesig,frame);
-	}
-
-	T_mv funcall(T_sp fnDesig, T_sp arg1,T_sp arg2,T_sp arg3,T_sp arg4, T_sp arg5, T_sp arg6, T_sp arg7, T_sp arg8, T_sp arg9 )
-	{
-	    ValueFrame_sp frame(ValueFrame_O::create_fill(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,_Nil<ActivationFrame_O>()));
-	    return eval::apply(fnDesig,frame);
-	}
-
-
 /*!
  * This method:
  * 1) evaluates the arguments
@@ -2224,7 +2000,7 @@
 		    }
 		    ValueFrame_sp evaluatedArgs(ValueFrame_O::create(af_length(cCdr(form)),_Nil<ActivationFrame_O>()));
 		    evaluateIntoActivationFrame(evaluatedArgs,cCdr(form),environment);
-		    try { result = eval::apply(headCons,evaluatedArgs);}
+		    try { result = eval::applyToActivationFrame(headCons,evaluatedArgs);}
 		    catch (...) { result = handleConditionInEvaluate(environment);};
 		}
 	    } else
@@ -2291,6 +2067,7 @@
 
 	T_mv evaluate(T_sp exp, Environment_sp environment)
 	{_G();
+	    Environment_sp localEnvironment = environment;
 	    T_mv result;
 	    af_stackMonitor();
 	    EvaluateDepthUpdater evaluateDepthUpdater;
@@ -2309,6 +2086,8 @@
 	    // If it reached here then exp is a cons
 	    //
 //	    LOG(BF("Evaluating cons[%s]") % exp->__repr__() );
+//	    printf("    Evaluating: %s\n", _rep_(exp).c_str() );
+//	    printf("    In env: %s\n", _rep_(environment).c_str() );
 	    Cons_sp form = exp.asOrNull<Cons_O>();
 	    ASSERTNOTNULL(form);
 	    T_sp head = oCar(form);
@@ -2359,6 +2138,7 @@
 		    if ( !result ) goto NULL_RESULT;
 		    return(result);
 		}
+		Environment_sp localEnv(environment);
 		headFunc = af_interpreter_lookup_function(headSym,environment);
 		if ( !headFunc.pointerp() )
 		{
@@ -2373,9 +2153,10 @@
 //		LOG(BF("Symbol[%s] is a normal form - evaluating arguments") % head->__repr__() );
 		if ( af_functionP(headFunc) )
 		{
-		    ValueFrame_sp evaluatedArgs(ValueFrame_O::create(af_length(cCdr(form)),_Nil<ActivationFrame_O>()));
+		    ValueFrame_sp evaluatedArgs(ValueFrame_O::create(af_length(cCdr(form)),
+								     _Nil<ActivationFrame_O>()));
 		    evaluateIntoActivationFrame(evaluatedArgs,cCdr(form),environment);
-		    try { result = eval::applyFunctionToActivationFrame(headFunc,evaluatedArgs);}
+		    try { result = headFunc->INVOKE(evaluatedArgs->length(),evaluatedArgs->argArray()); } // result = eval::applyFunctionToActivationFrame(headFunc,evaluatedArgs);}
 		    catch (...) {result = handleConditionInEvaluate(environment);};
 		    if ( !result ) goto NULL_RESULT;
 		    return(result);
@@ -2396,7 +2177,8 @@
 
 
 
-	void evaluateIntoActivationFrame(const_ActivationFrame_spREF af, Cons_sp args, Environment_sp environment )
+	void evaluateIntoActivationFrame(const_ActivationFrame_spREF af,
+					 Cons_sp args, Environment_sp environment )
 	{_G();
 	    if ( args.nilp() )
 	    {
@@ -2412,10 +2194,6 @@
 		for ( Cons_sp p=args; p.notnilp(); p=cCdr(p) )
 		{
 		    T_sp inObj = oCar(p);
-		    LOG(BF("Pushing code onto the backTrace: <%s>")%_rep_(p) );
-#ifdef DELOC_PUSH
-		    PushCodeStack pushCodeStack(p,environment,_lisp);
-#endif
 		    T_sp result = eval::evaluate(inObj,environment);
 		    ASSERTNOTNULL(result);
 		    LOG(BF("After evaluation result = %s")% _rep_(result) );
@@ -2509,50 +2287,49 @@
 
 
 
-	void defineSpecialFormsAndMacros(Package_sp pkg)
+	void defineSpecialOperatorsAndMacros(Package_sp pkg)
 	{_G();
 	    SYMBOL_EXPORT_SC_(ClPkg,block);
 	    SYMBOL_EXPORT_SC_(ClPkg,quote);
 	    SYMBOL_EXPORT_SC_(ClPkg,progn);
 	    SYMBOL_EXPORT_SC_(ClPkg,throw);
-	    _lisp->defineSpecialForm("special-var", &sp_specialVar);
-	    _lisp->defineSpecialForm("lexical-var", &sp_lexicalVar);
-	    _lisp->defineSpecialForm("block", &sp_block);
-	    _lisp->defineSpecialForm("catch",&sp_catch);
-	    _lisp->defineSpecialForm("eval-when",&sp_eval_when);
-	    _lisp->defineSpecialForm("dbg-i32",&sp_dbg_i32);
-	    _lisp->defineSpecialForm("flet", &sp_flet);
-	    _lisp->defineSpecialForm("function",&sp_function);
-	    _lisp->defineSpecialForm("the",&sp_the);
-	    _lisp->defineSpecialForm("truly-the",&sp_the); // SBCL defined truly-the as a 
-	    _lisp->defineSpecialForm("go",&sp_go);
-	    _lisp->defineSpecialForm("if",&sp_if);
-	    _lisp->defineSpecialForm("labels", &sp_labels);
-	    _lisp->defineSpecialForm("let", &sp_let);
-	    _lisp->defineSpecialForm("let*", &sp_letSTAR);
-	    _lisp->defineSpecialForm("locally",&sp_locally);
-	    _lisp->defineSpecialForm("macrolet", &sp_macrolet);
-	    _lisp->defineSpecialForm("multipleValueProg1",&sp_multipleValueProg1);
-	    _lisp->defineSpecialForm("multipleValueCall",&sp_multipleValueCall);
-	    _lisp->defineSpecialForm("progn",&sp_progn);
-	    _lisp->defineSpecialForm("progv",&sp_progv);
-	    _lisp->defineSpecialForm("quote",&sp_quote);
-	    _lisp->defineSpecialForm("return-from",&sp_returnFrom);
-	    _lisp->defineSpecialForm("setq",&sp_setq);
-	    _lisp->defineSpecialForm("tagbody",&sp_tagbody);
-	    _lisp->defineSpecialForm("throw",&sp_throw);
-	    _lisp->defineSpecialForm("unwind-protect",&sp_unwindProtect);
-	    _lisp->defineSpecialForm("symbol-macrolet",&sp_symbolMacrolet);
-	    _lisp->defineSpecialForm("load-time-value",&sp_loadTimeValue);
+	    _lisp->defineSpecialOperator(ExtPkg,"special-var", &sp_specialVar);
+	    _lisp->defineSpecialOperator(ExtPkg,"lexical-var", &sp_lexicalVar);
+	    _lisp->defineSpecialOperator(ClPkg,"block", &sp_block);
+	    _lisp->defineSpecialOperator(ClPkg,"catch",&sp_catch);
+	    _lisp->defineSpecialOperator(ClPkg,"eval-when",&sp_eval_when);
+//	    _lisp->defineSpecialOperator(ExtPkg,"dbg-i32",&sp_dbg_i32);
+	    _lisp->defineSpecialOperator(ClPkg,"flet", &sp_flet);
+	    _lisp->defineSpecialOperator(ClPkg,"function",&sp_function);
+	    _lisp->defineSpecialOperator(ClPkg,"the",&sp_the);
+	    // SBCL defined truly-the as a special operator
+	    _lisp->defineSpecialOperator(ExtPkg,"truly-the",&sp_the);
+	    _lisp->defineSpecialOperator(ClPkg,"go",&sp_go);
+	    _lisp->defineSpecialOperator(ClPkg,"if",&sp_if);
+	    _lisp->defineSpecialOperator(ClPkg,"labels", &sp_labels);
+	    _lisp->defineSpecialOperator(ClPkg,"let", &sp_let);
+	    _lisp->defineSpecialOperator(ClPkg,"let*", &sp_letSTAR);
+	    _lisp->defineSpecialOperator(ClPkg,"locally",&sp_locally);
+	    _lisp->defineSpecialOperator(ClPkg,"macrolet", &sp_macrolet);
+	    _lisp->defineSpecialOperator(ClPkg,"multipleValueProg1",&sp_multipleValueProg1);
+	    _lisp->defineSpecialOperator(ClPkg,"multipleValueCall",&sp_multipleValueCall);
+	    _lisp->defineSpecialOperator(ClPkg,"progn",&sp_progn);
+	    _lisp->defineSpecialOperator(ClPkg,"progv",&sp_progv);
+	    _lisp->defineSpecialOperator(ClPkg,"quote",&sp_quote);
+	    _lisp->defineSpecialOperator(ClPkg,"return-from",&sp_returnFrom);
+	    _lisp->defineSpecialOperator(ClPkg,"setq",&sp_setq);
+	    _lisp->defineSpecialOperator(ClPkg,"tagbody",&sp_tagbody);
+	    _lisp->defineSpecialOperator(ClPkg,"throw",&sp_throw);
+	    _lisp->defineSpecialOperator(ClPkg,"unwind-protect",&sp_unwindProtect);
+	    _lisp->defineSpecialOperator(ClPkg,"symbol-macrolet",&sp_symbolMacrolet);
+	    _lisp->defineSpecialOperator(ClPkg,"load-time-value",&sp_loadTimeValue);
 // missing special operator load-time-value
 // missing progv
 
 
 
 // These need to be converted to macros
-//	    _lisp->defineSpecialForm("defClass",&sp_defClass);
-//	    _lisp->defineSpecialForm("handler-case", &sp_handlerCase );
-	    _lisp->defineSpecialForm("step",&sp_step);
+//	    _lisp->defineSpecialOperator(ExtPkg,"step",&sp_step);
 
 	    SYMBOL_SC_(CorePkg,processDeclarations);
 	    Defun(processDeclarations);
Index: evaluator.fwd.h
===================================================================
--- evaluator.fwd.h	(revision 4737)
+++ evaluator.fwd.h	(working copy)
@@ -11,16 +11,11 @@
 */
 //extern T_sp apply(T_sp functionDesignator, Cons_sp args, Lisp_sp lisp);
 
-	extern T_mv applyFunctionToActivationFrame(Function_sp func, const_ActivationFrame_spREF args );
+//	extern T_mv applyFunctionToActivationFrame(Function_sp func, const_ActivationFrame_spREF args );
 
 	extern T_mv sp_trace( Cons_sp args, Environment_sp env );
 	extern T_mv sp_untrace( Cons_sp args, Environment_sp env );
 
-	extern T_mv funcall(T_sp desig );
-	extern T_mv funcall(T_sp desig, T_sp arg1 );
-	extern T_mv funcall(T_sp desig, T_sp arg1, T_sp arg2 );
-	extern T_mv funcall(T_sp desig, T_sp arg1, T_sp arg2, T_sp arg3 );
-	extern T_mv funcall(T_sp desig, T_sp arg1, T_sp arg2, T_sp arg3, T_sp arg4 );
 
     };
 };
Index: evaluator.h
===================================================================
--- evaluator.h	(revision 4737)
+++ evaluator.h	(working copy)
@@ -6,6 +6,11 @@
 #include "ql.h"
 #include "evaluator.fwd.h"
 #include "activationFrame.h"
+
+namespace cl {
+    extern core::Symbol_sp _sym_findClass;
+};
+
 namespace core
 {
 
@@ -26,61 +31,234 @@
 
 
 
-/*! See the CLHS for "apply" - all arguments are in args 
-  (functionDesignator) can be a Symbol or an Function
-*/
 
-	extern T_mv apply(T_sp functionDesignator, const_ActivationFrame_spREF af);
 
-	extern T_mv apply(T_sp funcDesic, T_sp arg0, Cons_sp argsRest );
-	extern T_mv apply(T_sp funcDesic, T_sp arg0, T_sp arg1, Cons_sp argsRest );
-	extern T_mv apply(T_sp funcDesic, T_sp arg0, T_sp arg1, T_sp arg2, Cons_sp argsRest );
-	extern T_mv apply(T_sp funcDesic, T_sp arg0, T_sp arg1, T_sp arg2, T_sp arg3, Cons_sp argsRest );
-	extern T_mv apply(T_sp funcDesic, T_sp arg0, T_sp arg1, T_sp arg2, T_sp arg3, T_sp arg4, Cons_sp argsRest );
-	extern T_mv apply(T_sp funcDesic, T_sp arg0, T_sp arg1, T_sp arg2, T_sp arg3, T_sp arg4, T_sp arg5, Cons_sp argsRest );
-	extern T_mv apply(T_sp funcDesic, T_sp arg0, T_sp arg1, T_sp arg2, T_sp arg3, T_sp arg4, T_sp arg5, T_sp arg6, Cons_sp argsRest );
-	extern T_mv apply(T_sp funcDesic, T_sp arg0, T_sp arg1, T_sp arg2, T_sp arg3, T_sp arg4, T_sp arg5, T_sp arg6, T_sp arg7, Cons_sp argsRest );
-	extern T_mv apply(T_sp funcDesic, T_sp arg0, T_sp arg1, T_sp arg2, T_sp arg3, T_sp arg4, T_sp arg5, T_sp arg6, T_sp arg7, T_sp arg8, Cons_sp argsRest );
 
-	/* Add more of these apply functions */
 
+	extern Cons_sp evaluateList(Cons_sp args, Environment_sp environment);
+	extern T_mv evaluateListReturnLast(Cons_sp args, Environment_sp environment);
 
-	extern T_mv funcall(T_sp funcDesig);
-	extern T_mv funcall(T_sp funcDesig, T_sp arg0);
-	extern T_mv funcall(T_sp funcDesig, T_sp arg0, T_sp arg1);
-	extern T_mv funcall(T_sp funcDesig, T_sp arg0, T_sp arg1, T_sp arg2);
-	extern T_mv funcall(T_sp funcDesig, T_sp arg0, T_sp arg1, T_sp arg2, T_sp arg3);
-	extern T_mv funcall(T_sp funcDesig, T_sp arg0, T_sp arg1, T_sp arg2, T_sp arg3, T_sp arg4);
-	extern T_mv funcall(T_sp funcDesig, T_sp arg0, T_sp arg1, T_sp arg2, T_sp arg3, T_sp arg4, T_sp arg5);
-	extern T_mv funcall(T_sp funcDesig, T_sp arg0, T_sp arg1, T_sp arg2, T_sp arg3, T_sp arg4, T_sp arg5, T_sp arg6);
-	extern T_mv funcall(T_sp funcDesig, T_sp arg0, T_sp arg1, T_sp arg2, T_sp arg3, T_sp arg4, T_sp arg5, T_sp arg6, T_sp arg7);
-	extern T_mv funcall(T_sp funcDesig, T_sp arg0, T_sp arg1, T_sp arg2, T_sp arg3, T_sp arg4, T_sp arg5, T_sp arg6, T_sp arg7, T_sp arg8);
 
+	extern T_mv sp_progn(Cons_sp code, Environment_sp env);
+	extern T_mv sp_setq(Cons_sp args, Environment_sp environment);
 
 
 
+	extern void defineSpecialOperatorsAndMacros(Package_sp pkg);
 
 
 
-#if 0
-	extern T_sp _evaluateForm(T_sp head,Cons_sp args, Environment_sp environment,Lisp_sp lisp);
-#endif
+	Function_sp lookupFunction(T_sp functionDesignator, Environment_sp env);
+
+
 	/*! Evaluate a list of expressions (args) into an ActivationFrame that has
 	  enough storage to accept each of the objects that is generated by the list of args */
 	extern void evaluateIntoActivationFrame(const_ActivationFrame_spREF af, Cons_sp args, Environment_sp environment );
 
 
-	extern Cons_sp evaluateList(Cons_sp args, Environment_sp environment);
-	extern T_mv evaluateListReturnLast(Cons_sp args, Environment_sp environment);
+/*! See the CLHS for "apply" - all arguments are in args 
+  (functionDesignator) can be a Symbol or an Function
+*/
 
+	extern T_mv applyToActivationFrame(T_sp functionDesignator, const_ActivationFrame_spREF af);
 
-	extern T_mv sp_progn(Cons_sp code, Environment_sp env);
-	extern T_mv sp_setq(Cons_sp args, Environment_sp environment);
 
+	T_mv apply( T_sp fn, Cons_sp argsPLUS )
+	{
+	    Function_sp func = lookupFunction(fn,_Nil<Environment_O>());
+	    int numArgsPassed = 0
+	    int numArgsPlus = af_length(argsPLUS);
+	    int nargs = numArgsPassed + numArgsPlus;
+	    ValueFrame_sp frame(ValueFrame_O::create_fill(nargs,_Nil<ActivationFrame_O>(),args...));
+	    Cons_sp cur = argsPLUS;
+	    for ( int i=numArgsPassed; i<nargs; ++i ) {
+		frame->operator[](i) = oCar(cur);
+		cur=cCdr(cur);
+	    }
+	    return func->INVOKE(frame->length(),frame->argArray());
+	}
 
+	T_mv apply( T_sp fn, T_sp a0,
+		    Cons_sp argsPLUS )
+	{
+	    Function_sp func = lookupFunction(fn,_Nil<Environment_O>());
+	    int numArgsPassed = 1;
+	    int numArgsPlus = af_length(argsPLUS);
+	    int nargs = numArgsPassed + numArgsPlus;
+	    ValueFrame_sp frame(ValueFrame_O::create_fill(nargs,_Nil<ActivationFrame_O>(),args...));
+	    frame->operator[](0) = a0;
+	    Cons_sp cur = argsPLUS;
+	    for ( int i=numArgsPassed; i<nargs; ++i ) {
+		frame->operator[](i) = oCar(cur);
+		cur=cCdr(cur);
+	    }
+	    return func->INVOKE(frame->length(),frame->argArray());
+	}
 
-	extern void defineSpecialFormsAndMacros(Package_sp pkg);
+	T_mv apply( T_sp fn, T_sp a0, T_sp a1,
+		    Cons_sp argsPLUS )
+	{
+	    Function_sp func = lookupFunction(fn,_Nil<Environment_O>());
+	    int numArgsPassed = 2;
+	    int numArgsPlus = af_length(argsPLUS);
+	    int nargs = numArgsPassed + numArgsPlus;
+	    ValueFrame_sp frame(ValueFrame_O::create_fill(nargs,_Nil<ActivationFrame_O>(),args...));
+	    frame->operator[](0) = a0;
+	    frame->operator[](1) = a1;
+	    Cons_sp cur = argsPLUS;
+	    for ( int i=numArgsPassed; i<nargs; ++i ) {
+		frame->operator[](i) = oCar(cur);
+		cur=cCdr(cur);
+	    }
+	    return func->INVOKE(frame->length(),frame->argArray());
+	}
+
+	T_mv apply( T_sp fn, T_sp a0, T_sp a1, T_sp a2,
+		    Cons_sp argsPLUS )
+	{
+	    Function_sp func = lookupFunction(fn,_Nil<Environment_O>());
+	    int numArgsPassed = 3;
+	    int numArgsPlus = af_length(argsPLUS);
+	    int nargs = numArgsPassed + numArgsPlus;
+	    ValueFrame_sp frame(ValueFrame_O::create_fill(nargs,_Nil<ActivationFrame_O>(),args...));
+	    frame->operator[](0) = a0;
+	    frame->operator[](1) = a1;
+	    frame->operator[](2) = a2;
+	    Cons_sp cur = argsPLUS;
+	    for ( int i=numArgsPassed; i<nargs; ++i ) {
+		frame->operator[](i) = oCar(cur);
+		cur=cCdr(cur);
+	    }
+	    return func->INVOKE(frame->length(),frame->argArray());
+	}
+
+	T_mv apply( T_sp fn, T_sp a0, T_sp a1, T_sp a2, T_sp a3,
+		    Cons_sp argsPLUS )
+	{
+	    Function_sp func = lookupFunction(fn,_Nil<Environment_O>());
+	    int numArgsPassed = 4;
+	    int numArgsPlus = af_length(argsPLUS);
+	    int nargs = numArgsPassed + numArgsPlus;
+	    ValueFrame_sp frame(ValueFrame_O::create_fill(nargs,_Nil<ActivationFrame_O>(),args...));
+	    frame->operator[](0) = a0;
+	    frame->operator[](1) = a1;
+	    frame->operator[](2) = a2;
+	    frame->operator[](3) = a3;
+	    Cons_sp cur = argsPLUS;
+	    for ( int i=numArgsPassed; i<nargs; ++i ) {
+		frame->operator[](i) = oCar(cur);
+		cur=cCdr(cur);
+	    }
+	    return func->INVOKE(frame->length(),frame->argArray());
+	}
+
+
+	T_mv apply( T_sp fn, T_sp a0, T_sp a1, T_sp a2, T_sp a3, T_sp a4,
+		    Cons_sp argsPLUS )
+	{
+	    Function_sp func = lookupFunction(fn,_Nil<Environment_O>());
+	    int numArgsPassed = 5;
+	    int numArgsPlus = af_length(argsPLUS);
+	    int nargs = numArgsPassed + numArgsPlus;
+	    ValueFrame_sp frame(ValueFrame_O::create_fill(nargs,_Nil<ActivationFrame_O>(),args...));
+	    frame->operator[](0) = a0;
+	    frame->operator[](1) = a1;
+	    frame->operator[](2) = a2;
+	    frame->operator[](3) = a3;
+	    frame->operator[](4) = a4;
+	    Cons_sp cur = argsPLUS;
+	    for ( int i=numArgsPassed; i<nargs; ++i ) {
+		frame->operator[](i) = oCar(cur);
+		cur=cCdr(cur);
+	    }
+	    return func->INVOKE(frame->length(),frame->argArray());
+	}
+
+	T_mv apply( T_sp fn, T_sp a0, T_sp a1, T_sp a2, T_sp a3, T_sp a4, T_sp a5,
+		    Cons_sp argsPLUS )
+	{
+	    Function_sp func = lookupFunction(fn,_Nil<Environment_O>());
+	    int numArgsPassed = 6;
+	    int numArgsPlus = af_length(argsPLUS);
+	    int nargs = numArgsPassed + numArgsPlus;
+	    ValueFrame_sp frame(ValueFrame_O::create_fill(nargs,_Nil<ActivationFrame_O>(),args...));
+	    frame->operator[](0) = a0;
+	    frame->operator[](1) = a1;
+	    frame->operator[](2) = a2;
+	    frame->operator[](3) = a3;
+	    frame->operator[](4) = a4;
+	    frame->operator[](5) = a5;
+	    Cons_sp cur = argsPLUS;
+	    for ( int i=numArgsPassed; i<nargs; ++i ) {
+		frame->operator[](i) = oCar(cur);
+		cur=cCdr(cur);
+	    }
+	    return func->INVOKE(frame->length(),frame->argArray());
+	}
+
+	T_mv apply( T_sp fn, T_sp a0, T_sp a1, T_sp a2, T_sp a3, T_sp a4, T_sp a5, T_sp a6, Cons_sp argsPLUS )
+	{
+	    Function_sp func = lookupFunction(fn,_Nil<Environment_O>());
+	    int numArgsPassed = 7;
+	    int numArgsPlus = af_length(argsPLUS);
+	    int nargs = numArgsPassed + numArgsPlus;
+	    ValueFrame_sp frame(ValueFrame_O::create_fill(nargs,_Nil<ActivationFrame_O>(),args...));
+	    frame->operator[](0) = a0;
+	    frame->operator[](1) = a1;
+	    frame->operator[](2) = a2;
+	    frame->operator[](3) = a3;
+	    frame->operator[](4) = a4;
+	    frame->operator[](5) = a5;
+	    frame->operator[](6) = a6;
+	    Cons_sp cur = argsPLUS;
+	    for ( int i=numArgsPassed; i<nargs; ++i ) {
+		frame->operator[](i) = oCar(cur);
+		cur=cCdr(cur);
+	    }
+	    return func->INVOKE(frame->length(),frame->argArray());
+	}
+
+	T_mv apply( T_sp fn, T_sp a0, T_sp a1, T_sp a2, T_sp a3, T_sp a4, T_sp a5, T_sp a6, T_sp a7, Cons_sp argsPLUS )
+	{
+	    Function_sp func = lookupFunction(fn,_Nil<Environment_O>());
+	    int numArgsPassed = 8;
+	    int numArgsPlus = af_length(argsPLUS);
+	    int nargs = numArgsPassed + numArgsPlus;
+	    ValueFrame_sp frame(ValueFrame_O::create_fill(nargs,_Nil<ActivationFrame_O>(),args...));
+	    frame->operator[](0) = a0;
+	    frame->operator[](1) = a1;
+	    frame->operator[](2) = a2;
+	    frame->operator[](3) = a3;
+	    frame->operator[](4) = a4;
+	    frame->operator[](5) = a5;
+	    frame->operator[](6) = a6;
+	    frame->operator[](7) = a7;
+	    Cons_sp cur = argsPLUS;
+	    for ( int i=numArgsPassed; i<nargs; ++i ) {
+		frame->operator[](i) = oCar(cur);
+		cur=cCdr(cur);
+	    }
+	    return func->INVOKE(frame->length(),frame->argArray());
+	}
+
+
+
+	template <class... ARGS>
+	T_mv funcall(T_sp fn, ARGS... args) {
+	    Function_sp func = lookupFunction(fn,_Nil<Environment_O>());
+	    T_sp argArray[sizeof...(ARGS)] = {args...};
+	    if ( !func.pointerp() ) {
+		// While booting, cl::_sym_findClass may be apply'd before it is bound to a symbol
+		if ( fn == cl::_sym_findClass ) {
+		    return(af_findClass(argArray[0].template as<Symbol_O>(),true,_Nil<Environment_O>()));
+		}
+		SIMPLE_ERROR(BF("Could not find function %s") % _rep_(fn) );
+	    }
+	    return func->INVOKE(sizeof...(ARGS),argArray);
+	}
     };
 };
 
+
+
 #endif
Index: exceptions.cc
===================================================================
--- exceptions.cc	(revision 4738)
+++ exceptions.cc	(working copy)
@@ -19,6 +19,7 @@
 #include "evaluator.h"
 #include "exceptions.h"
 #include "symbolTable.h"
+#include "bformat.h"
 #include "str.h"
 #include "lispStream.h"
 #include "sourceFileInfo.h"
@@ -55,17 +56,17 @@
 
     
     
-#define ARGS_af_signalSimpleError "(&rest args)"
+#define ARGS_af_signalSimpleError "(base-condition continue-message format-control format-args &rest args)"
 #define DECL_af_signalSimpleError ""
 #define DOCS_af_signalSimpleError "signalSimpleError"
-    T_sp af_signalSimpleError(T_sp args)
+    T_sp af_signalSimpleError(T_sp baseCondition, T_sp continueMessage, T_sp formatControl, T_sp formatArgs, T_sp args)
     {_G();
-	stringstream ss;
-	ss << "af_signalSimpleError: ";
-	ss << _rep_(args);
-	printf("%s:%d af_signalSimpleError --> %s\n", __FILE__, __LINE__, ss.str().c_str() );
-	dbg_hook(ss.str().c_str());
-	IMPLEMENT_MEF(BF("Implement signalSimpleError"));
+	printf("%s:%d af_signalSimpleError  caught because signal-simple-error is not installed yet\n", __FILE__, __LINE__ );
+	printf("%s\n", _rep_(baseCondition).c_str() );
+	af_format(_lisp->_true(), formatControl, formatArgs.as<Cons_O>() );
+	dbg_hook("af_signalSimpleError");
+	printf("%s:%d  Continuing...\n",__FILE__,__LINE__);
+	return _Nil<T_O>();
     };
 
 
@@ -524,14 +525,13 @@
     message <<  "In ~:[an anonymous function~;~:*function ~A~], "
                 "the value of the argument ~S is~&  ~S~&which is "
                 "not of the expected type ~A";
-    eval::apply(_sym_signalSimpleError,
-		cl::_sym_typeError, 		//arg0
-		_Nil<T_O>(),		// arg1
-		Str_O::create(message.str()),	// arg2
-		Cons_O::createList(function,key,value,type),
-		kw::_sym_expectedType, type,
-		kw::_sym_datum, value,
-		_Nil<Cons_O>());		// argrest
+    eval::funcall(_sym_signalSimpleError,
+		  cl::_sym_typeError, 		//arg0
+		  _Nil<T_O>(),		// arg1
+		  Str_O::create(message.str()),	// arg2
+		  Cons_O::createList(function,key,value,type),
+		  kw::_sym_expectedType, type,
+		  kw::_sym_datum, value );
 };
 
 
@@ -547,14 +547,13 @@
     message <<  "In ~:[an anonymous function~;~:*function ~A~], "
                 "the value of the only argument is~&  ~S~&which is "
                 "not of the expected type ~A";
-    eval::apply(_sym_signalSimpleError,
+    eval::funcall(_sym_signalSimpleError,
 		cl::_sym_typeError, 		//arg0
 		_Nil<T_O>(),		// arg1
 		Str_O::create(message.str()),	// arg2
 		Cons_O::createList(function,value,type),
 		kw::_sym_expectedType, type,
-		kw::_sym_datum, value,
-		_Nil<Cons_O>());		// argrest
+		  kw::_sym_datum, value );
 };
 
 
@@ -569,14 +568,13 @@
     message <<  "In ~:[an anonymous function~;~:*function ~A~], "
                 "the value of an argument is~&  ~S~&which is "
                 "not of the expected type ~A";
-    eval::apply(_sym_signalSimpleError,
+    eval::funcall(_sym_signalSimpleError,
 		cl::_sym_typeError, 		//arg0
 		_Nil<T_O>(),		// arg1
 		Str_O::create(message.str()),	// arg2
 		Cons_O::createList(function,value,type),
 		kw::_sym_expectedType, type,
-		kw::_sym_datum, value,
-		_Nil<Cons_O>());		// argrest
+		  kw::_sym_datum, value );
 };
 
 
@@ -591,14 +589,13 @@
     message <<  "In ~:[an anonymous function~;~:*function ~A~], "
                 "the value of the ~:R argument is~&  ~S~&which is "
                 "not of the expected type ~A";
-    eval::apply(_sym_signalSimpleError,
+    eval::funcall(_sym_signalSimpleError,
 		cl::_sym_typeError, 		//arg0
 		_Nil<T_O>(),		// arg1
 		Str_O::create(message.str()),	// arg2
 		Cons_O::createList(function,Fixnum_O::create(narg),value,type),
 		kw::_sym_expectedType, type,
-		kw::_sym_datum, value,
-		_Nil<Cons_O>());		// argrest
+		  kw::_sym_datum, value );
 };
 
 
@@ -619,14 +616,13 @@
     T_sp type = Cons_O::createList(cl::_sym_Integer_O,Fixnum_O::create(0),limit);
     const char* msg = (which<0) ? message1 : message2;
     Str_sp message = Str_O::create(msg);
-    eval::apply(_sym_signalSimpleError,
+    eval::funcall(_sym_signalSimpleError,
 		cl::_sym_typeError, 		//arg0
 		_Nil<T_O>(),		// arg1
 		message, // arg2 
 		Cons_O::createList(function,Fixnum_O::create(which+1), array, index, type ),
 		kw::_sym_expectedType, type,
-		kw::_sym_datum, index,
-		_Nil<Cons_O>());		// argrest
+		  kw::_sym_datum, index );
 };
 
 
Index: exceptions.h
===================================================================
--- exceptions.h	(revision 4738)
+++ exceptions.h	(working copy)
@@ -24,6 +24,8 @@
 #include "primitives.fwd.h"
 
 
+#define	DBG_HOOK(fmt) dbg_hook((fmt).str().c_str())
+
 #define INTERNAL_ERROR(_msg_) THROW_HARD_ERROR(_msg_)
 
 #define NO_INITIALIZERS_ERROR(_type_) {lisp_error_condition(__FUNCTION__,__FILE__,__LINE__,_type_,_Nil<core::Cons_O>()); THROW_NEVER_REACH(); }
Index: executables.cc
===================================================================
--- executables.cc	(revision 4738)
+++ executables.cc	(working copy)
@@ -40,15 +40,44 @@
 
 
 
+    
+    
+#define ARGS_cl_functionLambdaExpression "(fn)"
+#define DECL_cl_functionLambdaExpression ""
+#define DOCS_cl_functionLambdaExpression "functionLambdaExpression"
+    T_mv cl_functionLambdaExpression(Function_sp fn)
+    {_G();
+	if ( fn.nilp() ) {
+	    WRONG_TYPE_ARG(fn,cl::_sym_Function_O);
+	}
+	Cons_sp code = _Nil<Cons_O>();
+	if ( Interpreted_sp ifn = fn.asOrNull<Interpreted_O>() ) {
+	    code = ifn->getCode();
+	}
+	bool closedp = fn->closedEnvironment().notnilp();
+	T_sp name = fn->functionName();
+	return Values(code,_lisp->_boolean(closedp),name);
+    };
+
+
+
+
+
     Environment_sp Function_O::closedEnvironment() const
     {
 	SUBIMP();
     }
 
 
+
+
+
     T_mv Function_O::functionFile() const
     {
-	string pathName = this->_SourceFileInfo->namestring();
+	string pathName = "-no-file-";
+	if ( this->_SourceFileInfo.notnilp() ) {
+	    pathName =  this->_SourceFileInfo->namestring();
+	}
 	return Values(Str_O::create(pathName),Fixnum_O::create(this->_LineNumber));
     }
 
@@ -88,6 +117,7 @@
 	    .def("functionName",&Function_O::getFunctionName)
 	    .def("functionFile",&Function_O::functionFile)
 	    ;
+	ClDefun(functionLambdaExpression);
     }
 
     void Function_O::exposePython(Lisp_sp lisp)
@@ -242,9 +272,9 @@
     {
 	this->Base::archiveBase(node);
 	node->archiveObject("lambdaListHandler",this->_LambdaListHandler);
-	node->archiveObjectIfDefined("docString",this->_DocString);
-	node->archiveObjectIfDefined("declares",this->_Declares);
-	node->archiveObjectIfDefined("code",this->_Code);
+	node->attributeIfNotNil("docString",this->_DocString);
+	node->attributeIfNotNil("declares",this->_Declares);
+	node->attributeIfNotNil("code",this->_Code);
 	IMPLEMENT_MEF(BF("Handle kind better"));
 	node->attribute("kind",this->_Kind);
     }
@@ -291,14 +321,19 @@
     }
 
 
-
-    T_mv Interpreted_O::INVOKE(const_ActivationFrame_spREF args)
+#if 0
+    T_mv Interpreted_O::FUNCALL(int n_args, ... )
     {_G();
 	T_mv result;
 	LambdaListHandler_sp lambdaListHandler = this->getLambdaListHandler();
 	ValueEnvironment_sp newValueEnvironment = ValueEnvironment_O::createForLambdaListHandler(lambdaListHandler,this->closedEnvironment());
 	ValueEnvironmentDynamicScopeManager scope(newValueEnvironment);
-	lambdaListHandler->createBindingsInEnvironment(args,scope,this->closedEnvironment());
+	{
+	    va_list ap;
+	    va_start(ap,n_args);
+	    lambdaListHandler->createBindingsInScope_var_args(n_args,ap,scope);
+	    va_end(ap);
+	}
 	LOG(BF("About to evaluate the code bound to symbol[%s] in the environment->\n%s")
 	    % _rep_(this->getFunctionName()) % _rep_(newValueEnvironment) );
 	LOG(BF("About to evaluate code: %s")%_rep_(this->_Code) );
@@ -316,10 +351,37 @@
 	LOG(BF("Returning result: %s") % _rep_(result) );
 	return(result);
     }
+#endif
 
 
 
+    // This is the old way of doing things using createBindingsInEnvironment
 
+    T_mv Interpreted_O::INVOKE(int nargs, ArgArray args )
+    {_G();
+	T_mv result;
+	LambdaListHandler_sp lambdaListHandler = this->getLambdaListHandler();
+	ValueEnvironment_sp newValueEnvironment = ValueEnvironment_O::createForLambdaListHandler(lambdaListHandler,this->closedEnvironment());
+	ValueEnvironmentDynamicScopeManager scope(newValueEnvironment);
+	// I used to use createBindingsInEnvironment but I switched to createBindingInActivationFrame
+	lambdaListHandler->createBindingsInScope_argArray(nargs,args,scope);
+	LOG(BF("About to evaluate the code bound to symbol[%s] in the environment->\n%s")
+	    % _rep_(this->getFunctionName()) % _rep_(newValueEnvironment) );
+	LOG(BF("About to evaluate code: %s")%_rep_(this->_Code) );
+	if ( af_consP(this->_Code) )
+	{
+	    ValueFrame_sp newActivationFrame = newValueEnvironment->getActivationFrame().as<ValueFrame_O>();
+	    VectorObjects_sp debuggingInfo = lambdaListHandler->namesOfLexicalVariablesForDebugging();
+	    newActivationFrame->attachDebuggingInfo(debuggingInfo);
+	    LispInterpretedFunctionIHF _frame(_lisp->invocationHistoryStack(),this->sharedThis<Interpreted_O>(),newActivationFrame);
+	    result = eval::sp_progn(this->_Code,newValueEnvironment);
+	} else
+	{
+	    SIMPLE_ERROR(BF("What do we do now, this->_Code = %s") % _rep_(this->_Code) );
+	}
+	LOG(BF("Returning result: %s") % _rep_(result) );
+	return(result);
+    }
 
 
 
@@ -331,6 +393,7 @@
 
 
 
+
 //------------------------------------------------------------
 //
 // BuiltIn
@@ -371,6 +434,9 @@
     {_G();
 	LOG(BF("Creating a function named: %s")% _rep_(functionName) );
 	BuiltIn_sp proc = BuiltIn_O::create();
+	if ( lambdaList.nilp() ) {
+	    IMPLEMENT_MEF(BF("LambdaListHandler should never be nil"));
+	}
 	proc->set_kind(kw::_sym_function);
 	proc->setFunctionName(functionName);
 	proc->setLambdaListHandler(lambdaList);
@@ -406,39 +472,32 @@
     }
 
 
-
-
-    T_mv BuiltIn_O::INVOKE(const_ActivationFrame_spREF args)
+#if 0
+    // What do I do here - if I have a LambdaListHandler or I don't
+    // I still have to do argument conversions - WHAT DO I DO????????
+    T_mv BuiltIn_O::FUNCALL(int n_args, ... )
     {_G();
-	static Symbol_sp llvm_sys__createCompileUnit=_Nil<Symbol_O>();
-	if ( llvm_sys__createCompileUnit.nilp() ) {
-	    llvm_sys__createCompileUnit = _lisp->internWithPackageName("llvm-sys","create-compile-unit");
-	}
-	if ( this->_Name == llvm_sys__createCompileUnit ) {
-	    printf("%s:%d Builtin_O::INVOKE - calling createCompileUnit\n",
-		   __FILE__,__LINE__);
-	}
 	T_mv result;
-	LOG(BF("The body is a CompiledBody"));
 	Functoid* functoid = this->_Body->functoid();
 	// This is where we take the evaluated arguments that we were passed and
 	// give them to the LambdaListHandler to fill in to another ActivationFrame with
 	// optional defaults, key argument defaults and auxs 
+	va_list ap;
+	va_start(ap,n_args);
 	if ( !this->_LambdaListHandler.nilp() )
 	{
 	    ValueFrame_sp activationFrame(ValueFrame_O::createForLambdaListHandler(this->_LambdaListHandler,_Nil<ActivationFrame_O>()));
 	    ActivationFrameDynamicScopeManager scope(activationFrame);
-	    this->_LambdaListHandler->createBindingsInActivationFrame(args,scope,_Nil<Environment_O>());
+	    this->_LambdaListHandler->createBindingsInScope(ap,scope);
 	    activationFrame->attachDebuggingInfo(this->_LambdaListHandler->namesOfLexicalVariablesForDebugging());
 	    LOG(BF("Populated activation_frame: %s") % _rep_(activationFrame) );
-//	    CxxFunctionIHF cxxFunctionFrame(_lisp->invocationHistoryStack(),__FILE__,NULL,InvocationHistoryFrame::NoLine,activationFrame,this->sharedThis<BuiltIn_O>());
 	    result = functoid->activate(activationFrame);
 	} else
 	{
 	    // If there is no LambdaListHandler then pass the given activation frame on to the functoid
-//	    CxxFunctionIHF cxxFunctionFrame(_lisp->invocationHistoryStack(),__FILE__,NULL,InvocationHistoryFrame::NoLine,args,this->sharedThis<BuiltIn_O>());
-	    result = functoid->activate(args);
+	    result = functoid->activate(n_args,ap);
 	}
+	va_end(ap);
 	LOG(BF("Returning result: %s") % _rep_(result) );
 	if ( !result )
 	{
@@ -447,9 +506,52 @@
 	LOG(BF("Returning result: %s") % _rep_(result) );
 	return(result);
     }
+#endif
 
 
 
+
+    T_mv BuiltIn_O::INVOKE(int nargs, ArgArray argArray)
+    {_G();
+	T_mv result;
+	LOG(BF("The body is a CompiledBody"));
+	Functoid* functoid = this->_Body->functoid();
+	// This is where we take the evaluated arguments that we were passed and
+	// give them to the LambdaListHandler to fill in to another ActivationFrame with
+	// optional defaults, key argument defaults and auxs 
+	if ( !this->_LambdaListHandler.nilp() )
+	{
+	    LambdaListHandler_sp llh = this->_LambdaListHandler;
+	    ValueFrame_sp expandedArgs(ValueFrame_O::createForLambdaListHandler(this->_LambdaListHandler,_Nil<ActivationFrame_O>()));
+	    expandedArgs->attachDebuggingInfo(this->_LambdaListHandler->namesOfLexicalVariablesForDebugging());
+	    ActivationFrameDynamicScopeManager scope(expandedArgs);
+	    this->_LambdaListHandler->createBindingsInScope_argArray(nargs,argArray,scope);
+	    LOG(BF("Populated activation_frame: %s") % _rep_(expandedArgs) );
+	    CxxFunctionIHF _frame(_lisp->invocationHistoryStack(),this->sharedThis<BuiltIn_O>(),expandedArgs->length(),expandedArgs->argArray());
+	    // BuiltIn functions run in the nil lexical environment
+	    result = functoid->activate(_Nil<ActivationFrame_O>(),expandedArgs->length(),expandedArgs->argArray());
+	} else
+	{
+	    // If there is no LambdaListHandler then pass the given activation frame on to the functoid
+#if 1 // this is the old code
+	    /* TODO: Create an ActivationFrame that is completely stored on the stack and use it here */
+	    CxxFunctionIHF _frame(_lisp->invocationHistoryStack(),this->sharedThis<BuiltIn_O>(),nargs,argArray);
+	    result = functoid->activate(_Nil<ActivationFrame_O>(),nargs,argArray);
+#else
+	    SIMPLE_ERROR(BF("The BuiltIn function %s must have a LambdaListHandler") % _rep_(this->_Name) );
+#endif
+	}
+	LOG(BF("Returning result: %s") % _rep_(result) );
+	if ( !result )
+	{
+	    SIMPLE_ERROR(BF("Error: UNDEFINED result from INVOKE of function[%s]") % _rep_(this->getFunctionName()) );
+	}
+	LOG(BF("Returning result: %s") % _rep_(result) );
+	return(result);
+    }
+
+
+
     Environment_sp BuiltIn_O::closedEnvironment() const
     {
 	return this->_ClosedEnvironment;
@@ -510,21 +612,43 @@
     }
 
 
-
-    T_mv CompiledFunction_O::INVOKE(const_ActivationFrame_spREF args)
+#if 0
+    T_mv CompiledFunction_O::FUNCALL(int n_args, ... )
     {_G();
 	af_stackMonitor();
 	T_mv result;
 	LispCompiledFunctionIHF _frame(_lisp->invocationHistoryStack(),this->sharedThis<CompiledFunction_O>());
 	LOG(BF("The body is a CompiledBody"));
 	Functoid* functoid = this->_Body->functoid();
+	IMPLEMENT_MEF(BF("What do I do here???"));
+#if FUNCALL
 	args->setParentFrame(this->_ClosedEnvironment);
+#endif
+	IMPLEMENT_MEF(BF("WHAT DO I DO HERE???"));
+#if FUNCALL
 	result = functoid->activate(args);
-	ASSERTF(result!=NULL,BF("Error: UNDEFINED result from INVOKE of function[%s] on arguments[%s]") % _rep_(this->getFunctionName()) %  _rep_(args) );
+#endif
+	ASSERTF(result,BF("Error: UNDEFINED result from INVOKE of function[%s]") % _rep_(this->getFunctionName()) );
 	return(result);
     }
+#endif
 
 
+
+    T_mv CompiledFunction_O::INVOKE(int nargs, ArgArray args)
+    {_G();
+	af_stackMonitor();
+	T_mv result;
+	LispCompiledFunctionIHF _frame(_lisp->invocationHistoryStack(),this->sharedThis<CompiledFunction_O>());
+	LOG(BF("The body is a CompiledBody"));
+	Functoid* functoid = this->_Body->functoid();
+//	args->setParentFrame(this->_ClosedEnvironment);
+	result = functoid->activate(this->_ClosedEnvironment,nargs,args);
+	ASSERTF(result,BF("Error: UNDEFINED result from INVOKE of function[%s]") % _rep_(this->getFunctionName()));
+	return(result);
+    }
+
+
     string CompiledFunction_O::__repr__() const
     {_G();
 	stringstream ss;
Index: executables.h
===================================================================
--- executables.h	(revision 4737)
+++ executables.h	(working copy)
@@ -48,13 +48,16 @@
     Function_O() : Base(), _SourceFileInfo(_Nil<SourceFileInfo_O>()), _LineNumber(0), _Column(0) {};   
     virtual ~Function_O() {};
 public:
-    virtual T_mv INVOKE(const_ActivationFrame_spREF exp) {_OF(); SUBCLASS_MUST_IMPLEMENT();};
+    /*! Variadic funcall invoker */
+    virtual T_mv INVOKE(int nargs, ArgArray args) {_OF(); SUBCLASS_MUST_IMPLEMENT();};
 public:
-public:
 
+
+
     virtual Environment_sp closedEnvironment() const;
 
     Symbol_sp functionKind() const { return this->_Kind;};
+    T_sp functionName() const { return this->_Name;};
     void setFunctionName(T_sp symbol);
     T_sp getFunctionName() const;
 
@@ -92,7 +95,7 @@
     friend class SingleDispatchGenericFunction_O;
     friend class Lambda_emf;
     friend class Lambda_call_next_method;
-    friend T_mv core::eval::applyFunctionToActivationFrame(Function_sp head, const_ActivationFrame_spREF args);
+//    friend T_mv core::eval::applyFunctionToActivationFrame(Function_sp head, const_ActivationFrame_spREF args);
 public:
     void initialize();
 #if defined(XML_ARCHIVE)
@@ -108,7 +111,8 @@
     // Code
     Cons_sp			_Code;
 private:
-    virtual T_mv INVOKE(const_ActivationFrame_spREF args);
+    /*! Variadic funcall invoker */
+    virtual T_mv INVOKE(int nargs, ArgArray args );
 public:
 
     static Interpreted_sp make( T_sp functionName,
@@ -165,47 +169,47 @@
 
 
     
-    namespace core
+namespace core
+{
+    class BuiltIn_O : public Function_O
     {
-	class BuiltIn_O : public Function_O
-	{
-	    LISP_BASE1(Function_O);
-	    LISP_CLASS(core,CorePkg,BuiltIn_O,"BuiltIn");
-	    DECLARE_INIT();
-	public: // Simple default ctor/dtor
-	    DEFAULT_CTOR_DTOR(BuiltIn_O);
-	public: // ctor/dtor for classes with shared virtual base
+	LISP_BASE1(Function_O);
+	LISP_CLASS(core,CorePkg,BuiltIn_O,"BuiltIn");
+	DECLARE_INIT();
+    public: // Simple default ctor/dtor
+	DEFAULT_CTOR_DTOR(BuiltIn_O);
+    public: // ctor/dtor for classes with shared virtual base
 //    explicit BuiltIn_O(core::Class_sp const& mc) : T_O(mc), Function(mc) {};
 //    virtual ~BuiltIn_O() {};
-	private: // instance variables here
-	    ActivationFrame_sp 		_ClosedEnvironment;
-	    CompiledBody_sp		_Body;
-	private:
-	    virtual T_mv INVOKE(const_ActivationFrame_spREF args);
+    private: // instance variables here
+	ActivationFrame_sp 		_ClosedEnvironment;
+	CompiledBody_sp		_Body;
+    private:
+	virtual T_mv INVOKE(int nargs, ArgArray args);
 	    
-	public:
-	    /*! Used to create temporary functions in singleDispatchMethod */
-	    static BuiltIn_sp create_single_dispatch_function( T_sp functionName,
-									LambdaListHandler_sp args,
-									CompiledBody_sp code );
-	    static BuiltIn_sp make( T_sp functionName,
-					     LambdaListHandler_sp llh,
-					     CompiledBody_sp code );
+    public:
+	/*! Used to create temporary functions in singleDispatchMethod */
+	static BuiltIn_sp create_single_dispatch_function( T_sp functionName,
+							   LambdaListHandler_sp args,
+							   CompiledBody_sp code );
+	static BuiltIn_sp make( T_sp functionName,
+				LambdaListHandler_sp llh,
+				CompiledBody_sp code );
 
-	    static BuiltIn_sp create( T_sp functionName,
-					       LambdaListHandler_sp lambda_list_handler,
-					       CompiledBody_sp code,
-					       ActivationFrame_sp environment,
-					       Symbol_sp kind );
+	static BuiltIn_sp create( T_sp functionName,
+				  LambdaListHandler_sp lambda_list_handler,
+				  CompiledBody_sp code,
+				  ActivationFrame_sp environment,
+				  Symbol_sp kind );
 
-	    string __repr__() const;
+	string __repr__() const;
 
-	    virtual Environment_sp closedEnvironment() const;
+	virtual Environment_sp closedEnvironment() const;
 	    
-	public: // Functions here
-	}; // BuiltIn class
+    public: // Functions here
+    }; // BuiltIn class
 	
-    }; // core namespace
+}; // core namespace
     TRANSLATE(core::BuiltIn_O);
     
 
@@ -237,11 +241,12 @@
 							uint column,
 							Symbol_sp functionKind );
     public:
+    /*! Variadic funcall invoker */
+	virtual T_mv INVOKE(int nargs, ArgArray args);
+    public:
 
     virtual Environment_sp closedEnvironment() const;
 
-	    virtual T_mv INVOKE(const_ActivationFrame_spREF args);
-
 	CompiledBody_sp getBody() const { return this->_Body;};
 
 	string __repr__() const;
Index: extensionPackage.cc
===================================================================
--- extensionPackage.cc	(revision 4737)
+++ extensionPackage.cc	(working copy)
@@ -65,8 +65,7 @@
     void initialize_extensionPackage()
     {
 	list<string> lnicknames;
-	list<core::Package_sp> luse;
-	luse.push_front(_lisp->findPackage("COMMON-LISP"));
+	list<string> luse = { "COMMON-LISP" };
 	_lisp->makePackage("EXT",lnicknames,luse);
 	// We don't have to create the EXTENSION symbols here - it's done in bootStrapCoreSymbolMap
 
Index: externalObject.h
===================================================================
--- externalObject.h	(revision 4737)
+++ externalObject.h	(working copy)
@@ -50,9 +50,6 @@
     virtual void* externalObject() const {_OF(); SUBCLASS_MUST_IMPLEMENT();};
     virtual void set_externalObject(void* ptr) {_OF(); SUBCLASS_MUST_IMPLEMENT();};
 public:
-    ExternalObject_O( const ExternalObject_O& ss ); //!< Copy constructor
-
-public:
     explicit ExternalObject_O() : Base() {};
     virtual ~ExternalObject_O() {};
 };
@@ -123,8 +120,6 @@
 	static ForeignData_sp allocateForeignObject(T_sp kind);
 
     public:
-	ForeignData_O( const ForeignData_O& ss ); //!< Copy constructor
-
 	template <class T>
 	T data() { return reinterpret_cast<T>(this->_Data);};
     private:
Index: external_wrappers.h
===================================================================
--- external_wrappers.h	(revision 4737)
+++ external_wrappers.h	(working copy)
@@ -8,11 +8,68 @@
 
 namespace core
 {
+    template<class RT, class OT, typename... ARGS>
+    class IndirectMemberFunction {
+    public:
+	typedef std::function<RT(typename OT::WrappedType&,ARGS... args)> 	MethodPtrType;
+	MethodPtrType							mfn;
+    public:
+	IndirectMemberFunction(MethodPtrType fn) : mfn(fn) {};
+	T_mv operator()(OT& receiver, ARGS...args) {
+	    RT retval = mfn(*receiver.wrappedPtr(),args...);
+	    return translate::to_object<RT>::convert(retval);
+	}
+    };
 
+    template<class OT, typename... ARGS>
+    class IndirectMemberFunction<void,OT,ARGS...> {
+    public:
+	typedef std::function<void(typename OT::WrappedType&,ARGS...)> 	MethodPtrType;
+	MethodPtrType 					mfn;
+    public:
+	IndirectMemberFunction(MethodPtrType fn) : mfn(fn) {};
+	T_mv operator()(OT& receiver, ARGS...args) {
+	    mfn(*receiver.wrappedPtr(),args...);
+	    return Values0<T_O>();
+	}
+    };
+	    
 
 
+
+
+
+    template<typename RT, typename OT, typename ... ARGS>
+    class IndirectVariadicMethoid : public SingleDispatchMethoid {
+    private:
+	typedef typename OT::WrappedType	WrappedType;
+	typedef IndirectMemberFunction<RT,OT,ARGS...> 		HolderType;
+	typedef typename HolderType::MethodPtrType 	Type;
+	HolderType		 			mptr;
+    public:
+	string describe() const { return "IndirectVariadicMethoid";}
+	enum { NumParams = sizeof...(ARGS) };
+	IndirectVariadicMethoid(const string& name, Type ptr) : SingleDispatchMethoid(name), mptr(ptr) {};
+	T_mv activate( const_ActivationFrame_spREF closedEnv,int nargs, ArgArray args )
+	{_G();
+	    if ( nargs-1 != sizeof...(ARGS) ) // Was nargs-1
+	    {
+		stringstream ss;
+		ss << "Method expected "<< (sizeof...(ARGS)) << " argument(s) but was passed " << nargs << " argument(s) including the receiver.";
+		SIMPLE_ERROR_BF(ss.str());
+	    }
+	    mem::smart_ptr<OT> ot = args[this->_SingleDispatchArgumentIndex].template as<OT>();
+	    int arg_idx(-1);
+	    this->incIdx(arg_idx);
+	    return mptr(*ot.get(), (translate::from_object<ARGS>(args[this->incIdx(arg_idx)])._v)...);
+	};
+    };
+
+
+
+
 #define af_external_methodptrt_H
-#include "af_external_method_templates.h"
+//#include "af_external_method_templates.h"
 #undef af_external_methodptrt_H
    
 
@@ -88,21 +145,62 @@
 
 
 #define af_external_method_def_H
-#include "af_external_method_templates.h"
+//#include "af_external_method_templates.h"
 #undef af_external_method_def_H
 
 
-    externalClass_& old_style_def_raw(const string& name, T_sp (OT::*mp)(Function_sp,Cons_sp, Environment_sp, Lisp_sp ), const string& arguments="", string const& declarestring="", string const& docstring="", bool autoExport=true )
+    template <typename RT,class... ARGS>
+    externalClass_& def( string const& name, RT (OT::*mp)(ARGS...), string const& lambda_list="", const string& declares="", const string& docstring="",bool autoExport=true)
     {_G();
-	ASSERTNOTNULLP(this->_Lisp,"The Lisp environment must be defined before wrappers");
-	Functoid* m = new OldStyleMethoid<OT>(mp);
-	lisp_defineSingleDispatchMethod(name,this->_ClassSymbol,m,arguments,declarestring,docstring,autoExport);
-	return *this;
+        SingleDispatchMethoid* m = new VariadicMethoid<RT,OT,ARGS...>(name,mp);
+        lisp_defineSingleDispatchMethod(name,this->_ClassSymbol,m,lambda_list,declares,docstring,autoExport,sizeof...(ARGS)+1);
+        return *this;
     }
 
+    template <typename RT,class... ARGS>
+    externalClass_& def( string const& name, RT (OT::*mp)(ARGS...) const,
+		 string const& lambda_list="", const string& declares="", const string& docstring="",bool autoExport=true)
+    {_G();
+        SingleDispatchMethoid* m = new VariadicMethoid<RT,OT,ARGS...>(name,mp);
+        lisp_defineSingleDispatchMethod(name,this->_ClassSymbol,m,lambda_list,declares,docstring,autoExport,sizeof...(ARGS)+1);
+        return *this;
+    }
 
 
+#if 1
 
+    template <typename RT,class... ARGS>
+    externalClass_& def( const string& name, RT (OT::WrappedType::*mp)(ARGS...),
+			 const string& lambda_list="", const string& declares="", const string& docstring="", bool autoExport=true )
+    {_G();
+        SingleDispatchMethoid* m = new IndirectVariadicMethoid<RT,OT,ARGS...>(name,mp);
+        lisp_defineSingleDispatchMethod(name,this->_ClassSymbol,m,lambda_list,declares,docstring,autoExport,sizeof...(ARGS)+1);
+        return *this;
+    }
+
+
+    template <typename RT,class... ARGS>
+    externalClass_& def( const string& name, RT (OT::WrappedType::*mp)(ARGS...) const,
+			 const string& lambda_list="", const string& declares="", const string& docstring="", bool autoExport=true )
+    {_G();
+        SingleDispatchMethoid* m = new IndirectVariadicMethoid<RT,OT,ARGS...>(name,mp);
+        lisp_defineSingleDispatchMethod(name,this->_ClassSymbol,m,lambda_list,declares,docstring,autoExport,sizeof...(ARGS)+1);
+        return *this;
+    }
+#else
+    template <typename RT,class... ARGS>
+    externalClass_& def( const string& name, RT (OT::WrappedClass::*mp)(ARGS...) const,
+			 const string& lambda_list="", const string& declares="", const string& docstring="", bool autoExport=true )
+    {_G();
+        SingleDispatchMethoid* m = new ConstIndirectVariadicMethoid<RT,OT,ARGS...>(name,mp);
+        lisp_defineSingleDispatchMethod(name,this->_ClassSymbol,m,lambda_list,declares,docstring,autoExport,sizeof...(ARGS)+1);
+        return *this;
+    }
+#endif
+
+
+
+
 };
 
 
Index: float_to_digits.cc
===================================================================
--- float_to_digits.cc	(revision 4737)
+++ float_to_digits.cc	(working copy)
@@ -229,8 +229,8 @@
         k = scale(approx);
         if (Null(digits))
 	    digits = af_make_vector(cl::_sym_BaseChar_O,
-				    brcl_make_fixnum(10),
-				    BRCL_T /* adjustable */,
+				    10,
+				    true /* adjustable */,
 				    brcl_make_fixnum(0) /* fill pointer */,
 				    BRCL_NIL /* displacement */,
 				    BRCL_NIL /* displ. offset */,
Index: foundation.cc
===================================================================
--- foundation.cc	(revision 4738)
+++ foundation.cc	(working copy)
@@ -26,10 +26,8 @@
 #include "write_object.h"
 #include "designators.h"
 #include "instance.h"
-#ifndef CLOS
 #include "structureClass.h"
 #include "structureObject.h"
-#endif
 #include "str.h"
 #include "binder.h"
 #include "debugger.h"
@@ -80,7 +78,7 @@
 	    ilow = ihigh;
 	    ihigh = t;
 	}
-	core::Function_sp fn = core::coerce::functionDesignator(tfn,_lisp);
+	core::Function_sp fn = core::coerce::functionDesignator(tfn);
 	for ( GCObject* cur = _GlobalAllocatedObjects; cur!=NULL; cur=cur->_Next)
 	{
 	    if ( ilow <= cur->_AllocationCounter && cur->_AllocationCounter <= ihigh ) {
@@ -219,6 +217,7 @@
 {
 
 
+
 #if 0
     extern "C"
     {
@@ -367,11 +366,12 @@
 	} else if (Instance_sp iobj = o.asOrNull<Instance_O>() )
 	{
 	    return iobj->_instanceClass();
-#ifndef CLOS
+//#ifndef CLOS
 	} else if ( StructureObject_sp sobj = o.asOrNull<StructureObject_O>() )
 	{
-	    return sobj->structureClass();
-#endif
+	    IMPLEMENT_MEF(BF("structureType returns a T_sp but I need a Class_sp - What do I return here????"));
+//	    return sobj->structureType();
+//#endif
 	} else if ( Class_sp cobj = o.asOrNull<Class_O>() )
 	{
 	    return cobj->_instanceClass();
@@ -410,7 +410,7 @@
 
     T_sp lisp_apply(T_sp funcDesig, const_ActivationFrame_spREF frame )
     {_G();
-	return eval::apply(funcDesig,frame);
+	return eval::applyToActivationFrame(funcDesig,frame);
     }
     Symbol_sp lisp_allocate_packageless_sid(string const& name)
     {
@@ -419,7 +419,7 @@
     }
 
 
-    string lisp_convertCNameToLispName(Lisp_sp lisp, string const& cname, bool convertUnderscoreToDash)
+    string lisp_convertCNameToLispName(string const& cname, bool convertUnderscoreToDash)
     {_G();
 	if ( convertUnderscoreToDash )
 	{
@@ -589,7 +589,12 @@
 	_lisp->addClass(classSymbol,cb,base1ClassSymbol,base2ClassSymbol);
     }
 
+    void lisp_addClass(Symbol_sp classSymbol )
+    {_G();
+	_lisp->addClass(classSymbol);
+    }
 
+
     void lisp_addClassAndInitialize(Symbol_sp classSymbol,
 		       AllocatorFunctor* cb,
 		       Symbol_sp base1ClassSymbol,
@@ -708,7 +713,7 @@
 	{
 	    SIMPLE_ERROR(BF("%s dispatch-on-index[%d] does not match that of the arguments[%d] - arguments: %s") % gfn->dispatch_on_index() % single_dispatch_argument_index % arguments );
 	}
-	CompiledBody_sp compiledBody = CompiledBody_O::create(methoid,_Nil<T_O>(),_lisp);
+	CompiledBody_sp compiledBody = CompiledBody_O::create(methoid,_Nil<T_O>());
 	ASSERTF(compiledBody.notnilp(),BF("CompiledBody of method must never be nil - it is!"));
 	Str_sp docStr = Str_O::create(docstring);
 	SYMBOL_SC_(KeywordPkg,body);
@@ -740,7 +745,7 @@
 #if 0
 	FunctionPrimitive_sp setfFunc = FunctionPrimitive_O::create(setfName,meth,llh,docstring,kw::_sym_function,_lisp);
 #else
-	CompiledBody_sp cbmeth = CompiledBody_O::create(meth,_lisp);
+	CompiledBody_sp cbmeth = CompiledBody_O::create(meth);
 	Function_sp setfFunc = BuiltIn_O::create(setfName,
 							  llh,
 							  cbmeth,
@@ -803,6 +808,7 @@
 	return lisp->getClassSymbolForClassName(n);
     }
 
+#if 0
     /*! Return true if the class associated with (baseClassSymbol) is a base class of (classSymbol) */
     bool lisp_subClassOrder(Lisp_sp lisp, Symbol_sp baseClassSymbol, Symbol_sp classSymbol )
     {
@@ -810,9 +816,11 @@
 	Class_sp testClass = lisp->classFromClassSymbol(classSymbol);
 	return testClass->isSubClassOf(baseClass);
     }
+#endif
 
-    void lisp_defun_lispify_name(Lisp_sp lisp,
-				 const string& packageName,
+
+
+    void lisp_defun_lispify_name(const string& packageName,
 				 const string& cname,
 				 Functoid* f,
 				 const string& arguments,
@@ -823,12 +831,11 @@
 				 int number_of_required_arguments )
     {_G();
 	string name = lispify_symbol_name(cname);
-	lisp_defun(lisp,packageName,name,f,arguments,declstring,docstring,locked,autoExport,number_of_required_arguments);
+	lisp_defun(packageName,name,f,arguments,declstring,docstring,locked,autoExport,number_of_required_arguments);
     }
 
 
-    void lisp_defun(Lisp_sp lisp,
-		    const string& packageName,
+    void lisp_defun(const string& packageName,
 		    const string& cname,
 		    Functoid* f,
 		    const string& arguments,
@@ -840,7 +847,7 @@
     {_G();
 	string name = cname; // lispify above
 	LOG(BF("Adding form[%s] with arguments[%s]") % name % arguments );
-	string lispName = lisp_convertCNameToLispName(_lisp,name,true);
+	string lispName = lisp_convertCNameToLispName(name,true);
 #if 0
 	// Trap the definition of specific functions here
 	// sometimes I accidentally define things more than once and
@@ -851,7 +858,7 @@
 	    printf("%s:%d defining %s - break here to trap\n", __FILE__,__LINE__, lispName.c_str() );
 	}
 #endif
-	Symbol_sp sym = lisp->internWithPackageName(packageName,lispName);
+	Symbol_sp sym = _lisp->internWithPackageName(packageName,lispName);
 	if ( sym->getReadOnlyFunction() )
 	{
 	    printf( "%s:%d - The symbol[%s] has already been assigned a function and will not be redefined\n", __FILE__, __LINE__, _rep_(sym).c_str() );
@@ -869,7 +876,7 @@
 	}
 
 	ASSERTNOTNULL(llh);
-	CompiledBody_sp cbf = CompiledBody_O::create(f,_Nil<T_O>(),_lisp);
+	CompiledBody_sp cbf = CompiledBody_O::create(f,_Nil<T_O>());
 	Function_sp func = BuiltIn_O::create(sym,
 						      llh,
 						      cbf,
@@ -893,7 +900,7 @@
     {_G();
 	string name = lispify_symbol_name(cname);
 	LOG(BF("Adding form[%s] with arguments[%s]") % name % arguments );
-	string lispName = lisp_convertCNameToLispName(_lisp,name,true);
+	string lispName = lisp_convertCNameToLispName(name,true);
 	Symbol_sp sym = _lisp->internWithPackageName(packageName,lispName);
 	if ( sym->getReadOnlyFunction() )
 	{
@@ -906,7 +913,7 @@
 #if 0
 	FunctionPrimitive_sp func = FunctionPrimitive_O::create(sym,f,llh,""/*Docstring*/,kw::_sym_macro,_lisp);
 #else
-	CompiledBody_sp cbf = CompiledBody_O::create(f,_Nil<T_O>(),_lisp);
+	CompiledBody_sp cbf = CompiledBody_O::create(f,_Nil<T_O>());
 	Function_sp func = BuiltIn_O::create(sym,
 						      llh,
 						      cbf,
@@ -921,8 +928,7 @@
     }
 
 
-    void lisp_defgeneric(Lisp_sp lisp,
-			 const string& packageName,
+    void lisp_defgeneric(const string& packageName,
 			 const string& cname,
 			 Functoid* f,
 			 const string& arguments,
@@ -934,7 +940,7 @@
 	string name = lispify_symbol_name(cname);
 #if 0
 	LOG(BF("Adding generic-function[%s:%s] with arguments[%s]") %packageName % name % arguments );
-	string lispName = lisp_convertCNameToLispName(_lisp,name,true);
+	string lispName = lisp_convertCNameToLispName(name,true);
 	Symbol_sp sym = lisp->internWithPackageName(packageName,lispName);
 	lisp->createPredefinedSymbol(symSymbol,sym);
 	IMPLEMENT_MEF(BF("Switch to CompiledBody"));
@@ -945,68 +951,6 @@
     }
 
 
-#if 0
-    /*! This function is based on the AMOP-298:parse-defmethod function */
-    void lisp_defmethod(Lisp_sp lisp,Symbol_sp gfSymbol, Functoid* f, const string& arguments, const string& docstring )
-    {_G();
-	// Handle locking the function symbol
-	Symbol_sp func_spec = gfSymbol;
-	LOG(BF("Entered lisp_defmethod for generic-function[%s] with arguments[%s]") % func_spec->__repr__() % arguments );
-	//
-	// Parse the qualifiers and the specialized lambda list in the string arguments
-	//
-	StringInputStream_sp argumentStream = StringInputStream_O::create(arguments);
-	Cons_sp qualifierAndSpecializedLambdaListArguments = eval::apply(cl::_sym_read,(ql::list(_lisp)<<argumentStream),_lisp).as_or_nil<Cons_O>();
-	// Extract the qualifiers and specializedLambdaList - see AMOP-298:parse-defmethod
-	ql::list qualifierList(_lisp);
-	Cons_sp carg = qualifierAndSpecializedLambdaListArguments;
-	{_BLOCK_TRACEF(BF("Parsing qualifiers from args: %s") % carg->__repr__() );
-	    for ( ; carg.notnilp(); carg = carg->cdr() )
-	    {
-		T_sp arg = carg->ocar();
-		if ( af_atom(arg) && arg.notnilp() )
-		{
-		    LOG(BF("Found a qualifier[%s]") % arg->__repr__() );
-		    (qualifierList << arg);  // << operator appends arg to qualifierList
-		} else break;
-	    }
-	}
-	Cons_sp qualifiers = qualifierList.cons();  // We now have the qualifiers
-	LOG(BF("Qualifiers[%s]") % qualifiers->__repr__() );
-	LOG(BF("After qualifiers extracted args=%s") % carg->__repr__() );
-	if ( carg.nilp() )
-	{
-	    SIMPLE_ERROR(BF("lisp_defmethod[generic-function=%s] - specializedLambdaList is missing")%func_spec->__repr__() );
-	}
-	Cons_sp specializedLambdaList = carg->ocar().as_or_nil<Cons_O>(); // we should now have the specialized lambda list
-	Cons_sp lambdaList = eval::apply(_sym_extract_lambda_list,(ql::list(_lisp)<<specializedLambdaList),_lisp).as_or_nil<Cons_O>();
-	Cons_sp specializers = eval::apply(_sym_extract_specializers,(ql::list(_lisp)<<specializedLambdaList),_lisp).as_or_nil<Cons_O>();
-	IMPLEMENT_MEF(BF("Switch to CompiledBody"));
-	FunctionPrimitive_sp funcPrimitive = FunctionPrimitive_O::create(func_spec,f,arguments,docstring,kw::_sym_function,_lisp);
-	GenericFunction_sp genericFunction = eval::apply(_sym_find_generic_function,(ql::list(_lisp)<<func_spec),_lisp).as<GenericFunction_O>();
-	Function_sp canonicalize_specializers_fn = _Nil<Environment_O>()->lookup_function(_sym_canonicalize_specializer);
-	Cons_sp canonicalizedSpecializers =
-	    eval::apply(cl::_sym_mapcar,(ql::list(_lisp)
-				     << canonicalize_specializers_fn
-				     << specializers),_lisp).as_or_nil<Cons_O>();
-	SYMBOL_SC_(KeywordPkg,lambda_list);
-	SYMBOL_SC_(KeywordPkg,qualifiers);
-	SYMBOL_SC_(KeywordPkg,specializers);
-	SYMBOL_SC_(KeywordPkg,body);
-	SYMBOL_SC_(KeywordPkg,environment);
-	SYMBOL_SC_(KeywordPkg,function_primitive);
-	T_sp result =
-	    eval::apply(_sym_ensure_method,(ql::list(_lisp) << genericFunction
-					    << kw::_sym_lambda_list << lambdaList
-					    << kw::_sym_qualifiers << qualifiers
-					    << kw::_sym_specializers << canonicalizedSpecializers
-// in AMOP-300 ensure-method was passed :body for which ensure-methods wants a form
-// these are hard-coded functions so I'll pass the function primitive with :function_primitive key
-// instead of :body
-					    << kw::_sym_function_primitive << funcPrimitive
-					    << kw::_sym_environment << _Nil<Environment_O>()), _lisp);
-    }
-#endif
 
 
     Symbol_sp lisp_internKeyword(const string& name)
@@ -1434,12 +1378,11 @@
 //	    af_error(CandoException_O::create(ss.str()),_Nil<Cons_O>());
 	}
 	SYMBOL_EXPORT_SC_(ClPkg,programError);
-	eval::apply(_sym_signalSimpleError,
+	eval::funcall(_sym_signalSimpleError,
 		    cl::_sym_programError, 		//arg0
 		    _Nil<T_O>(),		// arg1
 		    Str_O::create(fmt.str()),	// arg2
-		    _Nil<Cons_O>(),		// arg3
-		    _Nil<Cons_O>());		// argrest
+		    _Nil<Cons_O>());
     }
 
     void lisp_error_condition(const char* functionName, const char* fileName, int lineNumber, T_sp baseCondition, T_sp initializers )
@@ -1454,12 +1397,11 @@
 	    dbg.invoke();
 //	    af_error(CandoException_O::create(ss.str()),_Nil<Cons_O>());
 	}
-	eval::apply(_sym_signalSimpleError,
-		    baseCondition,
-		    _Nil<T_O>(),
-		    Str_O::create(ss.str()),
-		    _Nil<Cons_O>(),
-		    initializers.as_or_nil<Cons_O>());
+	eval::funcall(_sym_signalSimpleError,
+		      initializers.as_or_nil<Cons_O>(),
+		      baseCondition,
+		      _Nil<T_O>(),
+		      Str_O::create(ss.str()) );
     }
 
 
@@ -1489,6 +1431,19 @@
 
 
 
+    T_sp lisp_ArgArrayToCons(int nargs, ArgArray args)
+    {
+	Cons_O::CdrType_sp first = _Nil<Cons_O::CdrType_O>();
+	Cons_O::CdrType_sp* cur = &first;
+	for ( int i(0); i<nargs; ++i ) {
+	    Cons_sp one = Cons_O::create(args[i]);
+	    *cur = one;
+	    cur = one->cdrPtr();
+	}
+	return first;
+    }
+
+
     vector<string> split(const string& str, const string& delimiters)
     {
 	vector<string>	parts;
Index: foundation.h
===================================================================
--- foundation.h	(revision 4737)
+++ foundation.h	(working copy)
@@ -3,6 +3,7 @@
 
 namespace std { class type_info; };
 
+#define VARARGS
 
 #ifdef	USEBOOSTPYTHON
 #include "mainBoostPython.h"
@@ -151,6 +152,7 @@
 #define Defun_maker(pkg,x) core::af_def(pkg,"make-" #x,&(x ## _O::make), ARGS_##x##_O_make, DECL_##x##_O_make, DOCS_##x##_O_make);
 
 #define ClDefun(x) core::af_def(ClPkg,#x,&cl_##x, ARGS_cl_##x, DECL_cl_##x, DOCS_cl_##x); 
+#define ClosDefun(x) core::af_def(ClosPkg,#x,&clos_##x, ARGS_clos_##x, DECL_clos_##x, DOCS_clos_##x); 
 #define CoreDefun(x) core::af_def(CorePkg,#x,&core_##x, ARGS_core_##x, DECL_core_##x, DOCS_core_##x); 
 
 
@@ -608,10 +610,18 @@
     typedef const ActivationFrame_sp& const_ActivationFrame_spREF;
     typedef ActivationFrame_sp& ActivationFrame_spREF;
 
+
+};
+
+/*! A type for an array of arguments */
+    typedef	core::T_sp* 	ArgArray;
+
+
+namespace core {
     class Instance_O;
 
-    typedef T_mv (*ActivationFrameFunctionPtr)(const_ActivationFrame_spREF);
-    typedef T_mv (*ActivationFrameGenericFunctionPtr)(const_ActivationFrame_spREF, const Instance_O& gf);
+//    typedef T_mv (*ActivationFrameFunctionPtr)(const_ActivationFrame_spREF);
+    typedef T_mv (*ArgArrayGenericFunctionPtr)(const Instance_O& gf, int nargs, ArgArray argArray);
 
     class Lisp_O;
     typedef Lisp_O* Lisp_sp;
@@ -745,7 +755,6 @@
 
 
 
-
 namespace core 
 {
 
@@ -789,6 +798,7 @@
     void lisp_throwUnexpectedType(T_sp offendingObject, Symbol_sp expectedTypeId );
     core::T_sp lisp_true();
     core::T_sp lisp_false();
+    T_sp lisp_ArgArrayToCons(int nargs, ArgArray args);
     bool lisp_fixnumP(core::T_sp obj);
     bool lisp_characterP(core::T_sp obj);
     bool	lisp_BuiltInClassesInitialized(Lisp_sp lisp);
@@ -800,6 +810,7 @@
     Class_sp lisp_boot_findClassBySymbolOrNil(Symbol_sp sym);
     void	lisp_exposeClass(Lisp_sp lisp, const string& className, ExposeCandoFunction exposeCandoFunction, ExposePythonFunction exposePythonFunction);
     void	lisp_addClass( Symbol_sp classSymbol, AllocatorFunctor* cb, Symbol_sp baseClassSymbol1, Symbol_sp baseClassSymbol2=UNDEFINED_SYMBOL,Symbol_sp baseClassSymbol3=UNDEFINED_SYMBOL );
+    void	lisp_addClass( Symbol_sp classSymbol );
     void	lisp_addClassAndInitialize( Symbol_sp classSymbol, AllocatorFunctor* cb, Symbol_sp baseClassSymbol1, Symbol_sp baseClassSymbol2=UNDEFINED_SYMBOL,Symbol_sp baseClassSymbol3=UNDEFINED_SYMBOL );
     void	lisp_throwIfBuiltInClassesNotInitialized(Lisp_sp lisp);
     string	lisp_classNameFromClassSymbol(Lisp_sp lisp, Symbol_sp classSymbol );
@@ -824,23 +835,23 @@
     bool lisp_isClassName(Lisp_sp lisp, const string& n);
     Symbol_sp lisp_allocate_packageless_sid(string const& n);
     Symbol_sp lisp_getClassSymbolForClassName(Lisp_sp lisp, const string& n);
-    bool lisp_subClassOrder(Lisp_sp lisp, Symbol_sp baseClassSymbol, Symbol_sp classSymbol );
-    string lisp_convertCNameToLispName(Lisp_sp lisp, string const& cname, bool convertUnderscoreToDash=true);
+//    bool lisp_subClassOrder(Lisp_sp lisp, Symbol_sp baseClassSymbol, Symbol_sp classSymbol );
+    string lisp_convertCNameToLispName(string const& cname, bool convertUnderscoreToDash=true);
     T_sp lisp_apply(T_sp funcDesig, const_ActivationFrame_spREF args );
     Cons_sp lisp_parse_arguments(Lisp_sp lisp, const string& packageName, const string& args);
     Cons_sp lisp_parse_declares(Lisp_sp lisp, const string& packageName, const string& declarestring);
     LambdaListHandler_sp lisp_function_lambda_list_handler(Lisp_sp lisp, Cons_sp lambda_list, Cons_sp declares );
 
-    void lisp_defun_lispify_name(Lisp_sp lisp, const string& packageName, const string& name,
+    void lisp_defun_lispify_name(const string& packageName, const string& name,
 				 Functoid*, const string& arguments="", const string& declarestring="",
 				 const string& docstring="", int locked=1, bool autoExport=true, int number_of_required_arguments=0 );
     void lisp_defmacro(const string& packageName, const string& name,
 		       Functoid*, const string& arguments="", const string& declarestring="",
 		       const string& docstring="", bool autoExport=true);
-    void lisp_defun(Lisp_sp lisp, const string& packageName, const string& name,
+    void lisp_defun(const string& packageName, const string& name,
 		    Functoid*, const string& arguments="", const string& declarestring="",
 		    const string& docstring="", int locked=1, bool autoExport=true, int number_of_required_arguments=0 );
-    void lisp_defgeneric(Lisp_sp lisp, const string& packageName, const string& name,
+    void lisp_defgeneric( const string& packageName, const string& name,
 			 Functoid*, const string& arguments="", const string& docstring="", bool autoExport=true  );
     void lisp_defmethod(Lisp_sp lisp, Symbol_sp gfSymbol, Functoid* func, const string& arguments, const string& docstring);
 
@@ -922,23 +933,31 @@
 
 
 
+
     class Functoid
     {
     private:
 	string	_Name;
     public:
-	T_mv static_activate( Functoid* self, const_ActivationFrame_spREF frame )
-	{
-	    return self->activate(frame);
-	}
     public:
 	virtual string describe() const {return "Functoid - subclass must implement describe()";};
-	virtual T_mv activate(const_ActivationFrame_spREF frame) {printf("Subclass of Functoid must implement 'activate'\n"); exit(1);};
+	virtual T_mv activate(const_ActivationFrame_spREF closedOverFrame, int nargs, ArgArray argArray) {printf("Subclass of Functoid must implement 'activate'\n"); exit(1);};
 
 	void dump() const
 	{
 	    printf( "Functoid - %s\n", this->_Name.c_str() );
 	}
+
+
+
+	T_mv funcall(int n_args, va_list vl) {
+	    //IMPLEMENT_ME();
+	    return Values0<T_O>();
+	}
+	    
+
+
+
 	Functoid( const string& name) : _Name(name) {};
 	virtual ~Functoid() {};
     };
@@ -948,7 +967,7 @@
     {
     public:
 	virtual string describe() const {return "AFFunctoid";};
-	virtual T_mv activate(const_ActivationFrame_spREF frame) {printf("Subclass of Functoid must implement 'activate'\n"); exit(1);};
+	virtual T_mv activate(const_ActivationFrame_spREF closedOverEnv, int nargs, ArgArray argArray) {printf("Subclass of Functoid must implement 'activate'\n"); exit(1);};
 
 	AFFunctoid(const string& name) : Functoid(name) {};
 	virtual ~AFFunctoid() {};
@@ -964,12 +983,20 @@
 	explicit SingleDispatchMethoid(const string& name) : AFFunctoid(name), _SingleDispatchArgumentIndex(0) {};
 	void setSingleDispatchArgumentIndex(int idx) { this->_SingleDispatchArgumentIndex = idx; };
 	virtual string describe() const {return "SingleDispatchMethoid";};
+	inline int incIdx(int& idx) {
+	    int startIdx = idx;
+	    idx++;
+	    if ( idx == this->_SingleDispatchArgumentIndex ) ++idx;
+	    return startIdx;
+	}
     };
 
 }
 
 
 
+
+
 #include <boost/random.hpp>
 
 
@@ -1081,7 +1108,7 @@
 #define UNLIKELY(x) brcl_unlikely(x)
 #define LIKELY(x) brcl_likely(x)
 
-#define unlikely_if if
+#define unlikely_if(x) if(UNLIKELY(x))
 #define BRCL_T (_lisp->_true())
 #define BRCL_NIL (_Nil<core::T_O>())
 
Index: funcallableStandardClass.h
===================================================================
--- funcallableStandardClass.h	(revision 4737)
+++ funcallableStandardClass.h	(working copy)
@@ -29,7 +29,7 @@
 {
     LISP_META_CLASS(StandardClass);
     LISP_BASE1(StdClass_O);
-    LISP_CLASS(core,CorePkg,FuncallableStandardClass_O,"FuncallableStandardClass");
+    LISP_CLASS(clos,ClosPkg,FuncallableStandardClass_O,"FuncallableStandardClass");
 public:
 #if defined(XML_ARCHIVE)
 	void	archiveBase(ArchiveP node);
Index: generate_af_function_templates.lisp
===================================================================
--- generate_af_function_templates.lisp	(revision 4737)
+++ generate_af_function_templates.lisp	(working copy)
@@ -40,16 +40,7 @@
 	       (format nil "~a" idx)
 	       "> a"
 	       (format nil "~a(af->entry(~a+~a));~%" idx (1- idx) offset)
-	       
-#||
-	       " = translate::from_object<P"
-	       (format nil "~a" idx)
-	       ">::convert(af->entry("
-	       (format nil "~a" (1- idx))
-	       "+"
-	       (format nil "~a" offset)
-	       "));~%"
-	       ||#
+       
 ))
 
 
@@ -59,6 +50,8 @@
 		       collect (from_object spaces  i offset))))))
 
 
+
+
 (defun function_args (num)
   (format nil (eval `(concatenate
 	  'string ,@(loop for i from 1 to num
@@ -69,20 +62,11 @@
 
 
 
-#|
-
-		    "class FunctionPtrT {~%"
-		    "public:~%"
-		    "    enum { NumParams = " arity  " };~%"
-		    "typedef RT(*Type)(" (P
-
-|#
-
 (defun _functionPtrT_fill (return-type arity max-arity &key const master)
   (let* ((s2 (format nil "~a" arity))
 	 (templateTree (list
 			"~%~%~%"
-			"// comment: " (if master "general_case" "partially_specialized") " returns(" return-type ") arity(" (format nil "~d" arity)  ")~%"
+			"// COMMENT: " (if master "general_case" "partially_specialized") " returns(" return-type ") arity(" (format nil "~d" arity)  ")~%"
 			"template < " (if (equal return-type "RT") "typename RT ") 
 			(if master (typename_P_args_void arity) (if (equal return-type "RT") (typename_P_args arity) (typename_P_args_no_RT arity))) ">~%"
 			"class " (if const "Const" "") "ActivationFrameFunctionPtrT " (if master "" (list "<" return-type (#|P_args_noVoid|# P_args arity max-arity) ">"))  " {~%"
@@ -104,6 +88,10 @@
 			    (list "        fn(" (function_args arity) ");~%"
 				  "        return Values0<core::T_O>();~%"))
 			"   }~%"
+
+
+
+
 			"};~%"))
 	 (template (flatten templateTree)))
     template))
@@ -117,19 +105,7 @@
 
 
 
-#|
-(_methodPtrT t "void" 0 10 "" "")
-(format t (eval `(concatenate 'string ,@res)))
 
-(defparameter res (_methodPtrT_fill "void" 0 10 "" ""))
-(mapcar (lambda (x) (print (class-of x))) res)
-(format t (eval `(concatenate 'string ,@res)))
-|#
-
-
-
-
-
 (defun def_fill_worker (arity)
   (let* ((tempTree (list
 		    "~%~%~%"
@@ -137,7 +113,7 @@
 		    "    void af_def(const string& packageName, const string& name, RT (*fp)(" (P_args_noVoid arity) ") , const string& arguments=\"\", const string& declares=\"\", const string& docstring=\"\", int locked=1 )~%"
 		    "    {_G();~%"
 		    "        Functoid* f = new ActivationFrameFunctionWrapPtr<RT" (if (= arity 0) "" ",") (P_args_noVoid arity) ">(packageName+\"::\"+name,fp);~%"
-		    "        lisp_defun_lispify_name(_lisp,packageName,name,f,arguments,declares,docstring,locked,true," (format nil "~d" arity) ");~%"
+		    "        lisp_defun_lispify_name(packageName,name,f,arguments,declares,docstring,locked,true," (format nil "~d" arity) ");~%"
 		    "    }~%"
 		    ))
 	(template (flatten tempTree)))
Index: genericFunction.cc
===================================================================
--- genericFunction.cc	(revision 4737)
+++ genericFunction.cc	(working copy)
@@ -5,6 +5,7 @@
 #include "core/lisp.h"
 #include "core/instance.h"
 #include "core/primitives.h"
+#include "core/evaluator.h"
 #include "core/multipleValues.h"
 #include "core/predicates.h"
 #include "core/vectorObjectsWithFillPtr.h"
@@ -90,7 +91,7 @@
 		 * compute the applicable methods. We must save
 		 * the keys and recompute the cache location if
 		 * it was filled. */
-		func = compute_applicable_method(env, frame, gf);
+	    func = compute_applicable_method(env, nargs, args, gf);
 		if (env->values[1] != ECL_NIL) {
 			cl_object keys = cl_copy_seq(vector);
 			if (e->key != OBJNULL) {
@@ -112,33 +113,33 @@
 
 
 
-    Cons_sp frame_to_classes(const_ActivationFrame_spREF frame)
+    Cons_sp frame_to_classes(int nargs, ArgArray args)
     {
 	Cons_sp arglist = _Nil<Cons_O>();
-	for ( int p=af_length(frame)-1; p>=0; --p)
+	for ( int p=nargs-1; p>=0; --p)
 	{
-	    T_sp co = af_classOf(frame->entry(p));
+	    T_sp co = af_classOf(args[p]);
 #if DEBUG_CLOS>=2
 	    printf("MLOG frame_to_classes class[%d] --> %lX  --> %s\n",
 		   p, co.intptr(), co->__repr__().c_str() );
 #endif
-	    arglist = Cons_O::create(co,arglist,_lisp);
+	    arglist = Cons_O::create(co,arglist);
 	}
 	return arglist;
     }
 
 
-    Cons_sp frame_to_list(const_ActivationFrame_spREF frame)
+    Cons_sp frame_to_list(int nargs, ArgArray args )
     {
 	Cons_sp arglist = _Nil<Cons_O>();
-	for ( int p=af_length(frame)-1; p>=0; --p)
+	for ( int p=nargs; p>=0; --p)
 	{
-	    T_sp co = frame->entry(p);
+	    T_sp co = args[p];
 #if DEBUG_CLOS>=2
 	    printf("MLOG frame_to_list p[%d] --> %lX  --> %s\n",
 		   p, co.intptr(), co->__repr__().c_str() );
 #endif
-	    arglist = Cons_O::create(co,arglist,_lisp);
+	    arglist = Cons_O::create(co,arglist);
 	}
 	return arglist;
     }
@@ -151,18 +152,18 @@
     SYMBOL_SC_(ClosPkg,compute_effective_method_function);
 
     /*! This function copies ECL>>gfun.d generic_compute_applicable_method */
-    T_mv generic_compute_applicable_method(const_ActivationFrame_spREF frame,
+    T_mv generic_compute_applicable_method(int nargs, ArgArray args,
 					   const Instance_O& gf)
     {
 	/* method not cached */
 	//cl_object memoize;
 	T_sp memoize;
 	T_mv methods = eval::funcall(clos::_sym_compute_applicable_methods_using_classes,
-				  gf.const_sharedThis<Instance_O>(),frame_to_classes(frame));
+				     gf.const_sharedThis<Instance_O>(),frame_to_classes(nargs,args));
 	memoize = methods.valueGet(1); // unlikely_if (Null(memoize = env->values[1])) {
 	if (memoize.nilp())
 	{
-	    Cons_sp arglist = frame->asCons();
+	    Cons_sp arglist = frame_to_list(nargs,args);
 	    methods = eval::funcall(cl::_sym_compute_applicable_methods,
 				    gf.const_sharedThis<Instance_O>(),arglist);
 	    if ( methods.nilp() )
@@ -170,7 +171,7 @@
 		SYMBOL_EXPORT_SC_(ClPkg,no_applicable_method);
 		T_sp func = eval::funcall(cl::_sym_no_applicable_method,
 					  gf.const_sharedThis<Instance_O>(),arglist);
-		frame->set_entry(0,_Nil<T_O>());
+		args[0] = _Nil<T_O>();
 		return(Values(func,_Nil<T_O>()));
 	    }
 	}
@@ -183,18 +184,18 @@
     SYMBOL_SC_(ClosPkg,std_compute_effective_method);
 
     /*! This function copies ECL>>gfun.d restricted_compute_applicable_method */
-    T_mv restricted_compute_applicable_method(const_ActivationFrame_spREF frame,
+    T_mv restricted_compute_applicable_method(int nargs, ArgArray args,
 					      const Instance_O& gf)
     {
 	Instance_sp igf = gf.const_sharedThis<Instance_O>();
 	/* method not cached */
-	Cons_sp arglist = frame_to_list(frame);
+	Cons_sp arglist = frame_to_list(nargs,args);
 	T_sp methods = eval::funcall(clos::_sym_std_compute_applicable_methods,igf,arglist);
 	if ( methods.nilp() )
 	{
 	    Function_sp func = eval::funcall(cl::_sym_no_applicable_method,
 					     igf,arglist).as<Function_O>();
-	    frame->set_entry(0,_Nil<T_O>());
+	    args[0] = _Nil<T_O>();
 	    return(Values(func,_Nil<T_O>()));
 	}
 	methods = eval::funcall(clos::_sym_std_compute_effective_method,igf,gf.GFUN_COMB(),methods);
@@ -205,14 +206,14 @@
 
 
 
-T_mv compute_applicable_method(const_ActivationFrame_spREF frame, T_sp gf)
+    T_mv compute_applicable_method(int nargs, ArgArray args, T_sp gf)
 {
     if (gf.as<Instance_O>()->isgf() == ECL_RESTRICTED_DISPATCH )
     {
-	return restricted_compute_applicable_method(frame, *(gf.as<Instance_O>().get()));
+	return restricted_compute_applicable_method(nargs,args, *(gf.as<Instance_O>().get()));
     } else
     {
-	return generic_compute_applicable_method(frame, *(gf.as<Instance_O>().get()));
+	return generic_compute_applicable_method(nargs,args, *(gf.as<Instance_O>().get()));
     }
 }
 
@@ -224,13 +225,12 @@
 
 /*! Mimic ECL>>gfun.d fill_spec_vector */
     VectorObjectsWithFillPtr_sp& fill_spec_vector(VectorObjectsWithFillPtr_sp& vektor,
-							 const_ActivationFrame_spREF frame, T_sp& gf)
+						  int nargs, ArgArray args, T_sp& gf)
     {
 #if DEBUG_CLOS>=2
 	printf("MLOG fill_spec_vector - entered with gf  %s\n", gf.as<Instance_O>()->GFUN_NAME()->__repr__().c_str() );
 #endif
-	int narg = af_length(frame);
-	const ActivationFrame_O& args = *(frame.get());
+	int narg = nargs;
 	T_sp spec_how_list = gf.as<Instance_O>()->GFUN_SPECIALIZERS();
 	// cl_object *argtype = vector->vector.self.t; // ??
 	VectorObjectsWithFillPtr_sp& argtype = vektor;
@@ -287,7 +287,7 @@
 
 
 
-    T_mv standard_dispatch(const_ActivationFrame_spREF frame, T_sp gf)
+    T_mv standard_dispatch(T_sp gf, int nargs, ArgArray args)
     {
 #if DEBUG_CLOS>=2
 	printf("MLOG  ------------ standard_dispatch\n");
@@ -296,7 +296,7 @@
 #if defined(CACHE_METHOD_LOOKUP)
 	Cache* cache = _lisp->methodCachePtr();
 	CacheRecord* e;
-	VectorObjectsWithFillPtr_sp& vektor = fill_spec_vector(cache->keys(), frame, gf);
+	VectorObjectsWithFillPtr_sp& vektor = fill_spec_vector(cache->keys(), nargs, args, gf);
 	e = cache->search_cache(); // e = ecl_search_cache(cache);
 	ASSERT(e!=NULL);
 	if (e->_key.notnilp()) {
@@ -314,7 +314,7 @@
 	     * compute the applicable methods. We must save
 	     * the keys and recompute the cache location if
 	     * it was filled. */
-	    T_mv mv = compute_applicable_method( frame, gf);
+	    T_mv mv = compute_applicable_method( nargs, args, gf);
 	    func = mv.as<Function_O>();
 	    if (mv.valueGet(1).notnilp() )
 	    {
@@ -332,8 +332,12 @@
 	// This is where it fails because applicable_method does not downcast to a Function
 	func = applicable_method.as<Function_O>();
 #endif
+#ifndef FIGURED_OUT_WHAT_TO_DO
+	IMPLEMENT_MEF(BF("Figure out what to do here - how do I pass frame to funcall??????"));
+#else
 	T_mv result  = eval::funcall(func,frame,_Nil<T_O>());
 	return result;
+#endif
     }
 
 
@@ -361,15 +365,15 @@
         return output;
 }
  */
-    T_mv generic_function_dispatch(const_ActivationFrame_spREF frame, const Instance_O& gf)
+ T_mv generic_function_dispatch( const Instance_O& gf, int nargs, ArgArray args)
     {
-	return standard_dispatch(frame,gf.const_sharedThis<Instance_O>());
+	return standard_dispatch(gf.const_sharedThis<Instance_O>(),nargs,args);
     }
 
 
     
     /*! Reproduces functionality in ecl_slot_reader_dispatch */
-    T_mv slotReaderDispatch(const_ActivationFrame_spREF frame, const Instance_O& gf)
+T_mv slotReaderDispatch( const Instance_O& gf, int nargs, ArgArray args )
     {
 	IMPLEMENT_MEF(BF("Implement slotReaderDispatch"));
     }
@@ -377,19 +381,19 @@
 
 
     /*! Reproduces functionality in ecl_slot_writer_dispatch */
-    T_mv slotWriterDispatch(const_ActivationFrame_spREF frame, const Instance_O& gf)
+T_mv slotWriterDispatch( const Instance_O& gf, int nargs, ArgArray args )
     {
 	IMPLEMENT_MEF(BF("Implement slotWriterDispatch"));
     }
 
     /*! Reproduces functionality in user_function_dispatch */
-    T_mv userFunctionDispatch(const_ActivationFrame_spREF frame, const Instance_O& gf)
+T_mv userFunctionDispatch( const Instance_O& gf, int nargs, ArgArray args )
     {
 	IMPLEMENT_MEF(BF("Implement userFunctionDispatch"));
     }
 
     /*! Reproduces functionality in FEnot_funcallable_vararg */
-    T_mv notFuncallableDispatch(const_ActivationFrame_spREF frame, const Instance_O& gf)
+T_mv notFuncallableDispatch( const Instance_O& gf, int nargs, ArgArray args )
     {
 	IMPLEMENT_MEF(BF("Implement notFuncallableDispatch"));
     }
Index: genericFunction.h
===================================================================
--- genericFunction.h	(revision 4737)
+++ genericFunction.h	(working copy)
@@ -7,19 +7,17 @@
 namespace core
 {
 
-    T_mv notFuncallableDispatch(const_ActivationFrame_spREF frame, const Instance_O& gf);
+    T_mv notFuncallableDispatch( const Instance_O& gf, int nargs, ArgArray args);
     
-    T_mv generic_function_dispatch(const_ActivationFrame_spREF frame, const Instance_O& gf);
+    T_mv generic_function_dispatch( const Instance_O& gf, int nargs, ArgArray args);
 
-    T_mv slotReaderDispatch(const_ActivationFrame_spREF frame, const Instance_O& gf);
+    T_mv slotReaderDispatch( const Instance_O& gf, int nargs, ArgArray args);
 
-    T_mv slotWriterDispatch(const_ActivationFrame_spREF frame, const Instance_O& gf);
+    T_mv slotWriterDispatch( const Instance_O& gf, int nargs, ArgArray args);
 
-    T_mv userFunctionDispatch(const_ActivationFrame_spREF frame, const Instance_O& gf);
+    T_mv userFunctionDispatch( const Instance_O& gf, int nargs, ArgArray args);
 
-    T_mv notFuncallableDispatch(const_ActivationFrame_spREF frame, const Instance_O& gf);
 
-
     void initialize_genericFunction();
     
 };
Index: glue.h
===================================================================
--- glue.h	(revision 4737)
+++ glue.h	(working copy)
@@ -111,7 +111,7 @@
 	{								\
 	    typedef	mem::smart_ptr<oClass>	ExpectedType;		\
 	    typedef	mem::smart_ptr<oClass>	DeclareType;		\
-	    DeclareType _v; \
+	    DeclareType _v;						\
 	    from_object(mem::smart_ptr<core::T_O> o)			\
 	    {								\
 		this->_v = o.as<oClass>();				\
@@ -121,8 +121,8 @@
 	{								\
 	    typedef	mem::smart_ptr<oClass>	ExpectedType;		\
 	    typedef	mem::smart_ptr<oClass>	DeclareType;		\
-	    DeclareType _v; \
-	    from_object(mem::smart_ptr<core::T_O> o)	\
+	    DeclareType _v;						\
+	    from_object(mem::smart_ptr<core::T_O> o)			\
 	    {								\
 		this->_v = o.as<oClass>();				\
 	    }								\
Index: grayPackage.cc
===================================================================
--- grayPackage.cc	(revision 4737)
+++ grayPackage.cc	(working copy)
@@ -46,8 +46,7 @@
     void initialize_grayPackage()
     {
 	list<string> lnicknames;
-	list<core::Package_sp> luse;
-	luse.push_front(_lisp->findPackage("COMMON-LISP"));
+	list<string> luse = { "COMMON-LISP" };
 	_lisp->makePackage("GRAY",lnicknames,luse);
 	// We don't have to create the GRAY symbols here - it's done in bootStrapCoreSymbolMap
     }
Index: hashTable.cc
===================================================================
--- hashTable.cc	(revision 4738)
+++ hashTable.cc	(working copy)
@@ -13,6 +13,7 @@
 #include "hashTableEqualp.h"
 #include "vectorObjects.h"
 #include "fileSystem.h"
+#include "serialize.h"
 #include "evaluator.h"
 #include "designators.h"
 #include "core/wrappers.h"
@@ -74,7 +75,7 @@
 #define DECL_af_maphash ""    
     T_mv af_maphash(T_sp function_desig, HashTable_sp hash_table)
     {_G();
-	Function_sp func = coerce::functionDesignator(function_desig,_lisp);
+	Function_sp func = coerce::functionDesignator(function_desig);
 	for ( size_t it=0, itEnd = af_length(hash_table->_HashTable); it<itEnd; ++it )
 	{
 
@@ -82,8 +83,12 @@
 	    for ( Cons_sp cur=first; cur.notnilp(); cur = cCdr(cur) )
 	    {
 		Cons_sp entry = oCar(cur).as_or_nil<Cons_O>();
+		eval::funcall(func,oCar(entry),oCdr(entry));
+#if 0
+		Cons_sp entry = oCar(cur).as_or_nil<Cons_O>();
 		ValueFrame_sp frame(ValueFrame_O::create_fill(oCar(entry),oCdr(entry),_Nil<ActivationFrame_O>()));
 		eval::apply(func,frame);
+#endif
 	    }
 	}
 	return(Values(_Nil<T_O>()));
@@ -179,7 +184,7 @@
 
     void HashTable_O::setup( uint sz,  Number_sp rehashSize, double rehashThreshold)
     {_OF();
-	this->resizeEmptyTable(sz);
+	sz = this->resizeEmptyTable(sz);
 	this->_InitialSize = sz;
 	this->_RehashSize = rehashSize;
 	ASSERT(!this->_RehashSize->zerop());
@@ -258,14 +263,26 @@
     }
 #endif
 
-#if defined(XML_ARCHIVE)
     void HashTable_O::archiveBase(::core::ArchiveP node)
     {
-	IMPLEMENT_ME();
-//        this->Bases::archiveBase(node);
-	// Archive other instance variables here
+	SYMBOL_EXPORT_SC_(KeywordPkg,rehashSize);
+	SYMBOL_EXPORT_SC_(KeywordPkg,rehashThreshold);
+	node->attribute(kw::_sym_rehashSize,this->_RehashSize);
+	node->attribute(kw::_sym_rehashThreshold,this->_RehashThreshold);
+	if ( node->loading() ) {
+	    this->clrhash();
+	    node->mapVector( [this] (T_sp keyValue) {
+		    T_sp key = oCar(keyValue);
+		    T_sp val = oCdr(keyValue);
+		    this->hash_table_setf_gethash(key,val);
+		} );
+	} else {
+	    this->mapHash( [&node] (T_sp key, T_sp val) {
+		    Cons_sp keyValue = Cons_O::create(key,val);
+		    node->pushVector(keyValue);
+		} );
+	}
     }
-#endif // defined(XML_ARCHIVE)
 
 
     void HashTable_O::initialize()
@@ -277,10 +294,11 @@
     }
 
 
-    void HashTable_O::resizeEmptyTable(uint sz)
+    uint HashTable_O::resizeEmptyTable(uint sz)
     {_OF();
-	ASSERTF(sz!=0, BF("The hashtable should never be resized to %d") % sz );
+	if ( sz < 4 ) sz = 4;
 	this->_HashTable = VectorObjects_O::make(_Nil<Cons_O>(),_Nil<Cons_O>(),sz,false);
+	return sz;
     }
 
 
@@ -443,7 +461,7 @@
 	}
 	VectorObjects_sp oldTable(VectorObjects_O::create());
 	oldTable->swap(this->_HashTable);
-	this->resizeEmptyTable(newSize);
+	newSize = this->resizeEmptyTable(newSize);
 	LOG(BF("Resizing table to size: %d") % newSize );
 	for ( size_t it(0), itEnd(af_length(oldTable)); it<itEnd; ++it )
 	{
@@ -481,7 +499,7 @@
     }
 
 
-#define ARGS_HashTable_O_hash_table_dump ""
+#define ARGS_HashTable_O_hash_table_dump "()"
 #define DECL_HashTable_O_hash_table_dump ""
 #define DOCS_HashTable_O_hash_table_dump "Dump the hash-table"
     string HashTable_O::hash_table_dump() const
@@ -502,6 +520,18 @@
     }
 
 
+    void HashTable_O::mapHash(std::function<void(T_sp,T_sp)> const& fn)
+    {
+	for ( size_t it(0),itEnd(af_length(this->_HashTable)); it<itEnd; ++it )
+	{
+	    Cons_sp first = this->_HashTable->operator[](it).as_or_nil<Cons_O>();
+	    for ( Cons_sp cur=first; cur.notnilp(); cur = cCdr(cur) )
+	    {
+		fn(oCar(cCar(cur)),oCdr(cCar(cur)));
+	    }
+	}
+    }
+
     void HashTable_O::lowLevelMapHash(KeyValueMapper* mapper) const
     {_OF();
 	for ( size_t it(0),itEnd(af_length(this->_HashTable)); it<itEnd; ++it )
Index: hashTable.h
===================================================================
--- hashTable.h	(revision 4738)
+++ hashTable.h	(working copy)
@@ -20,9 +20,8 @@
     {
 	LISP_BASE1(T_O);
 	LISP_VIRTUAL_CLASS(core,ClPkg,HashTable_O,"HashTable");
-#if defined(XML_ARCHIVE)
-	DECLARE_ARCHIVE();
-#endif // defined(XML_ARCHIVE)
+	void archiveBase(SNode_sp node);
+
 	HashTable_O() : _RehashSize(_Nil<Number_O>()), _HashTable(_Nil<VectorObjects_O>()) {};
 	virtual ~HashTable_O() {};
 //	DEFAULT_CTOR_DTOR(HashTable_O);
@@ -54,7 +53,7 @@
 	static void sxhash_equalp(HashGenerator& running_hash, T_sp obj);
     private:
 	void setup(uint sz, Number_sp rehashSize, double rehashThreshold );
-	void resizeEmptyTable(uint sz);
+	uint resizeEmptyTable(uint sz);
 	uint calculateHashTableCount() const;
 	void expandHashTable();
 	
@@ -62,6 +61,8 @@
 
 	/*! See CLHS */
 	virtual T_sp hashTableTest() const {SUBIMP();};
+	
+	/*! Return a count of the number of keys */
 	uint hashTableCount() const;
 
 	virtual Number_sp hashTableRehashSize() const { return this->_RehashSize;};
@@ -89,6 +90,8 @@
 
 	void lowLevelMapHash(KeyValueMapper* mapper) const;
 
+	void mapHash(std::function<void(T_sp, T_sp)> const& fn);
+
 	/*! Return the number of entries in the HashTable Vector0 */
 	int hashTableNumberOfHashes() const;
 	/*! Return the start of the alist in the HashTable Vector0 at hash value */
@@ -98,6 +101,7 @@
 
     HashTable_mv af_make_hash_table(T_sp test, Fixnum_sp size, Number_sp rehash_size, DoubleFloat_sp orehash_threshold);
 
+
 }; /* core */
 
 TRANSLATE(core::HashTable_O);
Index: holder.h
===================================================================
--- holder.h	(revision 4737)
+++ holder.h	(working copy)
@@ -26,6 +26,7 @@
 	typedef OT 			object_type;
 	typedef	mem::smart_ptr<OT>	ptr_type;
     public:
+	
 	void	push(ptr_type  obj) { this->push_back(obj); };
 	void	pop() { this->pop_back(); };
 	void	append(ptr_type obj) { this->push_back(obj); };
@@ -305,9 +306,15 @@
 	}
 	void	set(Symbol_sp s, value_type obj)
 	{_G();
-	    this->operator[](s) = this->_Values.size();
-	    this->_Values.push_back(obj);
-	    ASSERT(this->size()==this->_Values.size()); 
+	    iterator it = this->find(s);
+	    if ( it != this->end() )
+	    {
+		this->_Values[it->second] = obj;
+	    } else {
+		this->operator[](s) = this->_Values.size();
+		this->_Values.push_back(obj);
+	    }
+	    ASSERTF(this->size()==this->_Values.size(),BF("There is a IndexedSymbolMap mismatch in the size of the key map[%d elements] and the value vector[%d elements] when set(ing) key: %s to value: %s  key already present: %d") % this->size() % this->_Values.size() % _rep_(s) % (it != this->end() )); 
 	};
 	value_type get(Symbol_sp name) const
 	{_G();
@@ -450,6 +457,14 @@
 	    ASSERTP(!this->contains(obj),"The UnorderedSet already contains object("+_rep_(obj)+")");
 	    this->insert(obj);
 	};
+	void map( std::function<void(mem::smart_ptr<OType>)> fn) {
+	    typename UnorderedSet::const_iterator it;
+	    for ( it=this->begin(); it!=this->end(); it++ )
+	    {
+		fn(*it);
+	    }
+	}
+	    
 	Cons_sp asCons(Lisp_sp e)
 	{
 	    Cons_sp first = Cons_O::create(_Nil<T_O>(),_Nil<Cons_O>(),e);
Index: instance.cc
===================================================================
--- instance.cc	(revision 4737)
+++ instance.cc	(working copy)
@@ -13,10 +13,10 @@
 {
 
 
-#define ARGS_af_setFuncallableInstanceFunction "(instance func)"
-#define DECL_af_setFuncallableInstanceFunction ""
-#define DOCS_af_setFuncallableInstanceFunction "setFuncallableInstanceFunction"
-    T_sp af_setFuncallableInstanceFunction(T_sp obj, T_sp func)
+#define ARGS_clos_setFuncallableInstanceFunction "(instance func)"
+#define DECL_clos_setFuncallableInstanceFunction ""
+#define DOCS_clos_setFuncallableInstanceFunction "setFuncallableInstanceFunction"
+    T_sp clos_setFuncallableInstanceFunction(T_sp obj, T_sp func)
     {_G();
 	if ( Instance_sp iobj = obj.asOrNull<Instance_O>() )
 	{
@@ -89,6 +89,11 @@
     }
 
 
+    void Instance_O::archiveBase(ArchiveP node)
+    {
+	IMPLEMENT_MEF(BF("Call out to core:serialize me node"));
+    }
+
     Instance_O::Instance_O() :
 	Function_O(), _isgf(ECL_NOT_FUNCALLABLE), _Class(_Nil<Class_O>()),
 	_NumberOfSlots(0), _Slots(NULL), _Entry(NULL), _Sig(_Nil<T_O>()) {};
@@ -147,8 +152,8 @@
 	    ;
 
 	af_def(CorePkg,"allocateRawInstance",&Instance_O::allocateRawInstance);
-	SYMBOL_EXPORT_SC_(CorePkg,setFuncallableInstanceFunction);
-	Defun(setFuncallableInstanceFunction);
+	SYMBOL_EXPORT_SC_(ClosPkg,setFuncallableInstanceFunction);
+	ClosDefun(setFuncallableInstanceFunction);
 	SYMBOL_EXPORT_SC_(CorePkg,instanceClassSet);
 	Defun(instanceClassSet);
     }
@@ -353,10 +358,11 @@
 
 
 
-    T_mv Instance_O::INVOKE(const_ActivationFrame_spREF frame)
+
+    T_mv Instance_O::INVOKE(int nargs, ArgArray args)
     {
 	ASSERT(this->_Entry!=NULL);
-	return(( (this->_Entry)(frame,*this)));
+	return(( (this->_Entry)(*this,nargs,args)));
     }
 
 
Index: instance.h
===================================================================
--- instance.h	(revision 4737)
+++ instance.h	(working copy)
@@ -19,12 +19,15 @@
 
 namespace core
 {
+
+
+
     class Instance_O : public Function_O
     {
 	LISP_BASE1(Function_O);
 	LISP_CLASS(core,CorePkg,Instance_O,"Instance");
 	friend class Class_O;
-//    DECLARE_ARCHIVE();
+	void archiveBase(ArchiveP node);
     public: // ctor/dtor for classes with shared virtual base
 	explicit Instance_O();
 	virtual ~Instance_O();
@@ -33,7 +36,7 @@
 	Class_sp 				_Class;
 	int					_NumberOfSlots;
 	T_sp*					_Slots;
-	ActivationFrameGenericFunctionPtr 	_Entry;
+	ArgArrayGenericFunctionPtr 	_Entry;
 	/*! TODO: I don't know what this is for
 	  - mimicking ECL instance->sig generation signature */
 	T_sp 		_Sig;
@@ -94,6 +97,8 @@
     private:
 	void reshapeInstance(int delta);
 
+    public:
+	virtual T_mv INVOKE(int nargs, ArgArray argArray );
     public: // Functions here
 	int numberOfSlots() const { return this->_NumberOfSlots;};
 	/*! Return number of slots if not nil otherwise nil */
@@ -127,8 +132,6 @@
 
 
 
-	virtual T_mv INVOKE(const_ActivationFrame_spREF exp);
-
 	void __write__(Stream_sp sout) const; // Look in write_ugly.cc
 
 
Index: keywordPackage.cc
===================================================================
--- keywordPackage.cc	(revision 4737)
+++ keywordPackage.cc	(working copy)
@@ -23,9 +23,8 @@
 
     core::Package_sp initialize_keywordPackage()
     {
-	list<string> lnicknames;
-	list<core::Package_sp> luse;
-	lnicknames.push_front("kw");
+	list<string> lnicknames = {"KW"};;
+	list<string> luse;
 	core::Package_sp keywordPackage = _lisp->makePackage("KEYWORD",lnicknames,luse);
 	keywordPackage->setKeywordPackage(true);
 	return keywordPackage;
Index: lambdaListHandler.cc
===================================================================
--- lambdaListHandler.cc	(revision 4737)
+++ lambdaListHandler.cc	(working copy)
@@ -1,6 +1,8 @@
 #define	DEBUG_LEVEL_NONE
 
 
+#include <string.h>
+#include "core/config.h"
 #include "core/common.h"
 #include "core/environment.h"
 #include "symbolTable.h"
@@ -18,6 +20,7 @@
 
     T_sp evaluate_lambda_list_form(T_sp form, Environment_sp env)
     {
+	Environment_sp localEnv(env);
 	// TODO:: The code should be compiled and not interpreted
 	TopLevelIHF stackFrame(_lisp->invocationHistoryStack(),form);
 	return eval::evaluate(form,env);
@@ -51,7 +54,7 @@
 		if ( !this->_LambdaListSpecials->contains(*it) )
 		{
 		    this->_AccumulatedClassifiedSymbols
-			<< Cons_O::create(_sym_specialVar,*it,_lisp);
+			<< Cons_O::create(ext::_sym_specialVar,*it,_lisp);
 		}
 	    }
 	}
@@ -272,12 +275,12 @@
 	if ( sym->specialP() || (this->_SpecialSymbols.notnilp() && this->_SpecialSymbols->contains(sym) ))
 	{
 	    target._ArgTargetFrameIndex = SPECIAL_TARGET;
-	    this->_AccumulatedClassifiedSymbols << Cons_O::create(_sym_specialVar,target._ArgTarget,_lisp);
+	    this->_AccumulatedClassifiedSymbols << Cons_O::create(ext::_sym_specialVar,target._ArgTarget,_lisp);
 	    this->_LambdaListSpecials->insert(sym);
 	} else
 	{
 	    target._ArgTargetFrameIndex = this->_LexicalIndex;
-	    this->_AccumulatedClassifiedSymbols << Cons_O::create(_sym_lexicalVar,Cons_O::create(target._ArgTarget,Fixnum_O::create(target._ArgTargetFrameIndex),_lisp),_lisp);
+	    this->_AccumulatedClassifiedSymbols << Cons_O::create(ext::_sym_lexicalVar,Cons_O::create(target._ArgTarget,Fixnum_O::create(target._ArgTargetFrameIndex),_lisp),_lisp);
 	    ++this->_LexicalIndex;
 	}
     }
@@ -350,43 +353,122 @@
 
 
 
+    SYMBOL_SC_(CorePkg,tooFewArguments);
 
 
+// Setup argument binding for ActivationFrame 
+#define PASS_FUNCTION_REQUIRED 	bind_required_af
+#define PASS_FUNCTION_OPTIONAL 	bind_optional_af
+#define PASS_FUNCTION_REST 	bind_rest_af
+#define PASS_FUNCTION_KEYWORD 	bind_keyword_af
+#define PASS_ARGS	     	const_ActivationFrame_spREF args
+#define PASS_ARGS_NUM		af_length(args)
+#define PASS_NEXT_ARG()		args->entry(arg_idx)
+#include "argumentBinding.cc"
+#undef PASS_FUNCTION_REQUIRED
+#undef PASS_FUNCTION_OPTIONAL
+#undef PASS_FUNCTION_REST
+#undef PASS_FUNCTION_KEYWORD
+#undef PASS_ARGS
+#undef PASS_ARGS_NUM
+#undef PASS_NEXT_ARG
 
+
+#define PASS_FUNCTION_REQUIRED 	bind_required_argArray
+#define PASS_FUNCTION_OPTIONAL 	bind_optional_argArray
+#define PASS_FUNCTION_REST 	bind_rest_argArray
+#define PASS_FUNCTION_KEYWORD 	bind_keyword_argArray
+#define PASS_FUNCTION_SUFFIX 	argArray
+#define PASS_ARGS	     	int n_args, ArgArray ap
+#define PASS_ARGS_NUM		n_args
+#define PASS_NEXT_ARG()		ap[arg_idx]
+#include "argumentBinding.cc"
+#undef PASS_FUNCTION_REQUIRED
+#undef PASS_FUNCTION_OPTIONAL
+#undef PASS_FUNCTION_REST
+#undef PASS_FUNCTION_KEYWORD
+#undef PASS_ARGS
+#undef PASS_ARGS_NUM
+#undef PASS_NEXT_ARG
+
+
+void bind_aux
+(vector<AuxArgument> const& auxs, DynamicScopeManager& scope )
+{_G();
+    int num_auxs = auxs.size();
+    if ( num_auxs == 0 ) return;
+    LOG(BF("There are %d aux variables") % auxs.size() );
+    vector<AuxArgument>::const_iterator ci;
+    {_BLOCK_TRACE("Assigning aux variables");
+	for ( ci = auxs.begin(); ci!=auxs.end(); ci++ )
+	{
+	    T_sp expr = ci->_Expression;
+	    if ( expr.notnilp() )
+	    {
+		T_sp value = evaluate_lambda_list_form(expr,scope.lexenv());
+		scope.new_binding(*ci,value);
+	    } else
+	    {
+		scope.new_binding(*ci,_Nil<T_O>());
+	    }
+	}
+    }
+}
+
+
+
+    void LambdaListHandler_O::createBindingsInScope_af(
+				 const_ActivationFrame_spREF args,
+	DynamicScopeManager& scope )
+    {_G();
+	if ( UNLIKELY(!this->_CreatesBindings) ) return;
+	int arg_idx = 0;
+	arg_idx = bind_required_af( this->_RequiredArguments, args, arg_idx, scope );
+	arg_idx = bind_optional_af( this->_OptionalArguments, args, arg_idx, scope );
+	if ( UNLIKELY(arg_idx < af_length(args) && (!this->_RestArgument.isDefined()) && (this->_KeywordArguments.size() == 0))) {
+	    TOO_MANY_ARGUMENTS_ERROR();
+	}
+	bind_rest_af( this->_RestArgument, args, arg_idx, scope );
+	bind_keyword_af( this->_KeywordArguments, this->_AllowOtherKeys, args, arg_idx, scope );
+	bind_aux( this->_AuxArguments, scope );
+    }
+
+
+
+    void LambdaListHandler_O::createBindingsInScope_argArray(int n_args, ArgArray argArray,
+	DynamicScopeManager& scope )
+    {_G();
+	if ( UNLIKELY(!this->_CreatesBindings) ) return;
+	int arg_idx = 0;
+	arg_idx = bind_required_argArray( this->_RequiredArguments, n_args, argArray, arg_idx, scope );
+	arg_idx = bind_optional_argArray( this->_OptionalArguments, n_args, argArray, arg_idx, scope );
+	if ( UNLIKELY(arg_idx < n_args && (!this->_RestArgument.isDefined()) && (this->_KeywordArguments.size() == 0))) {
+	    TOO_MANY_ARGUMENTS_ERROR();
+	}
+	bind_rest_argArray( this->_RestArgument, n_args, argArray, arg_idx, scope );
+	bind_keyword_argArray( this->_KeywordArguments, this->_AllowOtherKeys, n_args, argArray, arg_idx, scope );
+	bind_aux( this->_AuxArguments, scope );
+    }
+
+#if 0 // OLD WORKING CODE
     int bind_required_arguments( vector<RequiredArgument> const& reqs,
-				  const_ActivationFrame_spREF args,
-				  int arg_idx,
-				 ValueEnvironmentDynamicScopeManager& scope,
-				 Environment_sp env)
+				 const_ActivationFrame_spREF args,
+				 int arg_idx,
+				 /*ValueEnvironment*/DynamicScopeManager& scope
+				 /*, Environment_sp env*/)
     {_G();
 	// Fill required arguments
 	{_BLOCK_TRACE("Assigning required arguments");
 	    LOG(BF("There are %d required arguments") % reqs.size() );
 	    if ( af_length(args) < reqs.size() )
 	    {
-		SYMBOL_SC_(CorePkg,tooFewArguments);
 		TOO_FEW_ARGUMENTS_ERROR();
 	    }
 	    for ( vector<RequiredArgument>::const_iterator it = reqs.begin(); it!= reqs.end(); it++ )
 	    {
-		if ( !it->isDefined() )
-		{
-		    LOG(BF("Throwing exception because it->_Target isNil"));
-		    TOO_FEW_ARGUMENTS_ERROR();
-		}
-		if ( it->_symbolP() )
-		{
-		    T_sp value = args->entry(arg_idx);
-		    LOG(BF("Binding value[%s] to target[%s]") % value->__repr__() % it->asString() );
-		    scope.new_binding(*it,value);
-		} else if ( it->_lambdaListHandlerP() )
-		{
-		    // Destructuring nested lambda list handlers
-		    LambdaListHandler_sp llh = it->lambdaListHandler();
-		    Cons_sp sub = args->entry(arg_idx).as_or_nil<Cons_O>();
-		    ValueFrame_sp frame(ValueFrame_O::create(sub,_Nil<ActivationFrame_O>()));
-		    llh->createBindingsInEnvironment(frame,scope,env);
-		}
+		T_sp value = args->entry(arg_idx);
+		LOG(BF("Binding value[%s] to target[%s]") % value->__repr__() % it->asString() );
+		scope.new_binding(*it,value);
 		++arg_idx;
 	    }
 	}
@@ -398,8 +480,8 @@
     void fill_activation_frame_required_arguments( vector<RequiredArgument> const& reqs,
 						   const_ActivationFrame_spREF args,
 						   int& arg_idx,
-						   ActivationFrameDynamicScopeManager& scope,
-						   Environment_sp env )
+						   /*ActivationFrame*/DynamicScopeManager& scope
+						   /*,Environment_sp env*/ )
     {_G();
 	// Fill required arguments
 	size_t length_args(af_length(args));
@@ -412,24 +494,9 @@
 	    LOG(BF("There are %d required arguments") % reqs.size() );
 	    for ( vector<RequiredArgument>::const_iterator it = reqs.begin(); it!= reqs.end(); it++ )
 	    {
-		if ( !it->isDefined() )
-		{
-		    LOG(BF("Throwing exception because it->_Target isNil"));
-		    TOO_FEW_ARGUMENTS_ERROR();
-		}
 		T_sp value = args->entry(arg_idx);
-		if ( it->_symbolP() )
-		{
-		    LOG(BF("Binding value[%s] to target[%s]") % value->__repr__() % it->asString() );
-		    scope.new_binding(*it,value);
-		} else if ( it->_lambdaListHandlerP() )
-		{
-		    // Destructuring nested lambda list handlers
-		    LambdaListHandler_sp llh = it->lambdaListHandler();
-		    Cons_sp cvalue = value.as_or_nil<Cons_O>();
-		    ValueFrame_sp subFrame(ValueFrame_O::create(cvalue,_Nil<ActivationFrame_O>()));
-		    llh->createBindingsInActivationFrame(subFrame,scope,env);
-		}
+		LOG(BF("Binding value[%s] to target[%s]") % value->__repr__() % it->asString() );
+		scope.new_binding(*it,value);
 		++arg_idx;
 	    }
 	}
@@ -443,8 +510,8 @@
     int bind_optional_arguments( vector<OptionalArgument> const& optionals,
 				 const_ActivationFrame_spREF args,
 				 int arg_idx,
-				 ValueEnvironmentDynamicScopeManager& scope,
-				 Environment_sp env)
+				 /*ValueEnvironment*/DynamicScopeManager& scope
+				 /* , Environment_sp env */)
     {_G();
 	// Fill required arguments
 	LOG(BF("There are %d optional arguments") % optionals.size() );
@@ -460,18 +527,7 @@
 		}
 		T_sp value = args->entry(arg_idx);
 		LOG(BF("Binding value[%s] to target[%s]") % value->__repr__() % it->asString() );
-		if ( it->_symbolP() )
-		{
-		    LOG(BF("Binding value[%s] to target[%s]") % value->__repr__() % it->asString() );
-		    scope.new_binding(*it,value);
-		} else if ( it->_lambdaListHandlerP() )
-		{
-		    ValueFrame_sp frame(ValueFrame_O::create(value.as_or_nil<Cons_O>(),_Nil<ActivationFrame_O>()));
-		    it->lambdaListHandler()->createBindingsInEnvironment(frame,scope,env);
-		} else
-		{
-		    SIMPLE_ERROR(BF("Illegal target type for bind: %s") % it->asString() );
-		}
+		scope.new_binding(*it,value);
 		if ( it->_Sensor.isDefined() )
 		{
 		    scope.new_binding(it->_Sensor,_lisp->_true());
@@ -486,17 +542,7 @@
 		LOG(BF("Init form: %s") % init_form->__repr__() );
 		T_sp value = evaluate_lambda_list_form(init_form,scope.lexenv());
 		LOG(BF("Binding value[%s] to target[%s]") % value->__repr__() % it->asString() );
-		if ( it->_symbolP() )
-		{
-		    scope.new_binding(*it,value);
-		} else if ( it->_lambdaListHandlerP() )
-		{
-		    ValueFrame_sp frame(ValueFrame_O::create(value.as_or_nil<Cons_O>(),_Nil<ActivationFrame_O>()));
-		    it->lambdaListHandler()->createBindingsInEnvironment(frame,scope,env);
-		} else
-		{
-		    SIMPLE_ERROR(BF("Illegal target type for bind: %s") % it->asString() );
-		}
+		scope.new_binding(*it,value);
 		if ( it->_Sensor.isDefined() )
 		{
 		    scope.new_binding(it->_Sensor,_lisp->_false());
@@ -515,8 +561,8 @@
     void fill_activation_frame_optional_arguments( vector<OptionalArgument> const& optionals,
 						   const_ActivationFrame_spREF args,
 						   int& arg_idx,
-						   ActivationFrameDynamicScopeManager& scope,
-						   Environment_sp env)
+						   /*ActivationFrame*/DynamicScopeManager& scope
+						   /*,Environment_sp env*/)
     {_G();
 	int num_args = af_length(args);
 	// Fill required arguments
@@ -534,19 +580,7 @@
 		T_sp value = args->entry(arg_idx);
 		++arg_idx;
 		LOG(BF("Binding value[%s] to target[%s]") % value->__repr__() % (it->_ArgTarget)->__repr__() );
-		if ( it->_symbolP() )
-		{
-		    scope.new_binding(*it,value);
-		} else if ( it->_lambdaListHandlerP() )
-		{
-		    LambdaListHandler_sp llh = it->lambdaListHandler();
-		    Cons_sp cvalue = value.as_or_nil<Cons_O>();
-		    ValueFrame_sp subFrame(ValueFrame_O::create(cvalue,_Nil<ActivationFrame_O>()));
-		    llh->createBindingsInActivationFrame(subFrame,scope,env);
-		} else
-		{
-		    SIMPLE_ERROR(BF("Illegal target type for bind: %s") % it->asString() );
-		}
+		scope.new_binding(*it,value);
 		if ( it->_Sensor.isDefined() )
 		{
 		    scope.new_binding(it->_Sensor,_lisp->_true());
@@ -558,21 +592,9 @@
 		{
 		    T_sp init_form = it->_Default;
 		    LOG(BF("Init form: %s") % init_form->__repr__() );
-		    T_sp value = evaluate_lambda_list_form(init_form,env);
+		    T_sp value = evaluate_lambda_list_form(init_form,scope.lexenv()); // Was env
 		    LOG(BF("Binding value[%s] to target[%s]") % value->__repr__() % (it->_ArgTarget)->__repr__() );
-		    if ( it->_symbolP() )
-		    {
-			scope.new_binding(*it,value);
-		    } else if ( it->_lambdaListHandlerP() )
-		    {
-			LambdaListHandler_sp llh = it->lambdaListHandler();
-			Cons_sp cvalue = value.as_or_nil<Cons_O>();
-			ValueFrame_sp subFrame(ValueFrame_O::create(cvalue,_Nil<ActivationFrame_O>()));
-			llh->createBindingsInActivationFrame(subFrame,scope,env);
-		    } else
-		    {
-			SIMPLE_ERROR(BF("Illegal target type for bind: %s") % it->asString() );
-		    }
+		    scope.new_binding(*it,value);
 		    if ( it->_Sensor.isDefined() )
 		    {
 			scope.new_binding(it->_Sensor,_lisp->_false());
@@ -583,11 +605,37 @@
     }
 
 
+
+    int bind_rest_var( RestArgument const& restarg,
+		       const_ActivationFrame_spREF args,
+		       int arg_idx,
+		       /*ValueEnvironment*/DynamicScopeManager& scope)
+    {_G();
+	if ( restarg.isDefined() )
+	{
+#if VARARGS
+	    Cons_O::CdrType_sp rest = _Nil<Cons_O::CdrType_O>();
+	    Cons_O::CdrType_sp* cur = &rest;
+	    for ( int i(arg_idx); i<n_args; ++i ) {
+		T_sp obj = mem::smart_ptr<T_O>(va_arg(ap,TAGGED_PTR));
+		Cons_sp one = Cons_O::create(obj);
+		*cur = one;
+		cur = one->cdrPtr();
+	    }
+#else
+	    Cons_O::CdrType_sp rest = args->asCons(arg_idx);
+#endif
+	    scope.new_binding(restarg,rest);
+	}
+	return arg_idx;
+    }
+
+
     void fill_activation_frame_rest_argument( RestArgument const& restarg,
 					      const_ActivationFrame_spREF args,
 					      int& arg_idx,
-					      ActivationFrameDynamicScopeManager& scope,
-					      Environment_sp env)
+					      /*ActivationFrame*/DynamicScopeManager& scope
+					      /*,Environment_sp env*/)
     {_G();
 	if ( restarg.isDefined() )
 	{
@@ -599,126 +647,71 @@
     }
 
 
-	
 
 
 
-    int bind_rest_var( RestArgument const& restarg,
-		       const_ActivationFrame_spREF args,
-		       int arg_idx,
-		       ValueEnvironmentDynamicScopeManager& scope)
-    {_G();
-	if ( restarg.isDefined() )
-	{
-	    if ( restarg._symbolP() )
-	    {
-		scope.new_binding(restarg,args->asCons(arg_idx));
-	    } else
-	    {
-		SIMPLE_ERROR(BF("Illegal target for bind_rest_var[%s]") % restarg.asString() );
-	    }
-	}
-	return arg_idx;
-    }
 
-
     void bind_keyword_arguments(vector<KeywordArgument> const& keyed_args,
 				T_sp allow_other_keys,
 				const_ActivationFrame_spREF args,
 				int arg_idx,
-				ValueEnvironmentDynamicScopeManager& scope,
-				Environment_sp env)
+				/*ValueEnvironment*/DynamicScopeManager& scope
+				/*, Environment_sp env */)
     {_G();
 	int num_keyed_arguments = keyed_args.size();
 	if ( num_keyed_arguments == 0 ) return;
 	bool passed_allow_other_keys = false;
-	{_BLOCK_TRACE("Check if :allow-other-keywords was passed");
-	    for ( int i= arg_idx, iEnd(af_length(args)); i<iEnd; i++ )
-	    {
-		if ( args->entry(i) == kw::_sym_allow_other_keys )
-		{
-		    ASSERT((i+1)<iEnd);
-		    passed_allow_other_keys = args->entry(i+1).isTrue();
-		    break;
-		}
-	    }
-	}
+	bool sawkeys[CALL_ARGUMENTS_LIMIT];
+	memset(sawkeys,0,num_keyed_arguments);
 	LOG(BF(":allow-other-keywords --> %d") % passed_allow_other_keys );
-	bool bool_allow_other_keys = passed_allow_other_keys || allow_other_keys.isTrue();
+	T_sp first_illegal_keyword(_Nil<T_O>());
 	{_BLOCK_TRACEF(BF("Copy passed keyword values to environment"));
-	    for ( int i = arg_idx,iEnd(af_length(args)); i<iEnd; i += 2 )
+	    for ( int i(arg_idx),iEnd(af_length(args)); i<iEnd; i+=2 )
 	    {
-		if ( args->entry(i) != kw::_sym_allow_other_keys )
+		Symbol_sp keyword = args->entry(i).as<Symbol_O>();
+		T_sp value = args->entry(i+1);
+		if ( keyword != kw::_sym_allow_other_keys )
 		{
 		    LOG(BF("Binding passed keyword[%s] value[%s]")
-			% args->entry(i)->__repr__() % args->entry(i+1)->__repr__() );
+			% _rep_(keyword) % _rep_(value) );
 		    Cons_sp find_key;
-		    vector<KeywordArgument>::const_iterator fi=keyed_args.begin();
-		    for ( ; fi!=keyed_args.end(); fi++ )
-		    {
-			if ( fi->_Keyword == args->entry(i) )
-			{
-			    T_sp value = args->entry(i+1);
-			    if ( fi->_symbolP() )
-			    {
-				scope.new_binding(*fi,value);
-			    } else if ( fi->_lambdaListHandlerP() )
-			    {
-				ValueFrame_sp frame(ValueFrame_O::create(value.as_or_nil<Cons_O>(),_Nil<ActivationFrame_O>()));
-				fi->lambdaListHandler()->createBindingsInEnvironment(frame,scope,env);
-			    } else
-			    {
-				SIMPLE_ERROR(BF("Illegal target type for bind: %s") % fi->asString() );
-			    }
-			    if ( fi->_Sensor.isDefined() )
-			    {
-				scope.new_binding(fi->_Sensor,_lisp->_true());
-			    }
+		    vector<KeywordArgument>::const_iterator fi;
+		    int ik(0);
+		    for ( fi =keyed_args.begin(); fi!=keyed_args.end(); fi++ ) {
+			if ( fi->_Keyword == keyword ) {
+			    scope.new_binding(*fi,value);
+			    if ( fi->_Sensor.isDefined() ) scope.new_binding(fi->_Sensor,_lisp->_true());
+			    sawkeys[ik] = 1;
 			    break;
 			}
+			ik++;
 		    }
-		    if ( fi ==  keyed_args.end() )
-		    {
-			if ( !bool_allow_other_keys )
-			{
-			    UNRECOGNIZED_KEYWORD_ARGUMENTS_ERROR(args->entry(i));
-			}
-		    }
+		    if ( fi ==  keyed_args.end() && first_illegal_keyword.nilp() )
+			first_illegal_keyword = keyword;
+		} else {
+		    passed_allow_other_keys = value.isTrue();
 		}
 	    }
 	}
+	if ( first_illegal_keyword.notnilp() && !passed_allow_other_keys && allow_other_keys.nilp() ) {
+	    UNRECOGNIZED_KEYWORD_ARGUMENTS_ERROR(first_illegal_keyword);
+	}
 	// Now fill in the default values for the missing parameters
-	{_BLOCK_TRACEF(BF("Add missing keyword default init-form values to environment"));
+	{_BLOCK_TRACEF(BF("Add missing keyword default init-form values to ActivationFrame"));
 	    vector<KeywordArgument>::const_iterator fi;
+	    int ik(0);
 	    for ( fi = keyed_args.begin(); fi!=keyed_args.end(); fi++ )
 	    {
 		LOG(BF("Checking if keyword[%s] needs default value") % fi->_Keyword->__repr__() );
-		Cons_sp find_cur;
-		int f, fEnd;
-		    for ( f=arg_idx,fEnd=af_length(args); f<fEnd; f += 2)
-		{
-		    if ( args->entry(f) == fi->_Keyword ) break;
-		}
-		if ( f >= fEnd )
-		{
+		if ( sawkeys[ik] == 0 )  {
 		    T_sp expr = fi->_Default;
 		    T_sp value = evaluate_lambda_list_form(expr,scope.lexenv());
-		    if ( fi->_symbolP() )
-		    {
-			scope.new_binding(*fi,value);
-		    } else if ( fi->_lambdaListHandlerP() )
-		    {
-			ValueFrame_sp frame(ValueFrame_O::create(value.as_or_nil<Cons_O>(),_Nil<ActivationFrame_O>()));
-			fi->lambdaListHandler()->createBindingsInEnvironment(frame,scope,env);
-		    } else
-		    {
-			SIMPLE_ERROR(BF("Illegal target type for bind: %s") % fi->asString() );
-		    }
-		    if ( fi->_Sensor.isDefined() )
-		    {
+		    scope.new_binding(*fi,value);
+		    if ( fi->_Sensor.isDefined() ) {
 			scope.new_binding(fi->_Sensor,_lisp->_false());
 		    }
 		}
+		++ik;
 	    }
 	}
     }
@@ -739,26 +732,16 @@
     void fill_activation_frame_keyword_arguments(vector<KeywordArgument> const& keyed_args,
 						 T_sp allow_other_keys,
 						 const_ActivationFrame_spREF args, int& arg_idx,
-						 ActivationFrameDynamicScopeManager& scope,
-						 Environment_sp env)
+						 /*ActivationFrame*/DynamicScopeManager& scope
+						 /*,Environment_sp env*/)
     {_G();
 	int num_keyed_arguments = keyed_args.size();
 	if ( num_keyed_arguments == 0 ) return;
 	bool passed_allow_other_keys = false;
-	{_BLOCK_TRACE("Check if :allow-other-keywords was passed");
-	    for ( int i=arg_idx,iEnd(af_length(args)); i<iEnd; i += 2)
-	    {
-		Symbol_sp keyword = args->entry(i).as<Symbol_O>();
-		T_sp value = args->entry(i+1);
-		if ( keyword == kw::_sym_allow_other_keys )
-		{
-		    passed_allow_other_keys = value.isTrue();
-		    break;
-		}
-	    }
-	}
+	bool sawkeys[CALL_ARGUMENTS_LIMIT];
+	memset(sawkeys,0,num_keyed_arguments);
 	LOG(BF(":allow-other-keywords --> %d") % passed_allow_other_keys );
-	bool will_allow_other_keys = passed_allow_other_keys || allow_other_keys.isTrue();
+	T_sp first_illegal_keyword(_Nil<T_O>());
 	{_BLOCK_TRACEF(BF("Copy passed keyword values to the ActivationFrame"));
 	    for ( int i=arg_idx,iEnd(af_length(args)); i<iEnd; i += 2 )
 	    {
@@ -766,71 +749,45 @@
 		T_sp value = args->entry(i+1);
 		if ( keyword != kw::_sym_allow_other_keys )
 		{
-		    LOG(BF("Binding passed keyword[%s] value[%s]") % keyword->__repr__() % value->__repr__() );
+		    LOG(BF("Binding passed keyword[%s] value[%s]")
+			% keyword->__repr__() % value->__repr__() );
 		    vector<KeywordArgument>::const_iterator fi;
-		    for ( fi=keyed_args.begin(); fi!=keyed_args.end(); fi++ )
-		    {
-			if ( fi->_Keyword == keyword )
-			{
-			    if ( fi->_symbolP() )
-			    {
-				if ( !scope.lexicalElementBoundP(*fi) )
-				{	
-				    scope.new_binding(*fi,value);
-				}
-			    } else if ( fi->_lambdaListHandlerP() )
-			    {
-				LambdaListHandler_sp llh = fi->lambdaListHandler();
-				Cons_sp cvalue = value.as_or_nil<Cons_O>();
-				ValueFrame_sp subFrame(ValueFrame_O::create(cvalue,_Nil<ActivationFrame_O>()));
-				llh->createBindingsInActivationFrame(subFrame,scope,env);
-			    } else
-			    {
-				SIMPLE_ERROR(BF("Illegal target type for bind: %s") % fi->asString() );
-			    }
-			    if ( fi->_Sensor.isDefined() )
-			    {
-				scope.new_binding(fi->_Sensor,_lisp->_true());
-			    }
+		    int ik(0);
+		    for ( fi=keyed_args.begin(); fi!=keyed_args.end(); fi++ ) {
+			if ( fi->_Keyword == keyword ) {
+			    if ( !scope.lexicalElementBoundP(*fi) ) scope.new_binding(*fi,value);
+			    if ( fi->_Sensor.isDefined() ) scope.new_binding(fi->_Sensor,_lisp->_true());
+			    sawkeys[ik] = 1;
 			    break;
 			}
+			ik++;
 		    }
-		    if ( fi ==  keyed_args.end() && !will_allow_other_keys )
-		    {
-			INVALID_KEYWORD_ARGUMENT_ERROR(keyword);
-		    }
+		    if ( fi ==  keyed_args.end() && first_illegal_keyword.nilp())
+			first_illegal_keyword = keyword;
+		} else {
+		    passed_allow_other_keys = value.isTrue();
 		}
 	    }
 	}
+	if ( first_illegal_keyword.notnilp() && !passed_allow_other_keys && allow_other_keys.nilp() ) {
+	    UNRECOGNIZED_KEYWORD_ARGUMENTS_ERROR(first_illegal_keyword);
+	}
 	// Now fill in the default values for the missing parameters
 	{_BLOCK_TRACEF(BF("Add missing keyword default init-form values to ActivationFrame"));
 	    vector<KeywordArgument>::const_iterator fi;
-	    for ( fi = keyed_args.begin(); fi!=keyed_args.end(); fi++ )
-	    {
+	    int ik(0);
+	    for ( fi = keyed_args.begin(); fi!=keyed_args.end(); fi++ ) {
 		LOG(BF("Checking if keyword[%s] needs default value") % fi->_Keyword->__repr__() );
 		// If the value hasn't been filled in the ActivationFrame then fill it with a default value
-		if ( !scope.lexicalElementBoundP(*fi) )
-		{
+		if ( sawkeys[ik] == 0 ) { // !scope.lexicalElementBoundP(*fi) ) {
 		    T_sp expr = fi->_Default;
-		    T_sp value = evaluate_lambda_list_form(expr,env);
-		    if ( fi->_symbolP() )
-		    {
-			scope.new_binding(*fi,value);
-		    } else if ( fi->_lambdaListHandlerP() )
-		    {
-			LambdaListHandler_sp llh = fi->lambdaListHandler();
-			Cons_sp cvalue = value.as_or_nil<Cons_O>();
-			ValueFrame_sp subFrame(ValueFrame_O::create(cvalue,_Nil<ActivationFrame_O>()));
-			llh->createBindingsInActivationFrame(subFrame,scope,env);
-		    } else
-		    {
-			SIMPLE_ERROR(BF("Illegal target type for bind: %s") % fi->asString() );
-		    }
-		    if ( fi->_Sensor.isDefined() )
-		    {
+		    T_sp value = evaluate_lambda_list_form(expr,scope.lexenv()); // env); // env should be scope.lexenv()
+		    scope.new_binding(*fi,value);
+		    if ( fi->_Sensor.isDefined() ) {
 			scope.new_binding(fi->_Sensor,_lisp->_false());
 		    }
 		}
+		++ik;
 	    }
 	}
     }
@@ -840,7 +797,7 @@
 
 
 
-    void bind_aux(vector<AuxArgument> const& auxs, ValueEnvironmentDynamicScopeManager& scope )
+    void bind_aux(vector<AuxArgument> const& auxs, /*ValueEnvironment*/DynamicScopeManager& scope )
     {_G();
 	int num_auxs = auxs.size();
 	if ( num_auxs == 0 ) return;
@@ -866,12 +823,12 @@
 
 
     void fill_activation_frame_aux_arguments(vector<AuxArgument> const& auxs,
-					     ActivationFrameDynamicScopeManager& scope,
-					     Environment_sp env)
+					     /*ActivationFrame*/DynamicScopeManager& scope
+					     /*,Environment_sp env*/)
     {_G();
 	int num_auxs = auxs.size();
 	if ( num_auxs == 0 ) return;
-	LOG(BF("There are %d aux variables"));
+	LOG(BF("There are %d aux variables") % auxs.size() );
 	vector<AuxArgument>::const_iterator ci;
 	{_BLOCK_TRACE("Assigning aux variables");
 	    for ( ci = auxs.begin(); ci!=auxs.end(); ci++ )
@@ -879,7 +836,7 @@
 		T_sp expr = ci->_Expression;
 		if ( expr.notnilp() )
 		{
-		    T_sp value = evaluate_lambda_list_form(expr,env);
+		    T_sp value = evaluate_lambda_list_form(expr,scope.lexenv()); // env); // env should be scope.lexenv()
 		    scope.new_binding(*ci,value);
 		} else
 		{
@@ -888,12 +845,12 @@
 	    }
 	}
     }
+#endif // 0 OLD WORKING CODE
 
 
 
 
 
-
     string argument_mode_as_string(ArgumentMode mode)
     {
 	switch (mode)
@@ -1461,48 +1418,14 @@
 
 
 
-    void LambdaListHandler_O::createBindingsInEnvironment(const_ActivationFrame_spREF args, ValueEnvironmentDynamicScopeManager& scope, Environment_sp env)
-    {_OF();
-	if ( !this->_CreatesBindings ) return;
-	int args_idx = 0;
-	args_idx = bind_required_arguments(this->_RequiredArguments,args,args_idx,scope,env);
-	args_idx = bind_optional_arguments(this->_OptionalArguments,args,args_idx,scope,env);
-	if ( args_idx < af_length(args) && (!this->_RestArgument.isDefined()) && (this->_KeywordArguments.size() == 0))
-	{
-	    SIMPLE_ERROR(BF("There are unused arguments: %s") % _rep_(args->asCons(args_idx)) );
-	}
-	bind_rest_var(this->_RestArgument,args,args_idx,scope);
-	bind_keyword_arguments(this->_KeywordArguments,this->_AllowOtherKeys,args,args_idx,scope,env);
-// Why is bind_aux not using the closed over environment (env)?
-	// Instead it uses the one in scope!!!
-	bind_aux(this->_AuxArguments,scope); 
-    }
 
 
 
 
-    void LambdaListHandler_O::createBindingsInActivationFrame(const_ActivationFrame_spREF args, ActivationFrameDynamicScopeManager& scope, Environment_sp env) const
-    {_OF();
-	if ( !this->_CreatesBindings ) return;
-	int arg_idx = 0;
-	fill_activation_frame_required_arguments( this->_RequiredArguments, args, arg_idx, scope, env);
-	fill_activation_frame_optional_arguments( this->_OptionalArguments, args, arg_idx, scope,env);
-	if ( arg_idx < af_length(args) && (!this->_RestArgument.isDefined()) && (this->_KeywordArguments.size() == 0))
-	{
-	    TOO_MANY_ARGUMENTS_ERROR();
-	}
-	fill_activation_frame_rest_argument( this->_RestArgument, args, arg_idx, scope, env );
-	fill_activation_frame_keyword_arguments( this->_KeywordArguments, this->_AllowOtherKeys, args, arg_idx, scope,env );
-	fill_activation_frame_aux_arguments( this->_AuxArguments, scope, env);
-    }
 
 
 
 
-
-
-
-
     int LambdaListHandler_O::single_dispatch_on_argument(Symbol_sp target)
     {_G();
 	for ( vector<RequiredArgument>::iterator ri = this->_RequiredArguments.begin();
@@ -1676,7 +1599,7 @@
 	Cons_sp namesRev = _Nil<Cons_O>();
 	for ( Cons_sp cur=this->_ClassifiedSymbolList; cur.notnilp(); cur=cCdr(cur) )
 	{
-	    if ( oCar(oCar(cur)) == _sym_lexicalVar )
+	    if ( oCar(oCar(cur)) == ext::_sym_lexicalVar )
 	    {
 		namesRev = Cons_O::create(oCadr(oCar(cur)),namesRev,_lisp);
 	    }
Index: lambdaListHandler.h
===================================================================
--- lambdaListHandler.h	(revision 4737)
+++ lambdaListHandler.h	(working copy)
@@ -162,20 +162,15 @@
 	  context can be one of 'FUNCTION, 'MACRO and other values */
 	virtual void parse_lambda_list_declares(Cons_sp lambda_list, Cons_sp declares, T_sp context, TargetClassifier& classifier);
 
-	void createBindingsInEnvironment(const_ActivationFrame_spREF frame, ValueEnvironmentDynamicScopeManager& scope, Environment_sp env);
+	void createBindingsInScope_af(const_ActivationFrame_spREF args,
+				   DynamicScopeManager& scope );
+	void createBindingsInScope_argArray(int n_args, ArgArray argArray,
+				   DynamicScopeManager& scope );
 
-	void createBindingsInActivationFrame(const_ActivationFrame_spREF args, ActivationFrameDynamicScopeManager& scope, Environment_sp env) const;
-
-
 	/*! Return a list of expressions that can be evaluated in (env) to generate a list of values that would
 	  be put into the classifiedSymbols */
 	Cons_sp lambdaListParts(Environment_sp env);
 
-	T_mv createBindingExpressions(Environment_sp env);
-
-
-
-
 	// ---------
 	// Following are the methods that deal with preparing Lexical ActivationFrames for arguments
 
Index: lisp.cc
===================================================================
--- lisp.cc	(revision 4738)
+++ lisp.cc	(working copy)
@@ -8,6 +8,7 @@
 #include <stdlib.h>
 
 #include "boost/filesystem.hpp"
+#include "boost/algorithm/string.hpp"
 #include "boost/program_options.hpp"
 //#i n c l u d e	"boost/fstream.hpp"
 #include "foundation.h"
@@ -105,10 +106,7 @@
 extern "C" void add_history(char* line);
 #endif
 
-#define ARGS_empty ""
-#define DOCS_empty ""
 
-
 namespace core 
 {
 
@@ -243,7 +241,7 @@
 	this->_GlobalInitializationCallbacks.clear();
 	this->_MakePackageCallback = NULL;
 	this->_ExportSymbolCallback = NULL;
-#if CLOS
+#ifdef CLOS
 	this->_Roots._SlotCachePtr = NULL;
 	this->_Roots._MethodCachePtr = NULL;
 #endif
@@ -402,9 +400,6 @@
 
 	this->_Mode = FLAG_EXECUTE;
 
-	// Print info at startup
-	print_startup_info();
-
 	::_lisp = this; // this->sharedThis<Lisp_O>();
 	
 //	initializeProfiler(this->profiler(),_lisp);
@@ -436,7 +431,7 @@
 	}
 	{ _BLOCK_TRACE("Initialize special forms and macros");
 	    this->_EnvironmentInitialized = true;
-	    eval::defineSpecialFormsAndMacros(this->_Roots._CorePackage);
+	    eval::defineSpecialOperatorsAndMacros(this->_Roots._CorePackage);
 //	    this->createHiddenBinder();
 	}
 	this->_BuiltInClassesInitialized = true;
@@ -489,7 +484,6 @@
 	    initialize_num_co();
 	    initialize_float_to_digits();
 
-
 	    // initialize math routines - all are initialized in initialize_numbers
 	    initialize_numbers();
 
@@ -497,7 +491,7 @@
 
 
 	    ext::initialize_extension_functions();
-#if CLOS
+#ifdef CLOS
 	    initialize_genericFunction();
 #endif
 	    initialize_conditions();
@@ -507,9 +501,9 @@
 //	    initializeCandoClos(_lisp);
 	}
 	{
-	    // setup pathname translations
+	    // setup the SYS logical-pathname-translation
 	    Cons_sp pts = Cons_O::createList(
-		Cons_O::createList(Str_O::create("sys:lisp;**;*.*"), bundle->getSysPathname())
+		Cons_O::createList(Str_O::create("sys:**;*.*"), bundle->getSysPathname())
 		/* ,  more here */
 		);
 	    af_pathnameTranslations(Str_O::create("sys"),pts);
@@ -556,8 +550,8 @@
 	    this->_Roots._RehashThreshold = DoubleFloat_O::create(0.9);
 	    this->_Roots._ImaginaryUnit = Complex_O::create(0.0,1.0);
 	    this->_Roots._ImaginaryUnitNegative = Complex_O::create(0.0,-1.0);
-	    this->_Roots._PlusHalf = Ratio_O::create(1,2);
-	    this->_Roots._MinusHalf = Ratio_O::create(-1,2);
+	    this->_Roots._PlusHalf = Ratio_O::create(Fixnum_O::create(1),Fixnum_O::create(2));
+	    this->_Roots._MinusHalf = Ratio_O::create(Fixnum_O::create(-1),Fixnum_O::create(2));
 	    this->_Roots._SingleFloatOne = SingleFloat_O::create(1.0);
 	    this->_Roots._DoubleFloatOne = DoubleFloat_O::create(1.0);
 	    this->_Roots._SingleFloatMinusZero = SingleFloat_O::create(-0.0);
@@ -794,11 +788,11 @@
     }
 #endif
 
-    Symbol_sp Lisp_O::defineSpecialForm(const string& rawFormName, SpecialFormCallback cb, const string& argstring, const string& docstring )
+    Symbol_sp Lisp_O::defineSpecialOperator(const string& packageName, const string& rawFormName, SpecialFormCallback cb, const string& argstring, const string& docstring )
     {_OF();
 	string formName = lispify_symbol_name(rawFormName);
-	Symbol_sp sym = _lisp->intern(formName)->exportYourself();
-	SpecialForm_sp special = SpecialForm_O::create(sym,cb,_lisp);
+	Symbol_sp sym = _lisp->internWithPackageName(packageName,formName)->exportYourself();
+	SpecialForm_sp special = SpecialForm_O::create(sym,cb);
 	ASSERTP(this->_Roots._SpecialForms.count(sym)==0,"You cant define a special form with the symbol("+formName+") it has already been defined");
 	this->_Roots._SpecialForms[sym] = special;
 	return sym;
@@ -920,10 +914,35 @@
 	{
 	    cc->addInstanceBaseClass(base3ClassSymbol);
 	}
+	ASSERTF(alloc!=NULL,BF("instance_newNil_callback for %s is NULL!!!") % _rep_(classSymbol) );
 	cc->setInstance_newNil_callback(alloc);
     }
 
 
+
+
+/*! Add the class with (className) to the current package
+ */
+    void Lisp_O::addClass(Symbol_sp classSymbol )
+    {_G();
+	printf("%s:%d:%s  Adding class with symbol %s -- It will have a NULL instance_newNil_callback unless we initialize it properly\n", __FILE__,__LINE__,__FUNCTION__,_rep_(classSymbol).c_str() );
+	LOG(BF("Lisp_O::addClass classSymbol(%s)") % _rep_(classSymbol) );
+	ASSERTP(BuiltInClass_O::static_classSymbol(),
+		"You cannot create a BuiltInClass before the BuiltInClass is defined");
+	Class_sp cc;
+	if ( classSymbol == StandardObject_O::static_classSymbol() )
+	{
+	    IMPLEMENT_ME(); // WHEN DO StandardClasses get created with addClass?????
+	} else {
+	    LOG(BF("Adding BuiltInClass with classSymbol(%d)") % classSymbol );
+	    cc = BuiltInClass_O::create(classSymbol,_lisp);
+	}
+	printf("%s:%d --> Adding class[%s]\n", __FILE__, __LINE__, _rep_(classSymbol).c_str() );
+	af_setf_findClass(cc,classSymbol,true,_Nil<Environment_O>());
+	cc->setInstance_newNil_callback(NULL);
+    }
+
+
     StringSet_sp Lisp_O::allClassNames()
     {_G();
 	DEPRECIATED();
@@ -956,9 +975,12 @@
     }
 	
 
-    Package_sp Lisp_O::makePackage(const string& name,list<string> const& nicknames, list<Package_sp> const& usePackages)
+    Package_sp Lisp_O::makePackage(const string& name,list<string> const& nicknames, list<string> const& usePackages)
     {_G();
-	ASSERTP(this->_PackageNameIndexMap.count(name) == 0,"There already exists a package with name: "+name);
+	map<string,int>::iterator it = this->_PackageNameIndexMap.find(name);
+	if ( it != this->_PackageNameIndexMap.end() ) {
+	    SIMPLE_ERROR(BF("There already exists a package with name: %s") % name);
+	}
 	LOG(BF("Creating package with name[%s]") % name);
 	Package_sp newPackage = Package_O::create(name);
 	int packageIndex = this->_Roots._Packages.size();
@@ -977,9 +999,12 @@
 	    this->_PackageNameIndexMap[nickName] = packageIndex;
 	}
 
-	for ( list<Package_sp>::const_iterator jit=usePackages.begin(); jit!=usePackages.end(); jit++ )
+	for ( list<string>::const_iterator jit=usePackages.begin(); jit!=usePackages.end(); jit++ )
 	{
-	    Package_sp usePkg = *jit;
+	    Package_sp usePkg = this->findPackage(*jit);
+	    if ( usePkg.nilp() ) {
+		SIMPLE_ERROR(BF("Could not find package %s to use") % (*jit) );
+	    }
 	    LOG(BF("Using package[%s]") % usePkg->getName() );
 	    newPackage->usePackage(usePkg);
 	}
@@ -1140,20 +1165,40 @@
 	{
 	    features = Cons_O::create(_lisp->internKeyword(lispify_symbol_name(options._Features[i])),features,_lisp);
 	}
+#ifdef VARARGS
+	features = Cons_O::create(_lisp->internKeyword("VARARGS"),features);
+#endif
+#ifdef POLYMORPHIC_SMART_PTR
+	features = Cons_O::create(_lisp->internKeyword("POLYMORPHIC-SMART-PTR"),features);
+#endif
 	cl::_sym_STARfeaturesSTAR->setf_symbolValue(features);
-	
+
+	SYMBOL_EXPORT_SC_(CorePkg,STARprintVersionOnStartupSTAR);
+	_sym_STARprintVersionOnStartupSTAR->defparameter(_lisp->_boolean(options._Version));
+	SYMBOL_EXPORT_SC_(CorePkg,STARsilentStartupSTAR);
+	_sym_STARsilentStartupSTAR->defparameter(_lisp->_boolean(options._SilentStartup));
     
 //	this->_FunctionName = execName;
-	this->_RCFileName = "sys:lisp;" KERNEL_NAME ";init.lsp";
+	this->_RCFileName = "sys:" KERNEL_NAME ";init.lsp";
 
 	if ( options._IgnoreInitImage ) {
 	    SYMBOL_EXPORT_SC_(KeywordPkg,ignoreInitImage);
 	    Cons_sp features = cl::_sym_STARfeaturesSTAR->symbolValue().as_or_nil<Cons_O>();
-	    features = Cons_O::create(kw::_sym_ignoreInitImage,features,_lisp);
+	    features = Cons_O::create(kw::_sym_ignoreInitImage,features);
 	    cl::_sym_STARfeaturesSTAR->setf_symbolValue(features);
 	}
 
-	this->_Interactive = options._Interactive;
+	if ( options._LoadFile != "" ) {
+	    _sym_STARcommandLineLoadSTAR->defparameter(Str_O::create(options._LoadFile));
+	    this->_Interactive = false;
+	} else {
+	    this->_Interactive = true;
+	    if ( this->_Interactive ) {
+		Cons_sp features = cl::_sym_STARfeaturesSTAR->symbolValue().as_or_nil<Cons_O>();
+		features = Cons_O::create(KW("interactive"),features);
+		cl::_sym_STARfeaturesSTAR->setf_symbolValue(features);
+	    }
+	}
 	this->_dont_load_startup = options._DontLoadInit;
 
 	if (options._GotRandomNumberSeed)
@@ -1344,6 +1389,19 @@
 
 
 
+
+    
+    
+#define ARGS_af_lowLevelRepl "()"
+#define DECL_af_lowLevelRepl ""
+#define DOCS_af_lowLevelRepl "lowLevelRepl - this is a built in repl for when the top-level repl isn't available"
+    void af_lowLevelRepl()
+    {_G();
+	_lisp->readEvalPrintInteractive();
+    };
+
+
+
     void Lisp_O::readEvalPrintInteractive()
     {_OF();
 	Cons_sp expression;
@@ -1460,8 +1518,16 @@
 	throw(ExitProgram(exitValue));
     };
 
+#define ARGS_af_quit "(&optional (exit-value 0))"
+#define DECL_af_quit ""
+#define DOCS_af_quit "quit"
+    void af_quit(int exitValue)
+    {_G();
+	throw(ExitProgram(exitValue));
+    };
 
 
+
     
     
 
@@ -1494,10 +1560,14 @@
 #define ARGS_af_member "(item list &key key test test-not)"
 #define	DECL_af_member	""
 #define	DOCS_af_member	"See CLHS member"
-    Cons_sp af_member(T_sp item, Cons_sp list, T_sp key, T_sp test, T_sp test_not)
+    Cons_sp af_member(T_sp item, T_sp tlist, T_sp key, T_sp test, T_sp test_not)
     {_G();
-	if ( list.nilp() ) return list;
-	return(list->member(item,key,test,test_not));
+	if ( tlist.nilp() ) return _Nil<Cons_O>();
+	if ( Cons_sp list = tlist.asOrNull<Cons_O>() ) {
+	    return(list->member(item,key,test,test_not));
+	}
+	WRONG_TYPE_NTH_ARG(2,tlist,cl::_sym_List_O);
+	UNREACHABLE();
     }
 
 #define ARGS_af_memberTest "(item list &key key test test-not)"
@@ -1932,7 +2002,7 @@
 
 
 
-#define ARGS_af_mpi_enabled ""
+#define ARGS_af_mpi_enabled "()"
 #define DECL_af_mpi_enabled ""
 #define DOCS_af_mpi_enabled "mpi_enabled"
     T_mv af_mpi_enabled()
@@ -1948,7 +2018,7 @@
   Return the mpi rank or 0 if not enabled.
   __END_DOC
 */
-#define ARGS_af_mpi_rank ""
+#define ARGS_af_mpi_rank "()"
 #define DECL_af_mpi_rank ""
 #define DOCS_af_mpi_rank "Return the mpi_rank or 0 if mpi is disabled"
     T_mv af_mpi_rank()
@@ -1967,7 +2037,7 @@
 
 
 
-#define ARGS_af_mpi_size ""
+#define ARGS_af_mpi_size "()"
 #define DECL_af_mpi_size ""
 #define DOCS_af_mpi_size "Return mpi_size or 0 if mpi is not enabled"
     T_mv af_mpi_size()
@@ -2014,10 +2084,11 @@
 	if ( expansionFunction.notnilp() )
 	{
 	    T_sp macroexpandHook = cl::_sym_STARmacroexpand_hookSTAR->symbolValue();
-	    Function_sp hookFunc = coerce::functionDesignator(macroexpandHook,_lisp);
-	    ValueFrame_sp macroHookArgs(ValueFrame_O::create_fill(expansionFunction,form,env,_Nil<ActivationFrame_O>()));
-	    MacroExpansionIHF _frame(_lisp->invocationHistoryStack(),hookFunc,macroHookArgs);
-	    T_sp expanded = eval::applyFunctionToActivationFrame(hookFunc,macroHookArgs);
+	    Function_sp hookFunc = coerce::functionDesignator(macroexpandHook);
+	    T_sp macroHookArgs[3] = { expansionFunction, form, env };
+//	    ValueFrame_sp macroHookArgs(ValueFrame_O::create_fill(expansionFunction,form,env,_Nil<ActivationFrame_O>()));
+	    MacroExpansionIHF _frame(_lisp->invocationHistoryStack(),hookFunc);
+	    T_sp expanded = hookFunc->INVOKE(3, macroHookArgs); // eval::applyFunctionToActivationFrame(hookFunc,macroHookArgs);
 	    _lisp->sourceManager()->duplicateSourceInfoForMacroExpansion(form,expansionFunction,expanded);
 	    return(Values(expanded,_lisp->_true()) );
 	}
@@ -2180,11 +2251,11 @@
 #define DOCS_af_funcall "See CLHS: funcall"
     T_mv af_funcall(T_sp function_desig, Cons_sp args)
     {_G();
-	Function_sp func = coerce::functionDesignator(function_desig,_lisp);
+	Function_sp func = coerce::functionDesignator(function_desig);
 	ASSERTF(func.pointerp(),BF("funcall target[%s] is undefined") % _rep_(function_desig) );
 	Cons_sp passArgs = args;
 	ValueFrame_sp frame(ValueFrame_O::create(passArgs,_Nil<ActivationFrame_O>()));
-	return eval::applyFunctionToActivationFrame(func,frame);
+	return func->INVOKE(frame->length(),frame->argArray());//return eval::applyFunctionToActivationFrame(func,frame);
     }
 
 
@@ -2210,10 +2281,10 @@
 	   APPLY directly to that ActivationFrame */
 	if ( oCar(args).notnilp() && cCdr(args).nilp() )
 	{
-	    Function_sp func = coerce::functionDesignator(head,_lisp);
+	    Function_sp func = coerce::functionDesignator(head);
 	    if ( ActivationFrame_sp singleFrame = oCar(args).asOrNull<ActivationFrame_O>() )
 	    {
-		return eval::applyFunctionToActivationFrame(func,singleFrame);
+		return func->INVOKE(singleFrame->length(),singleFrame->argArray()); // return eval::applyFunctionToActivationFrame(func,singleFrame);
 	    }
 	}
 	ql::list largs(_lisp);
@@ -2225,8 +2296,8 @@
 	largs.dot(oCar(cur));
 	Cons_sp pass_args = largs.cons();
 	ValueFrame_sp frame(ValueFrame_O::create(pass_args,_Nil<ActivationFrame_O>()));
-	Function_sp func = coerce::functionDesignator(head,_lisp);
-	return eval::applyFunctionToActivationFrame(func,frame);
+	Function_sp func = coerce::functionDesignator(head);
+	return func->INVOKE(frame->length(),frame->argArray()); // return eval::applyFunctionToActivationFrame(func,frame);
     }
 
 
@@ -2301,8 +2372,7 @@
 	}
 	bool operator()(T_sp x, T_sp y )
 	{
-	    ValueFrame_sp frame(ValueFrame_O::create_fill(x,y,_Nil<ActivationFrame_O>()));
-	    return eval::apply(this->_SortFunction,frame);
+	    return eval::funcall(this->_SortFunction,x,y);
 	}
     };
 
@@ -2325,7 +2395,7 @@
 		return MPS_RES_OK;
 	    };
 	} Frame;
-	Function_sp sortProc = coerce::functionDesignator(predicate,_lisp);
+	Function_sp sortProc = coerce::functionDesignator(predicate);
 	LOG(BF("Unsorted data: %s") % _rep_(sequence) );
 	if ( af_length(sequence) == 0 ) return(Values(_Nil<Cons_O>()));
 	Frame.sorted.fillFromCons(sequence);
@@ -2351,7 +2421,7 @@
     
     
     
-#define ARGS_af_sourceFileName ""
+#define ARGS_af_sourceFileName "()"
 #define DECL_af_sourceFileName ""
 #define DOCS_af_sourceFileName "Return the current sourceFileName"
     T_mv af_sourceFileName()
@@ -2365,7 +2435,7 @@
     }
 
     
-#define ARGS_af_sourceLineColumn ""
+#define ARGS_af_sourceLineColumn "()"
 #define DECL_af_sourceLineColumn ""
 #define DOCS_af_sourceLineColumn "sourceLineColumn"
     T_mv af_sourceLineColumn()
@@ -2400,7 +2470,7 @@
 
 
 
-#define ARGS_af_script_dir ""
+#define ARGS_af_script_dir "()"
 #define DECL_af_script_dir ""
 #define DOCS_af_script_dir "script_dir"
     Path_mv af_script_dir()
@@ -2453,7 +2523,7 @@
 
 
 
-#define ARGS_af_database_dir ""
+#define ARGS_af_database_dir "()"
 #define DECL_af_database_dir ""
 #define DOCS_af_database_dir "database_dir"
     Path_mv af_database_dir()
@@ -2497,7 +2567,7 @@
     
     
     
-#define ARGS_af_isTopLevelScript ""
+#define ARGS_af_isTopLevelScript "()"
 #define DECL_af_isTopLevelScript ""
 #define DOCS_af_isTopLevelScript "isTopLevelScript"
     T_mv af_isTopLevelScript()
@@ -2522,7 +2592,7 @@
     
     
     
-#define ARGS_af_debugLogOn ""
+#define ARGS_af_debugLogOn "()"
 #define DECL_af_debugLogOn ""
 #define DOCS_af_debugLogOn "debugLogOn"
     void af_debugLogOn()
@@ -2543,7 +2613,7 @@
     
     
     
-#define ARGS_af_debugLogOff ""
+#define ARGS_af_debugLogOff "()"
 #define DECL_af_debugLogOff ""
 #define DOCS_af_debugLogOff "debugLogOff"
     void af_debugLogOff()
@@ -2615,10 +2685,15 @@
 #define DOCS_af_universalErrorHandler "universalErrorHandler"
     T_mv af_universalErrorHandler(T_sp continueString, T_sp datum, Cons_sp initializers)
     {_G();
-	stringstream ss;
-	ss << "Low level universalErrorHandler datum: " << _rep_(datum) << " " << _rep_(initializers);
-	printf("%s:%d %s\n", __FILE__, __LINE__, ss.str().c_str() );
-	dbg_hook(ss.str().c_str());
+	printf("%s:%d \n", __FILE__, __LINE__);
+	if ( af_stringP(datum) ) {
+	    af_format(_lisp->_true(),datum,initializers);
+	} else {
+	    stringstream ss;
+	    ss << "datum: " << _rep_(datum) << " " << _rep_(initializers);
+	    printf("%s\n", ss.str().c_str() );
+	}
+	dbg_hook("universalErrorHandler");
 	af_invokeInternalDebugger(_Nil<T_O>());
 	exit(1);
     };
@@ -2999,7 +3074,7 @@
     }
 
 
-#define ARGS_Lisp_O_forget_all_single_dispatch_generic_functions ""
+#define ARGS_Lisp_O_forget_all_single_dispatch_generic_functions "()"
 #define DECL_Lisp_O_forget_all_single_dispatch_generic_functions ""
 #define DOCS_Lisp_O_forget_all_single_dispatch_generic_functions "Forget all single dispatch functions"
     void Lisp_O::forget_all_single_dispatch_generic_functions()
@@ -3038,7 +3113,7 @@
 	  
 
 
-
+#if 0
     Class_sp Lisp_O::classFromClassSymbol(Symbol_sp cid) const
     {_G();
 	DEPRECIATED();
@@ -3046,7 +3121,10 @@
 	return this->findClass(cid,true);
 #endif
     }
+#endif
 
+
+
     string Lisp_O::classNameFromClassSymbol(Symbol_sp cid)
     {
 	DEPRECIATED();
@@ -3206,6 +3284,7 @@
 	{
 	    SIMPLE_ERROR(BF("You cannot intern[%s] as a keyword - it has package designating ':' characters in it at pos[%d]") % realName % colonPos);
 	}
+	boost::to_upper(realName);
 	return this->_Roots._KeywordPackage->intern(realName).as<Symbol_O>();
     }
 
@@ -3266,15 +3345,15 @@
 
 
 
-
+#if 0
     bool Lisp_O::subClassOrder(Symbol_sp classSymbol1, Symbol_sp classSymbol2 )
     {_OF();
 	Class_sp mc1 = this->classFromClassSymbol(classSymbol1);
 	Class_sp mc2 = this->classFromClassSymbol(classSymbol2);
 	return mc2->isSubClassOf(mc1);
     }
+#endif
 
-
     void Lisp_O::dump_apropos(const char* part) const
     {_OF();
 	string substring = part;
@@ -3411,40 +3490,23 @@
 		Pathname_sp initPathname = af_pathname(Str_O::create(this->_RCFileName));
 		af_load(initPathname);
 	    }
-	    if ( !this->_ScriptInFile
-		 && this->_FileNameOrCode != "" )
-	    {
-		LOG(BF("Compiling script in string: %s")% this->_FileNameOrCode);
-		StringInputStream_sp sin = StringInputStream_O::create(this->_FileNameOrCode);
-		af_load(sin);
-	    } else
-	    {
-		string& scriptFileName = this->_FileNameOrCode;
-		if ( scriptFileName != "" )
-		{
-		    Pathname_sp loadPathname = af_pathname(Str_O::create(scriptFileName));
-		    af_load(loadPathname);
-		} else
-		{
-		    LOG(BF("this->_FileNameOrCode is empty"));
+	} else {
+	    // Assume that if there is no program then
+	    // we want an interactive script
+	    //
+//	    if ( this->_Interactive )
+	    {_BLOCK_TRACE("Interactive REPL");
+		//
+		// Implement a Read-Eval-Print-Loop
+		//
+		this->print(BF("BRIDGE-COMMON-LISP (copyright Christian E. Schafmeister 2013) - 1.0\n"));
+		this->print(BF("Built in top level shell\n"));
+		while ( 1 ) {
+		    this->readEvalPrintInteractive();
 		}
 	    }
+	    LOG(BF("Leaving lisp run"));
 	}
-	//
-	// Assume that if there is no program then
-	// we want an interactive script
-	//
-	if ( this->_Interactive )
-	{_BLOCK_TRACE("Interactive REPL");
-	    //
-	    // Implement a Read-Eval-Print-Loop
-	    //
-	    this->print(BF("BRIDGE-COMMON-LISP (copyright Christian E. Schafmeister 2013) - 1.0\n"));
-	    while ( 1 ) {
-		  this->readEvalPrintInteractive();
-	    }
-	}
-	LOG(BF("Leaving lisp run"));
     };
 
 
@@ -3525,6 +3587,7 @@
 
 	SYMBOL_SC_(CorePkg,stackMonitor);
 	Defun(stackMonitor);
+	Defun(lowLevelRepl);
 	SYMBOL_SC_(CorePkg,setupStackMonitor);
 	Defun(setupStackMonitor);
 
@@ -3541,6 +3604,8 @@
 
 	SYMBOL_SC_(CorePkg,exit);
 	Defun(exit);
+	SYMBOL_SC_(CorePkg,quit);
+	Defun(quit);
 #if defined(XML_ARCHIVE)
 	SYMBOL_SC_(CorePkg,saveArchive);
 	Defun(saveArchive);
@@ -3715,7 +3780,7 @@
 #if 0
 //	boost::python::def_raw(CorePkg,"export",&prim_export,ARGS_empty,DOCS_empty,_LISP);
 //	boost::python::def_raw(CorePkg,"apply", &prim_apply,ARGS_empty,DOCS_empty,_LISP);
-	boost::python::def_raw(CorePkg,"testomp", &prim_testomp,ARGS_empty,DOCS_empty,_LISP);
+//	boost::python::def_raw(CorePkg,"testomp", &prim_testomp,ARGS_empty,DOCS_empty,_LISP);
 	boost::python::def_raw(CorePkg,"isTopLevelScript", &prim_isTopLevelScript ,ARGS_empty,DOCS_empty,_LISP);
 //	boost::python::def_raw(CorePkg,"allGlobalNames", &prim_allGlobalNames ,ARGS_empty,DOCS_empty,_LISP);
 //	boost::python::def_raw(CorePkg,"locals", &prim_locals,ARGS_empty,DOCS_empty,_LISP);
@@ -3869,7 +3934,7 @@
 	    {
 		lnnames.push_front(nicknames[i]);
 	    }
-	    list<Package_sp> lp;
+	    list<string> lp;
 	    this->_Package = lisp->makePackage(packageName,lnnames,lp);
 	} else
 	{
@@ -3884,7 +3949,7 @@
 	if ( !lisp->recognizesPackage(packageName) )
 	{	
 	    list<string> lnnames;
-	    list<Package_sp> lpkgs;
+	    list<string> lpkgs;
 	    this->_Package = lisp->makePackage(packageName,lnnames,lpkgs);
 	} else
 	{
Index: lisp.h
===================================================================
--- lisp.h	(revision 4737)
+++ lisp.h	(working copy)
@@ -35,7 +35,11 @@
 //#i n c l u d e "lispDefinitions.h"
 
 
+namespace cl {
+    extern core::Symbol_sp 	_sym_eq;
+};
 
+
 namespace core 
 {
 
@@ -56,12 +60,7 @@
     SMART(Hierarchy);
     SMART(Environment);
 
-    SMART(Mpi);
-
-
-
-
-    Cons_sp af_member(T_sp item, Cons_sp list, T_sp key, T_sp test, T_sp test_not);
+    Cons_sp af_member(T_sp item, T_sp list, T_sp key=_Nil<T_O>(), T_sp test=cl::_sym_eq, T_sp test_not=_Nil<T_O>());
     void af_invokeInternalDebugger(T_sp condition);
 
 
@@ -637,7 +636,7 @@
 	void switchToClassNameHashTable();
 
 
-	Class_sp classFromClassSymbol(Symbol_sp cid) const;
+//	Class_sp classFromClassSymbol(Symbol_sp cid) const;
 	Class_sp classFromClassName(const string& name);
 	string classNameFromClassSymbol(Symbol_sp cid);
     public:
@@ -664,7 +663,7 @@
 	T_sp error(const boost::format& fmt);
 
     public:	// Functions for manipulating special forms
-	Symbol_sp defineSpecialForm(const string& formName, SpecialFormCallback cb, const string& args = "", const string& docstring = "");
+	Symbol_sp defineSpecialOperator(const string& package, const string& formName, SpecialFormCallback cb, const string& args = "", const string& docstring = "");
 	SpecialForm_sp specialFormOrNil(Symbol_sp sym);
     public:
 	bool recognizesModule(const string& fileName);
@@ -771,14 +770,14 @@
 
 	/*! Return true if classSymbol is the id for a class that has the baseClassSymbol
 	 */
-	bool subClassOrder(Symbol_sp baseClassSymbol,Symbol_sp classSymbol);
+//	bool subClassOrder(Symbol_sp baseClassSymbol,Symbol_sp classSymbol);
 
 	bool recognizesPackage(const string& packageName) const;
 	Package_sp findPackage(const string& packageName) const;
 	void inPackage(const string& packageName);
 	void selectPackage(Package_sp pack);
 	Package_sp getCurrentPackage() const;
-	Package_sp makePackage(const string& packageName, list<string> const& nicknames, list<Package_sp> const& usePackages);
+	Package_sp makePackage(const string& packageName, list<string> const& nicknames, list<string> const& usePackages);
 	bool usePackage(const string& packageName);
 
 	Cons_sp	getBackTrace() const;
@@ -843,6 +842,7 @@
 
 	void addClassNameToPackageAsDynamic(const string& package, const string& name, Class_sp cl);
 	void addClass( Symbol_sp classSymbol, AllocatorFunctor* alloc, Symbol_sp base1ClassSymbol, Symbol_sp base2ClassSymbol = UNDEFINED_SYMBOL, Symbol_sp base3ClassSymbol = UNDEFINED_SYMBOL );
+	void addClass( Symbol_sp classSymbol);
 
 	string __repr__() const ;
 
@@ -930,6 +930,8 @@
     T_mv af_macroexpand_1(T_sp form, Environment_sp env);
     T_mv af_macroexpand(T_sp form, Environment_sp env);
 
+    Cons_sp af_assoc(T_sp item, Cons_sp alist, T_sp key, T_sp test=cl::_sym_eq, T_sp test_not=_Nil<T_O>());
+
     Class_mv af_findClass(Symbol_sp symbol, bool errorp=true, Environment_sp env=_Nil<Environment_O>());
     Class_mv af_setf_findClass(T_sp newValue, Symbol_sp name, bool errorp, Environment_sp env );
 
Index: lispReader.cc
===================================================================
--- lispReader.cc	(revision 4739)
+++ lispReader.cc	(working copy)
@@ -4,6 +4,7 @@
 #include <string>
 #include "core/common.h"
 #include "core/corePackage.h"
+#include "core/pathname.h"
 #include "character.h"
 #include "symbolTable.h"
 #include "numbers.h"
@@ -44,8 +45,11 @@
 #define TRAIT_MATCH_EQ(x,t)
 
 
-
+#if 1
+#define TRAP_BAD_CONS(x)
+#else
 #define TRAP_BAD_CONS(x) {if (af_consP(x)) {LOG(BF("About to try trap bad cons"));string ssss=af_sourceFileInfo(x.as_or_nil<Cons_O>())->fileName();}}
+#endif
 
     /*! Return a uint that combines the character x with its character TRAITs
       See CLHS 2.1.4.2 */
@@ -465,11 +469,11 @@
 	    T_sp obj;
 	    T_mv mv = lisp_object_query(sin,true,_Nil<T_O>(),true);
 	    ivalues = mv.number_of_values();
-	    obj = mv;
-	    LOG(BF("lisp_object_query: %s") % _rep_(obj) );
-	    // Could get ending lineNumber and column here
 	    if ( ivalues > 0 )
 	    {
+		obj = mv;
+		LOG(BF("lisp_object_query: %s") % _rep_(obj) );
+		// Could get ending lineNumber and column here
 		if ( obj == _sym_dot )
 		{
 		    if ( allow_consing_dot )
@@ -517,14 +521,11 @@
 	{
 	    while (1)
 	    {
-		int ivalues;
-		{MULTIPLE_VALUES_CONTEXT();
-		    const T_mv& mv = lisp_object_query(sin,eofErrorP,eofValue,recursiveP);
-		    ivalues = mv.number_of_values();
-		    result = mv;
-		}
+		T_mv mv = lisp_object_query(sin,eofErrorP,eofValue,recursiveP);
+		int ivalues = mv.number_of_values();
 		if ( ivalues> 0 )
 		{
+		    result = mv;
 		    if (cl::_sym_STARread_suppressSTAR->symbolValue().isTrue() )
 		    {
 			LOG(BF("read_suppress == true"));
@@ -554,6 +555,13 @@
       Return the result in a MultipleValues object - if it is empty then nothing was read */
     T_mv lisp_object_query(Stream_sp sin, bool eofErrorP, T_sp eofValue, bool recursiveP)
     {_G();
+#if 1	
+	static int monitorReaderStep = 0;
+	if ( (monitorReaderStep % 1000 ) == 0 && af_member(_sym_monitorReader,_sym_STARdebugMonitorSTAR->symbolValue(),_Nil<T_O>()).notnilp()) {
+	    printf("%s:%d:%s stream %s -> pos = %lld\n",__FILE__,__LINE__,__FUNCTION__, _rep_(sin->pathname()).c_str(),sin->tell());
+	}
+	++monitorReaderStep;
+#endif
 	string chars;
 	vector<uint> token;
 	ReadTable_sp readTable = _lisp->getCurrentReadTable();
Index: lispStream.cc
===================================================================
--- lispStream.cc	(revision 4738)
+++ lispStream.cc	(working copy)
@@ -12,6 +12,7 @@
 #include "pathname.h"
 #include "primitives.h"
 #include "multipleValues.h"
+#include "evaluator.h"
 #include "strWithFillPtr.h"
 #include "designators.h"
 #include "unixfsys.h"
@@ -767,6 +768,10 @@
     }
 
 
+    Pathname_sp Stream_O::pathname() const {
+	return this->sourceFileInfo()->pathname();
+    }
+
     int Stream_O::read(unsigned char* buffer, int num)
     {
 	int numAvailable = this->listen();
@@ -1854,10 +1859,7 @@
 	{
 	    SIMPLE_ERROR(BF("You tried to close a file that is not closeable"));
 	}
-	if ( this->_FStream==NULL)
-	{
-	    SIMPLE_ERROR(BF("Could not close file - it was already closed"));
-	}
+	if ( this->_FStream==NULL) return;
 	if ( abort )
 	{
 	    _lisp->print(BF("-----Close for %s with abort=true called - I don't currently support abort=true") % this->_instanceClass()->classNameAsString() );
@@ -2318,7 +2320,6 @@
 
     void FDOutStream_O::close(bool abort)
     {_OF();
-	this->throw_if_no_file_descriptor();
 	if ( !this->_Closeable ) 
 	{
 	    SIMPLE_ERROR(BF("You tried to close a file that is not closeable"));
@@ -2328,13 +2329,25 @@
 	    fclose(this->_FStream);
 	    this->_FStream = NULL;
 	}
-	if ( !abort )
+	if ( abort )
 	{
 	    // We are supposed to rename the ActivePathname to the OriginalPathname
 	    if ( this->_RenameToOriginalOnClose )
 	    {
-		Pathname_sp backupPathname = af_pathname(this->_OriginalPathname);
-		backupPathname->_Type = Str_O::create(backupPathname->_Type.as<Str_O>()->get()+"Backup");
+		Pathname_sp backupPathname = af_makePathname(_Nil<T_O>() /* host */,
+							     false /* hostp */,
+							     _Nil<T_O>() /* device */,
+							     false /* devicep */,
+							     _Nil<T_O>() /* directory */,
+							     false /* directoryp */,
+							     _Nil<T_O>() /* name */,
+							     false /* namep */,
+							     Str_O::create(this->_OriginalPathname->_Type.as<Str_O>()->get()+"Backup") /*type*/,
+							     true /* typep */,
+							     _Nil<T_O>() /* version */,
+							     false /* versionp */,
+							     kw::_sym_local /* scase */,
+							     this->_OriginalPathname /* defaults */ );
 		if ( af_probe_file(backupPathname).notnilp() ) {
 		    af_deleteFile(backupPathname);
 		}
Index: lispStream.h
===================================================================
--- lispStream.h	(revision 4738)
+++ lispStream.h	(working copy)
@@ -119,10 +119,8 @@
 	LISP_CLASS(core,ClPkg,Stream_O,"stream");
 	DECLARE_INIT_GLOBALS();
     public:
-	Stream_O( const Stream_O& ss ); //!< Copy constructor
-
 	/*! Return the stream name as a pathname*/
-	Pathname_sp pathname() const {SUBIMP();};
+	Pathname_sp pathname() const;
 
 	virtual bool inputStreamP() const {return false;};
 	virtual bool outputStreamP() const {return false;};
@@ -165,7 +163,7 @@
 	// Output stream methods
 	virtual int writeBytes(const unsigned char* c, int n);
 	virtual void writeStr(string const& str);
-	virtual void writeChar(char c) {SUBIMP();};
+	virtual void writeChar(brclChar c) {SUBIMP();};
 	virtual void writeByte(T_sp c) {SUBIMP();};
 	virtual void writeln(string const& str) {SUBIMP();};
 	virtual Fixnum_sp writeVector(Vector_sp vec,Fixnum_sp start, Fixnum_sp end);
@@ -216,9 +214,6 @@
 	LISP_CLASS(core,ExtPkg,AnsiStream_O,"AnsiStream");
 	DECLARE_INIT_GLOBALS();
     public:
-	AnsiStream_O( const AnsiStream_O& ss ); //!< Copy constructor
-
-
 	virtual bool inputStreamP() const {return false;};
 	virtual bool outputStreamP() const {return false;};
 
@@ -251,7 +246,7 @@
 
 
 	// Output stream methods
-	virtual void writeChar(char c) {SUBIMP();};
+	virtual void writeChar(brclChar c) {SUBIMP();};
 	virtual void writeln(string const& str) {SUBIMP();};
 
 	virtual void flush() {SUBIMP();};
@@ -394,7 +389,7 @@
 	LongLongInt tellp() { return this->_Stream.tellp();};
 	void seekp(LongLongInt pos) {this->_Stream.seekp(pos,ios_base::beg);};
 	void flush() { this->_Stream.flush();};
-	virtual void writeChar(char c);
+	virtual void writeChar(brclChar c);
 	virtual void writeln(const string& str);
 	virtual uint outputColumn() const;
 	virtual bool atStartOfLine() const;
@@ -515,7 +510,7 @@
 	LongLongInt tellp() { IMPLEMENT_ME();};
 	void seekp(LongLongInt pos) { IMPLEMENT_ME();};
 	void flush();
-	virtual void writeChar(char c);
+	virtual void writeChar(brclChar c);
 	virtual void writeln(const string& str);
 	virtual uint column() const;
 	virtual bool atStartOfLine() const;
@@ -654,7 +649,7 @@
 	virtual bool outputStreamP() const {return true;};
 
 	void clear();	
-	virtual void writeChar(char c);
+	virtual void writeChar(brclChar c);
 	virtual void writeln(const string& str);
 	virtual bool atStartOfLine() const;
 	virtual uint outputColumn() const;
@@ -802,7 +797,7 @@
 	LongLongInt tellp();
 	void seekp(LongLongInt pos);
 	void flush();
-	virtual void writeChar(char c);
+	virtual void writeChar(brclChar c);
 	virtual void writeln(const string& str);
 	virtual uint outputColumn() const;
 	virtual bool atStartOfLine() const;
@@ -904,7 +899,7 @@
 
 	virtual bool outputStreamP() const;
 
-	virtual void writeChar(char c);
+	virtual void writeChar(brclChar c);
 	virtual void writeln(const string& str);
 	virtual bool atStartOfLine() const;
 	// Line counting stuff for input streams
@@ -976,7 +971,7 @@
 	string __repr__() const;
 
 	void flush();
-	virtual void writeChar(char c);
+	virtual void writeChar(brclChar c);
 	virtual void writeln(const string& str);
 	virtual bool atStartOfLine() const;
 
Index: lispVector.cc
===================================================================
--- lispVector.cc	(revision 4738)
+++ lispVector.cc	(working copy)
@@ -5,6 +5,7 @@
 #include "symbolTable.h"
 #include "core/lispVector.h"
 #include "core/str.h"
+#include "core/evaluator.h"
 #include "core/strWithFillPtr.h"
 #include "core/vectorObjects.h"
 #include "core/vectorObjectsWithFillPtr.h"
@@ -23,9 +24,14 @@
 #define ARGS_af_make_vector "(element-type dimension adjustable fill-pointer displaced-to displaced-index-offset &optional initial-element initial-contents)"
 #define DECL_af_make_vector ""    
     SYMBOL_EXPORT_SC_(ClPkg,subtypep);
-    T_sp af_make_vector(Symbol_sp element_type, Fixnum_sp dimension, T_sp adjustable,
-			T_sp fill_pointer, T_sp displaced_to, T_sp displaced_index_offset,
-			T_sp initial_element, Sequence_sp initialContents )
+    Vector_sp af_make_vector(Symbol_sp element_type,
+			int dimension,
+			bool adjustable,
+			T_sp fill_pointer,
+			T_sp displaced_to,
+			T_sp displaced_index_offset,
+			T_sp initial_element,
+			Sequence_sp initialContents )
     {_G();
 	ASSERTF(displaced_to.nilp(),BF("Add support for make-vector :displaced-to"));
 	ASSERTF(displaced_index_offset.nilp() || displaced_index_offset.as<Fixnum_O>()->get()==0,BF("Add support for make-vector non-zero :displaced-index-offset "));
@@ -47,22 +53,22 @@
 	    if ( fill_pointer.notnilp() )
 	    {
 		int ifp = 0;
-		if ( fill_pointer == BRCL_T ) ifp = dimension->get();
-		else ifp = MIN(dimension->get(),abs(fill_pointer.as<Fixnum_O>()->get()));
-		return StrWithFillPtr_O::create(c,dimension->get(),ifp,adjustable.isTrue(),initialContents);
+		if ( fill_pointer == BRCL_T ) ifp = dimension;
+		else ifp = MIN(dimension,abs(fill_pointer.as<Fixnum_O>()->get()));
+		return StrWithFillPtr_O::create(c,dimension,ifp,adjustable,initialContents);
 	    }
-	    return(Str_O::create(' ',dimension->get(),initialContents));
+	    return(Str_O::create(' ',dimension,initialContents));
 	} else
 	{
 	    if ( fill_pointer.notnilp() )
 	    {
 		int ifp = 0;
-		if ( fill_pointer == BRCL_T ) ifp = dimension->get();
+		if ( fill_pointer == BRCL_T ) ifp = dimension;
 		else ifp = fill_pointer.as<Fixnum_O>()->get();
-		return VectorObjectsWithFillPtr_O::make(initial_element,initialContents,dimension->get(),ifp,adjustable.isTrue());
+		return VectorObjectsWithFillPtr_O::make(initial_element,initialContents,dimension,ifp,adjustable);
 	    } else
 	    {
-		return VectorObjects_O::make(initial_element,initialContents,dimension->get(),adjustable.isTrue());
+		return VectorObjects_O::make(initial_element,initialContents,dimension,adjustable);
 	    }
 	}
 	SIMPLE_ERROR(BF("Handle make-vector :element-type %s") % _rep_(element_type) );
@@ -99,14 +105,10 @@
     }
 
 
-#if defined(XML_ARCHIVE)
     void Vector_O::archiveBase(::core::ArchiveP node)
     {
-	this->Bases::Base1::Base::archiveBase(node);
-	this->Bases::Base1::archiveBase(node);
-	this->Bases::Base2::archiveBase(node);
+	// Do nothing
     }
-#endif // defined(XML_ARCHIVE)
 
 
     int Vector_O::arrayDimension(int axisNumber) const
@@ -162,15 +164,15 @@
 #define	DOCS_Vector_O_vectorPush "See CLHS aref"
     Fixnum_sp Vector_O::vectorPush(T_sp newElement)
     {_G();
-	SUBCLASS_MUST_IMPLEMENT();
+	return this->vectorPush(newElement);
     }
 
-#define	ARGS_Vector_O_vectorPushExtend "(newElement (self vector) &optional extension)"
+#define	ARGS_Vector_O_vectorPushExtend "(newElement (self vector) &optional (extension 16))"
 #define	DECL_Vector_O_vectorPushExtend ""
 #define	DOCS_Vector_O_vectorPushExtend "See CLHS aref"
     Fixnum_sp Vector_O::vectorPushExtend(T_sp newElement, int extension)
     {_G();
-	SUBCLASS_MUST_IMPLEMENT();
+	return this->vectorPushExtend(newElement,extension);
     }
 
 
Index: lispVector.h
===================================================================
--- lispVector.h	(revision 4738)
+++ lispVector.h	(working copy)
@@ -18,10 +18,11 @@
 {
     LISP_VIRTUAL_BASE2(T_O,Array_O,Sequence_O);
     LISP_CLASS(core,ClPkg,Vector_O,"vector");
-#if defined(XML_ARCHIVE)
-    DECLARE_ARCHIVE();
-#endif // defined(XML_ARCHIVE)
+
+
 public:
+    void archiveBase(core::ArchiveP node);
+public:
     explicit Vector_O(): T_O(), Array_O(), Sequence_O() {} ;
     virtual ~Vector_O() {};
 public:
@@ -67,9 +68,14 @@
     // Like ecl_vector_start_end
     T_mv brcl_vectorStartEnd(Symbol_sp fn, T_sp thing, Fixnum_sp start, Fixnum_sp end); 
 
-    T_sp af_make_vector(Symbol_sp element_type, Fixnum_sp dimension, T_sp adjustable,
-			T_sp fill_pointer, T_sp displaced_to, T_sp displaced_index_offset,
-			T_sp initial_element, Sequence_sp initial_contents );
+    Vector_sp af_make_vector(Symbol_sp element_type,
+			int dimension,
+			bool adjustable,
+			T_sp fill_pointer=Fixnum_O::create(0),
+			T_sp displaced_to=_Nil<T_O>(),
+			T_sp displaced_index_offset=_Nil<T_O>(),
+			T_sp initial_element=_Nil<T_O>(),
+			Sequence_sp initial_contents=_Nil<Sequence_O>() );
 
 };
 #endif /* _core_Vector_H */
Index: metaClass.cc
===================================================================
--- metaClass.cc	(revision 4737)
+++ metaClass.cc	(working copy)
@@ -17,6 +17,7 @@
 #include "lambdaListHandler.h"
 #include "core/lispList.h"
 #include "instance.h"
+#include "evaluator.h"
 #include "hashTable.h"
 #include "builtInClass.h"
 #include "standardClass.h"
@@ -38,16 +39,17 @@
 
     
     
-#define ARGS_af_allocateRawClass "(original meta-class slots)"
+#define ARGS_af_allocateRawClass "(original meta-class slots &optional name)"
 #define DECL_af_allocateRawClass ""
 #define DOCS_af_allocateRawClass "allocateRawClass - behaves like ECL instance::allocate_raw_instance"
-    T_sp af_allocateRawClass(Class_sp orig, Class_sp metaClass, int slots)
+    T_sp af_allocateRawClass(Class_sp orig, Class_sp metaClass, int slots, T_sp className)
     {_G();
 	if ( orig.notnilp() )
 	{
 	    SIMPLE_ERROR(BF("Deal with non-nil orig in allocateRawClass"));
 	    // Check out ecl/src/c/instance.d/si_allocate_raw_instance
 	}
+//	printf("%s:%d:%s allocateRawClass metaClass: %s  for class: %s\n", __FILE__,__LINE__,__FUNCTION__,_rep_(metaClass).c_str(), _rep_(className).c_str() );
 	Class_sp newClass = metaClass->allocate_newNil().as<Class_O>();
 	newClass->initialize();
 	newClass->initializeSlots(slots);
@@ -123,7 +125,9 @@
 
     T_sp Class_O::allocate_newNil()
     {_G();
-	ASSERTP(this->_instance_newNil_callback != NULL, "_instance_newNil_callback is NULL!!");
+	if ( UNLIKELY(this->_instance_newNil_callback == NULL) ) {
+	    SIMPLE_ERROR(BF("_instance_newNil_callback for %s is NULL!!") % _rep_(this->asSmartPtr()) );
+	}
 	T_sp newObject = (*(this->_instance_newNil_callback))();
 	return newObject;
     }
@@ -325,7 +329,17 @@
 */
     void	Class_O::describe()
     {_G();
-	_lisp->print(BF("%s") % this->dumpInfo().c_str() );
+	printf("Class instanceClassName %s\n", this->instanceClassName().c_str() );
+	printf("FullName %s\n", this->name()->fullName().c_str() );
+	if ( this->directSuperclasses().nilp() ) {
+	    printf("There are no super-classes!!!!!!\n");
+	} else {
+	    for ( Cons_sp cc = this->directSuperclasses(); cc.notnilp(); cc=cCdr(cc) )
+	    {
+		printf("Super class: %s\n", oCar(cc).as<Class_O>()->instanceClassName().c_str() );
+	    }
+	}
+	printf(" this.instanceAllocatorFunctor* = %p\n", (void*)(this->instance_newNil_callback()));
     }
 
 
Index: metaobject.h
===================================================================
--- metaobject.h	(revision 4737)
+++ metaobject.h	(working copy)
@@ -25,8 +25,6 @@
     LISP_CLASS(core,CorePkg,Metaobject_O,"metaobject");
 public:
 
-	Metaobject_O( const Metaobject_O& ss ); //!< Copy constructor
-
 	explicit Metaobject_O();
 	virtual ~Metaobject_O();
 };
Index: methodptr.h
===================================================================
--- methodptr.h	(revision 4737)
+++ methodptr.h	(working copy)
@@ -53,7 +53,7 @@
 	this->fptr = fp;
     };
     virtual string describe() const {return "Methoid";};
-    T_mv activate(const_ActivationFrame_spREF frame)
+    T_mv activate( const_ActivationFrame_spREF closedEnv,const_ActivationFrame_spREF frame)
     {
 	T_sp receiver = frame->entry(this->_SingleDispatchArgumentIndex);
 	mem::smart_ptr<OT> obj = receiver.as<OT>();
@@ -86,7 +86,7 @@
     ChainableMethoid( const string& name, Functoid* m) : AFFunctoid(name), _methoid(m) {};
     virtual ~ChainableMethoid() { if (this->_methoid!=NULL) { delete this->_methoid; this->_methoid = NULL;}};
     virtual string describe() const {return "ChainableMethoid";};
-    T_mv activate(const_ActivationFrame_spREF frame)
+    T_mv activate( const_ActivationFrame_spREF closedEnv,int nargs, ArgArray args)
     {_G();
 	IMPLEMENT_MEF(BF("Handle new way of passing emfun in activation frames"));
 #if 0
Index: model.cc
===================================================================
--- model.cc	(revision 4737)
+++ model.cc	(working copy)
@@ -143,7 +143,7 @@
 #endif // defined(XML_ARCHIVE)
 
 
-    bool Model_O::loadFinalize(::core::Dumb_Node* node)
+    bool Model_O::loadFinalize(ArchiveP node)
     {
 	this->cleanupListeners();
 	return true;
@@ -428,12 +428,12 @@
 	    LOG(BF("There were %d listeners that got signals") % count );
 	}
 	{_BLOCK_TRACEF(BF("Activating triggers"));
-	    ValueFrame_sp frame(ValueFrame_O::create_fill(this->sharedThis<Model_O>(),_Nil<ActivationFrame_O>()));
+	    ValueFrame_sp frame(ValueFrame_O::create_fill(_Nil<ActivationFrame_O>(),this->sharedThis<Model_O>()));
 	    int count = 0;
 	    for ( triggerIterator jt=this->_Triggers.lower_bound(sig); jt!=this->_Triggers.upper_bound(sig); jt++ )
 	    {
 		LOG(BF("Invoking trigger: %s") % _rep_(jt->second) );
-		eval::apply(jt->second,frame);
+		eval::applyToActivationFrame(jt->second,frame);
 		count++;
 	    }
 	    LOG(BF("There were %d triggers invoked") % count );
Index: model.h
===================================================================
--- model.h	(revision 4737)
+++ model.h	(working copy)
@@ -70,7 +70,7 @@
     set<Symbol_sp>			_SignalsToHold;
     typedef set<Symbol_sp>::iterator	holdIterator;
 public:
-    bool loadFinalize(Dumb_Node* node);
+    bool loadFinalize(core::ArchiveP node);
 private:
     void _notify(const string& sigType, Symbol_sp sig, Cons_sp data);
 
Index: multiStringBuffer.h
===================================================================
--- multiStringBuffer.h	(revision 4737)
+++ multiStringBuffer.h	(working copy)
@@ -70,9 +70,7 @@
 public:	// Creation class functions
 
 public:
-	MultiStringBuffer_O( const MultiStringBuffer_O& ss ); //!< Copy constructor
 
-
 		/*! Add the string and return the index for the string
 		 */
 	uint	addCharacters(const char* str);
Index: multipleValues.h
===================================================================
--- multipleValues.h	(revision 4737)
+++ multipleValues.h	(working copy)
@@ -48,11 +48,15 @@
     private:
 	int 	_number_of_values;
     public:
-	multiple_values() : smart_ptr<T>(), _number_of_values(0) {};
+	multiple_values() : smart_ptr<T>(_Nil<T>()), _number_of_values(0) {};
 	multiple_values(const smart_ptr<T>& v,int num) : smart_ptr<T>(v), _number_of_values(num) {};
+	multiple_values(const smart_ptr<T>& v) : smart_ptr<T>(v), _number_of_values(1) {};
 	template <class Y> multiple_values(const mem::multiple_values<Y>& yy) : smart_ptr<T>(yy), _number_of_values(yy.number_of_values()) {};
 
-	virtual int number_of_values() const { return this->_number_of_values;};
+#ifdef POLYMORPHIC_SMART_PTR
+	virtual
+#endif
+	int number_of_values() const { return this->_number_of_values;};
 
 	/*! The argument must contain the number of values */
 	vector<core::T_sp> asVector() {
Index: numbers.cc
===================================================================
--- numbers.cc	(revision 4739)
+++ numbers.cc	(working copy)
@@ -8,6 +8,7 @@
 #include "symbolTable.h"
 #include "symbol.h"
 #include "bignum.h"
+#include "evaluator.h"
 #include "conditions.h"
 #include "hashTable.h"
 #include "mathDispatch.h"
@@ -1764,6 +1765,8 @@
     void Integer_O::exposeCando(Lisp_sp lisp)
     {
 	class_<Integer_O>()
+	    .def("evenp",&Integer_O::evenp)
+	    .def("oddp",&Integer_O::oddp)
 	    ;
 	SYMBOL_EXPORT_SC_(ClPkg,logand);
 	Defun(logand);
Index: numerics.cc
===================================================================
--- numerics.cc	(revision 4739)
+++ numerics.cc	(working copy)
@@ -84,7 +84,7 @@
 
     
     
-#define ARGS_af_getUniversalTime ""
+#define ARGS_af_getUniversalTime "()"
 #define DECL_af_getUniversalTime ""
 #define DOCS_af_getUniversalTime "getUniversalTime"
     Integer_mv af_getUniversalTime()
Index: objRef.cc
===================================================================
--- objRef.cc	(revision 4737)
+++ objRef.cc	(working copy)
@@ -26,7 +26,7 @@
     {
 	node->attribute("sel",this->_Selector);
 	node->attribute("name",this->_Name);
-	node->archiveObjectIfDefined("subRef",this->_SubRef);
+	node->attributeIfNotNil("subRef",this->_SubRef);
     }
 #endif // defined(XML_ARCHIVE)
 
Index: object.cc
===================================================================
--- object.cc	(revision 4737)
+++ object.cc	(working copy)
@@ -81,8 +81,23 @@
 {
 
 
+
     
     
+#define ARGS_af_describe "(arg)"
+#define DECL_af_describe ""
+#define DOCS_af_describe "describe"
+    void af_describe(T_sp obj)
+    {_G();
+	if ( obj.nilp() ) {
+	    printf("NIL\n");
+	    return;
+	}
+	obj->describe();
+    };
+
+    
+    
 #define ARGS_af_eq "(x y)"
 #define DECL_af_eq ""
 #define DOCS_af_eq "eq"
@@ -444,12 +459,6 @@
 }
 
 
-#if defined(XML_ARCHIVE)
-void	T_O::archiveBase(core::ArchiveP node)
-{
-    	// Nothing to do here
-}
-#endif // defined(XML_ARCHIVE)
 
 
 #if defined(OLD_SERIALIZE)
@@ -461,17 +470,17 @@
 #endif
 
 
-#if defined(XML_ARCHIVE)
-void	T_O::archive(core::ArchiveP node)
+void	T_O::archiveBase(core::ArchiveP node)
 {
-    this->archiveBase(node);
+    	// Nothing to do here
+    SUBIMP();
 }
 
+
 bool	T_O::loadFinalize(core::ArchiveP node)
 {_G();
     return true;
 }
-#endif // defined(XML_ARCHIVE)
 
 string	T_O::descriptionOfContents() const
 { 
@@ -482,7 +491,7 @@
 string	T_O::description() const
 {_OF(); 
     stringstream ss;
-    if ( this == _lisp->_true() )
+    if ( this == _lisp->_true().get() )
     {
 	ss << "t";
     } else
@@ -524,6 +533,7 @@
 
 
 
+#if 0
 bool T_O::isOfClassByClassSymbol(Symbol_sp classSymbol)
 {_G();
     Class_sp mc = _lisp->classFromClassSymbol(classSymbol);
@@ -532,8 +542,8 @@
     LOG(BF("Checking if this->_class(%s) == other class(%s) --> %d") % myClass->instanceClassName() % mc->instanceClassName() % sameClass );
     return sameClass;
 }
+#endif
 
-
 T_sp T_O::instanceRef(int idx) const
 {_G();
     SIMPLE_ERROR(BF("T_O::instanceRef(%d) invoked on object class[%s] val-->%s") % idx % this->_instanceClass()->classNameAsString() % this->__repr__() );
@@ -572,6 +582,7 @@
     void T_O::exposeCando(core::Lisp_sp lisp)
 {
     class_<T_O> ot;
+    Defun(describe);
     SYMBOL_SC_(CorePkg,slBoundp);
     Defun(slBoundp);
     SYMBOL_SC_(CorePkg,isNil);
Index: object.h
===================================================================
--- object.h	(revision 4737)
+++ object.h	(working copy)
@@ -57,8 +57,9 @@
 
     class	Archive_O;
     typedef	mem::smart_ptr<Archive_O>	Archive_sp;
-    class	Dumb_Node;
-    typedef	Dumb_Node* ArchiveP;
+    class	SNode_O;
+    typedef	mem::smart_ptr<SNode_O>		SNode_sp;
+    typedef	mem::smart_ptr<SNode_O>		ArchiveP;
     class Function_O;
     typedef	mem::smart_ptr<Function_O>	Function_sp;
 
@@ -626,9 +627,8 @@
 	 */
 //	    bool hierarchy_isA(core::Hierarchy_sp h, T_sp obj);
 
-	bool isOfClassByClassSymbol(Symbol_sp cid);
-	template <class o_class>
-	bool isOfClass() { return this->isOfClassByClassSymbol(o_class::static_classSymbol()); };
+//	bool isOfClassByClassSymbol(Symbol_sp cid);
+//	template <class o_class> bool isOfClass() { return this->isOfClassByClassSymbol(o_class::static_classSymbol()); };
 	/*! Check if this is a subclass of cid */
 
 	bool isAssignableToByClassSymbol(Symbol_sp cid) const;
@@ -691,17 +691,8 @@
 
 	//! Serialize a base object of an object .
 	//Only called by subclasses that want to archive their base
-#if defined(XML_ARCHIVE)
 	virtual void archiveBase(core::ArchiveP node);
-#endif // defined(XML_ARCHIVE)
 
-	//! Serialize an object
-#if defined(XML_ARCHIVE)
-	virtual void archive(core::ArchiveP node);
-
-	//! Load an object from an archive.
-	//If you implement archive you don't need to implement this.
-	virtual void archiveLoad(core::ArchiveP node) {_G(); HARD_SUBCLASS_MUST_IMPLEMENT(); };
 	/*! Finalize an object loaded from an archive.
 	 * objects that need to finalize their contents once the entire archive
 	 * has loaded can register with the loadArchive
@@ -717,8 +708,6 @@
 	//If you implement archive you don't need to implement this.
 	virtual void save(core::ArchiveP node) {_OF(); HARD_SUBCLASS_MUST_IMPLEMENT(); };
 
-#endif // defined(XML_ARCHIVE)
-
 	bool sameAs(T_sp obj)
 	{_OF();
 	    return ( this == obj.get() );
@@ -1247,6 +1236,8 @@
 #include "metaClass.h"
 #include "conditions.h"
 
+
+
 TRANSLATE(core::T_O);
 
 namespace mem {
Index: package.cc
===================================================================
--- package.cc	(revision 4737)
+++ package.cc	(working copy)
@@ -72,8 +72,10 @@
 	    Str_sp nickstr = coerce::stringDesignator(oCar(nc));
 	    lnn.push_front(nickstr->get());
 	}
-	list<Package_sp> lup;
-	for ( Cons_sp uc = use_packages; uc.notnilp(); uc=cCdr(uc) ) lup.push_front(oCar(uc).as<Package_O>());
+	list<string> lup;
+	for ( Cons_sp uc = use_packages; uc.notnilp(); uc=cCdr(uc) ) {
+	    lup.push_front(oCar(uc).as<Package_O>()->packageName());
+	}
 	return(Values(_lisp->makePackage(package_name->get(),lnn,lup)));
     }
 
@@ -91,7 +93,7 @@
 
     
     
-#define ARGS_af_list_all_packages ""
+#define ARGS_af_list_all_packages "()"
 #define DECL_af_list_all_packages ""
 #define DOCS_af_list_all_packages "list_all_packages"
     List_mv af_list_all_packages()
@@ -424,26 +426,23 @@
     {_G();
 	Symbol_sp retval;
 	Symbol_sp retstatus;
-	int isize;
-	{MULTIPLE_VALUES_CONTEXT();
-	    T_mv mv = this->findSymbolDirectlyContained(nameKey);
-	    isize = mv.number_of_values();
+	T_mv mv = this->findSymbolDirectlyContained(nameKey);
+	int isize = mv.number_of_values();
+	if ( isize != 0 ) {
 	    retval = mv.as<Symbol_O>();
 	    retstatus = mv.valueGet(1).as<Symbol_O>();
+	    return(Values(retval,retstatus));
 	}
-	if (isize!=0) return(Values(retval,retstatus));
 	{_BLOCK_TRACEF(BF("Looking in _UsingPackages"));
 	    for ( Vector0<Package_O>::const_iterator it = this->_UsingPackages.begin();
 		  it != this->_UsingPackages.end(); it++ )
 	    {
-		LOG(BF("Looking in package[%s]") % _rep_((*it)) );
-		Symbol_sp uf, status;
-		{MULTIPLE_VALUES_CONTEXT();
-		    T_mv tmv = (*it)->findSymbolDirectlyContained(nameKey);
-		    if ( tmv.number_of_values()==0 ) continue;
-		    uf = tmv.as<Symbol_O>();
-		    status = tmv.valueGet(1).as<Symbol_O>();
-		}
+		Package_sp pkg = *it;
+		LOG(BF("Looking in package[%s]") % _rep_(pkg) );
+		T_mv tmv = pkg->findSymbolDirectlyContained(nameKey);
+		if ( tmv.number_of_values()==0 ) continue;
+		Symbol_sp uf = tmv.as<Symbol_O>();
+		Symbol_sp status = tmv.valueGet(1).as<Symbol_O>();
 		if ( status.notnilp() )
 		{
 		    if (status != kw::_sym_external) continue;
Index: package.h
===================================================================
--- package.h	(revision 4737)
+++ package.h	(working copy)
@@ -149,8 +149,6 @@
 
 
 public:
-	Package_O( const Package_O& ss ); //!< Copy constructor
-
 	DEFAULT_CTOR_DTOR(Package_O);
     };
 
Index: pathname.cc
===================================================================
--- pathname.cc	(revision 4737)
+++ pathname.cc	(working copy)
@@ -1315,16 +1315,17 @@
 #define ARGS_af_makePathname "(&key (host nil hostp) (device nil devicep) (directory nil directoryp) (name nil namep) (type nil typep) (version nil versionp) ((:case scase) :local) defaults)"
 #define DECL_af_makePathname ""
 #define DOCS_af_makePathname "makePathname"
-    Pathname_sp af_makePathname(T_sp host, bool hostp, T_sp device, bool devicep, T_sp directory, bool directoryp, T_sp name, bool namep, T_sp type, bool typep, T_sp version, bool versionp, T_sp scase, Pathname_sp defaults)
+    Pathname_sp af_makePathname(T_sp host, bool hostp, T_sp device, bool devicep, T_sp directory, bool directoryp, T_sp name, bool namep, T_sp type, bool typep, T_sp version, bool versionp, T_sp scase, T_sp odefaults)
     {_G();
 	Pathname_sp x;
-	if (defaults.nilp()) {
+	Pathname_sp defaults;
+	if (odefaults.nilp()) {
 	    defaults = brcl_defaultPathnameDefaults();
 	    defaults = Pathname_O::makePathname(defaults->_Host,
 						_Nil<T_O>(), _Nil<T_O>(), _Nil<T_O>(), _Nil<T_O>(), _Nil<T_O>(),
 						kw::_sym_local);
 	} else {
-	    defaults = af_pathname(defaults);
+	    defaults = af_pathname(odefaults);
 	}
 	if (!hostp) host = defaults->_Host;
 	x = Pathname_O::makePathname(host, device, directory, name, type, version, scase);
Index: pathname.h
===================================================================
--- pathname.h	(revision 4737)
+++ pathname.h	(working copy)
@@ -12,19 +12,16 @@
 
 
 namespace kw {
-
-extern core::Symbol_sp _sym_unspecific;
+    extern core::Symbol_sp _sym_unspecific;
+    extern core::Symbol_sp _sym_local;
+    extern core::Symbol_sp _sym_newest;
 }
 
 namespace cl {
     extern core::Symbol_sp _sym_STARdefaultPathnameDefaultsSTAR;
 };
 
-namespace kw {
-    extern core::Symbol_sp _sym_newest;
-};
 
-
 namespace core {
 
     FORWARD(Pathname);
@@ -75,7 +72,7 @@
 	friend Str_sp af_coerceToFilename(Pathname_sp pathname);
 	friend Str_sp brcl_namestring(T_sp tx, int flags);
 	friend Pathname_mv af_parseNamestring(T_sp thing, T_sp host, T_sp defaults, Fixnum_sp start, Fixnum_sp end, bool junk_allowed);
-	friend Pathname_sp af_makePathname(T_sp host, bool hostp, T_sp device, bool devicep, T_sp directory, bool directoryp, T_sp name, bool namep, T_sp type, bool typep, T_sp version, bool versionp, T_sp scase, Pathname_sp defaults);
+	friend Pathname_sp af_makePathname(T_sp host, bool hostp, T_sp device, bool devicep, T_sp directory, bool directoryp, T_sp name, bool namep, T_sp type, bool typep, T_sp version, bool versionp, T_sp scase, T_sp defaults);
 	friend T_sp af_pathnameHost(T_sp tpname, Symbol_sp scase);
 	friend T_sp af_pathnameDevice(T_sp tpname, Symbol_sp scase);
 	friend T_sp af_pathnameDirectory(T_sp tpname, Symbol_sp scase);
@@ -163,14 +160,31 @@
 
     T_sp af_pathnameTranslations(T_sp host, T_sp set);
 
+    /* If you want to call makePathname use:
+		Pathname_sp backupPathname = af_makePathname(_Nil<T_O>(), // host 
+							     false, // hostp 
+							     _Nil<T_O>(), // device 
+							     false, // devicep 
+							     _Nil<T_O>(), // directory 
+							     false, // directoryp 
+							     _Nil<T_O>(), // name 
+							     false, // namep 
+							     Str_O::create(this->_OriginalPathname->_Type.as<Str_O>()->get()+"Backup"), //type
+							     true, // typep 
+							     _Nil<T_O>(), // version 
+							     false, // versionp 
+							     kw::_sym_local, // scase 
+							     this->_OriginalPathname, // defaults 
+							     )
+    */
     Pathname_sp af_makePathname(T_sp host, bool hostp,
 				T_sp device, bool devicep,
 				T_sp directory, bool directoryp,
 				T_sp name, bool namep,
 				T_sp type, bool typep,
 				T_sp version, bool versionp,
-				T_sp scase,
-				Pathname_sp defaults);
+				T_sp scase = kw::_sym_local,
+				T_sp defaults = _Nil<T_O>());
 
 };
 
Index: posixTime.h
===================================================================
--- posixTime.h	(revision 4737)
+++ posixTime.h	(working copy)
@@ -48,7 +48,7 @@
 	string toSimpleString();
 	string toIsoString();
 
-	PosixTime_O( const PosixTime_O& ss ); //!< Copy constructor
+//	PosixTime_O( const PosixTime_O& ss ); //!< Copy constructor
 
 	DEFAULT_CTOR_DTOR(PosixTime_O);
 };
@@ -89,8 +89,6 @@
 	string toSimpleString();
 	string toIsoString();
 
-	PosixTimeDuration_O( const PosixTimeDuration_O& ss ); //!< Copy constructor
-
 	DEFAULT_CTOR_DTOR(PosixTimeDuration_O);
 };
 
Index: predicates.cc
===================================================================
--- predicates.cc	(revision 4737)
+++ predicates.cc	(working copy)
@@ -6,15 +6,16 @@
 #include "core/metaClass.h"
 #include "core/package.h"
 #include "core/bignum.h"
+#include "core/closPackage.h"
 #include "core/bitVector.h"
 #include "core/pathname.h"
 #include "core/hashTable.h"
 #include "core/vectorObjects.h"
-#ifndef CLOS
+//#ifndef CLOS
 #include "core/structureObject.h"
-#else
+//#else
 #include "core/instance.h"
-#endif
+//#endif
 #include "core/readtable.h"
 #include "core/lambdaListHandler.h"
 #include "core/singleDispatchGenericFunction.h"
@@ -366,11 +367,8 @@
     bool af_structureObjectP(T_sp obj)
     {_G();
 	if (obj.nilp()) return false;
-#ifndef CLOS
-	return obj.isA<StructureObject_O>();
-#else
+	if (obj.isA<StructureObject_O>()) return true;
 	return obj.isA<Instance_O>();
-#endif
     };
 
 #define ARGS_af_arrayP "(arg)"
@@ -620,7 +618,8 @@
 	newNameDefun(CorePkg,bignumP,bignump);
 	Defun(strP);
 	Defun(doubleFloatP);
-	Defun(classp);
+	SYMBOL_EXPORT_SC_(ClosPkg,classp);
+	af_def(ClosPkg,"classp",&af_classp,ARGS_af_classp,DECL_af_classp,DOCS_af_classp);
 	Defun(lambda_list_handler_p);
 	Defun(ratioP);
 	Defun(longFloatP);
Index: primitives.cc
===================================================================
--- primitives.cc	(revision 4738)
+++ primitives.cc	(working copy)
@@ -6,6 +6,7 @@
 #include "core/corePackage.h"
 #include "core/environment.h"
 #include "core/fileSystem.h"
+#include "core/bformat.h"
 #include "core/bignum.h"
 #include "core/character.h"
 #include "core/executables.h"
@@ -43,6 +44,7 @@
 #include "hashTableEql.h"
 #include "multipleValues.h"
 #include "lispStream.h"
+#include "structureObject.h"
 #include "lispReader.h"
 #include "designators.h"
 #include "profile.h"
@@ -52,9 +54,47 @@
 
 
 
+    
+    
+#define ARGS_af_toTaggedFixnum "(arg)"
+#define DECL_af_toTaggedFixnum ""
+#define DOCS_af_toTaggedFixnum "toTaggedFixnum"
+    T_sp af_toTaggedFixnum(int val)
+    {_G();
+	return mem::smart_ptr<T_O>(val);
+    };
 
+
+
     
     
+#define ARGS_af_fromTaggedFixnum "(val)"
+#define DECL_af_fromTaggedFixnum ""
+#define DOCS_af_fromTaggedFixnum "fromTaggedFixnum"
+    int af_fromTaggedFixnum(T_sp val)
+    {_G();
+	if ( val.BaseType::fixnump() )
+	{
+	    return val.fixnum();
+	}
+	SIMPLE_ERROR(BF("Not a fixnum"));
+    };
+
+#define ARGS_af_dumpTaggedFixnum "(arg)"
+#define DECL_af_dumpTaggedFixnum ""
+#define DOCS_af_dumpTaggedFixnum "dumpTaggedFixnum"
+    void af_dumpTaggedFixnum(T_sp val)
+    {_G();
+	if ( val.BaseType::fixnump() ) {
+	    printf("%s:%d Raw TaggedFixnum %p   Untagged %d\n",
+		   __FILE__,__LINE__, val.pxget(), val.fixnum() );
+	} else
+	    printf("%s:%d Not a tagged fixnum\n", __FILE__, __LINE__ );
+    }
+
+
+    
+    
 #define ARGS_af_getEnv "(arg)"
 #define DECL_af_getEnv ""
 #define DOCS_af_getEnv "getEnv"
@@ -389,6 +429,16 @@
     
     
 
+#define ARGS_af_break "(&optional fmt-control &rest args)"
+#define DECL_af_break ""
+#define DOCS_af_break "Built in implementation of break - that calls the internal debugger - replace this with a CL implemented version"
+    void af_break(Str_sp fmt, Cons_sp args)
+    {_G();
+	if ( fmt.notnilp() ) {
+	    af_format(_lisp->_true(),fmt,args);
+	}
+	dbg_hook("built in break");
+    };
 
     
     
@@ -470,7 +520,7 @@
     void af_ensure_single_dispatch_generic_function(Symbol_sp gfname, LambdaListHandler_sp llhandler,
 						    int dispatch_on_required_argument_index )
     {_G();
-	SingleDispatchGenericFunction_sp gf = SingleDispatchGenericFunction_O::create(gfname,llhandler,dispatch_on_required_argument_index,_lisp);
+	SingleDispatchGenericFunction_sp gf = SingleDispatchGenericFunction_O::create(gfname,llhandler,dispatch_on_required_argument_index);
 	Lisp_O::setf_find_single_dispatch_generic_function(gfname,gf);
 	gfname->setf_symbolFunction(gf);
     };
@@ -680,21 +730,21 @@
 #define DOCS_af_read "read an object from a stream - see CLHS"
 #define ARGS_af_read "(&optional input-stream-designator (eof-error-p t) eof-value recursive-p)"
 #define DECL_af_read ""    
-    T_mv af_read(T_sp input_stream_designator, T_sp eof_error_p, T_sp eof_value, T_sp recursive_p)
+    T_sp af_read(T_sp input_stream_designator, T_sp eof_error_p, T_sp eof_value, T_sp recursive_p)
     {_G();
 	Stream_sp sin = coerce::inputStreamDesignator(input_stream_designator);
-	return(Values(read_lisp_object(sin,eof_error_p.isTrue(),eof_value,recursive_p)));
+	return(read_lisp_object(sin,eof_error_p.isTrue(),eof_value,recursive_p.notnilp()));
     }
 
 
 #define DOCS_af_read_preserving_whitespace "read an object from a stream while preserving whitespace - see CLHS"
 #define ARGS_af_read_preserving_whitespace "(&optional input-stream-designator (eof-error-p t) eof-value recursive-p)"
 #define DECL_af_read_preserving_whitespace ""    
-    T_mv af_read_preserving_whitespace(T_sp input_stream_designator, T_sp eof_error_p, T_sp eof_value, T_sp recursive_p)
+    T_sp af_read_preserving_whitespace(T_sp input_stream_designator, T_sp eof_error_p, T_sp eof_value, T_sp recursive_p)
     {_G();
 	DynamicScopeManager scope(_sym_STARpreserve_whitespace_pSTAR,BRCL_T);
 	Stream_sp sin = coerce::inputStreamDesignator(input_stream_designator);
-	return(Values(read_lisp_object(sin,eof_error_p.isTrue(),eof_value,recursive_p)));
+	return(read_lisp_object(sin,eof_error_p.isTrue(),eof_value,recursive_p));
     }
 
 
@@ -900,7 +950,7 @@
 	{
 	    steppers.fillValueFrameUsingCurrentSteppers(frame);
 	    LOG(BF("Applying predicate to elements[%s]") % frame->asString());
-	    bool test = eval::apply(predicate,frame).isTrue();
+	    bool test = eval::applyToActivationFrame(predicate,frame).isTrue();
 	    if (test==elementTest)
 	    {
 		LOG(BF("element test was %d - returning %d") % elementTest % elementReturn );
@@ -919,7 +969,7 @@
 #define DECL_af_every ""    
     T_mv af_every(T_sp predicate, Cons_sp sequences)
     {_G();
-	Function_sp op = coerce::functionDesignator(predicate,_lisp);
+	Function_sp op = coerce::functionDesignator(predicate);
 	bool result = test_every_some_notevery_notany(op,sequences,false,false,true);
 	return(Values(_lisp->_boolean(result)));
     }
@@ -931,7 +981,7 @@
 #define DECL_af_some ""    
     T_mv af_some(T_sp predicate, Cons_sp sequences)
     {_G();
-	Function_sp op = coerce::functionDesignator(predicate,_lisp);
+	Function_sp op = coerce::functionDesignator(predicate);
 	bool result = test_every_some_notevery_notany(op,sequences,true,true,false);
 	return(Values(_lisp->_boolean(result)));
     }
@@ -945,7 +995,7 @@
 #define DECL_af_notany ""    
     T_mv af_notany(T_sp predicate, Cons_sp sequences)
     {_G();
-	Function_sp op = coerce::functionDesignator(predicate,_lisp);
+	Function_sp op = coerce::functionDesignator(predicate);
 	bool result = test_every_some_notevery_notany(op,sequences,true,false,true);
 	return(Values(_lisp->_boolean(result)));
     }
@@ -958,7 +1008,7 @@
 #define DECL_af_notevery ""    
     T_mv af_notevery(T_sp predicate, Cons_sp sequences)
     {_G();
-	Function_sp op = coerce::functionDesignator(predicate,_lisp);
+	Function_sp op = coerce::functionDesignator(predicate);
 	bool result = test_every_some_notevery_notany(op,sequences,false,true,false);
 	return(Values(_lisp->_boolean(result)));
     }
@@ -978,14 +1028,14 @@
     SYMBOL_EXPORT_SC_(ClPkg,mapcar);
     List_mv af_mapcar(T_sp func_desig, Cons_sp lists)
     {_G();
-	Function_sp func = coerce::functionDesignator(func_desig,_lisp);
+	Function_sp func = coerce::functionDesignator(func_desig);
 	ListOfListSteppers steppers(lists);
 	ValueFrame_sp frame(ValueFrame_O::create(steppers.size(),_Nil<ActivationFrame_O>()));
 	ql::list result(_lisp);
 	while (!steppers.atEnd())
 	{
 	    steppers.fillValueFrameUsingCurrentSteppers(frame);
-	    T_sp res = eval::apply(func,frame);
+	    T_sp res = eval::applyToActivationFrame(func,frame);
 	    result << res;
 	    steppers.advanceSteppers();
 	}
@@ -1027,7 +1077,7 @@
 		++idx;
 	    }
 	    LOG(BF("About to evaluate map op[%s] on arguments[%s]") % _rep_(op) % _rep_(frame) );
-	    T_sp res = eval::applyFunctionToActivationFrame(op,frame);
+	    T_sp res = op->INVOKE(frame->length(),frame->argArray()); // T_sp res = eval::applyFunctionToActivationFrame(op,frame);
 	}
     RETURN:
 	return(Values(oCar(lists)));
@@ -1041,7 +1091,7 @@
 #define DECL_af_maplist ""    
     T_mv af_maplist(T_sp func_desig, Cons_sp lists)
     {_G();
-	Function_sp op = coerce::functionDesignator(func_desig,_lisp);
+	Function_sp op = coerce::functionDesignator(func_desig);
 	VectorObjectsWithFillPtr_sp argumentLists(VectorObjectsWithFillPtr_O::make(_Nil<Cons_O>(),_Nil<Cons_O>(),16,0,true));
 //	vector<Cons_sp> argumentLists;
 	// Copy the arguments into argumentLists
@@ -1066,7 +1116,7 @@
 	    }
 	    LOG(BF("About to evaluate map op[%s] on arguments[%s]")
 		% _rep_(op) % _rep_(frame) );
-	    T_sp res = eval::applyFunctionToActivationFrame(op,frame);
+	    T_sp res = op->INVOKE(frame->length(),frame->argArray()); // T_sp res = eval::applyFunctionToActivationFrame(op,frame);
 	    Cons_sp one = Cons_O::create(res,_lisp);
 	    curResult->setCdr(one);
 	    curResult = one;
@@ -1122,7 +1172,7 @@
     {_G();
 	Cons_sp parts = af_maplist(op,lists).as_or_nil<Cons_O>();
 	ValueFrame_sp frame(ValueFrame_O::create(parts,_Nil<ActivationFrame_O>()));
-	T_sp result = eval::apply(cl::_sym_nconc,frame);
+	T_sp result = eval::applyToActivationFrame(cl::_sym_nconc,frame);
 	return(Values(result));
     };
 
@@ -1134,7 +1184,7 @@
     {_G();
 	Cons_sp parts = af_mapcar(op,lists).as_or_nil<Cons_O>();
 	ValueFrame_sp frame(ValueFrame_O::create(parts,_Nil<ActivationFrame_O>()));
-	T_sp result = eval::apply(cl::_sym_nconc,frame);
+	T_sp result = eval::applyToActivationFrame(cl::_sym_nconc,frame);
 	return(Values(result));
     };
 
@@ -1199,7 +1249,7 @@
 #define DOCS_af_coerce_to_function "coerce_to_function"
     Function_mv af_coerce_to_function(T_sp arg)
     {_G();
-	return(Values(coerce::functionDesignator(arg,_lisp)));
+	return(Values(coerce::functionDesignator(arg)));
     };
 
 
@@ -1271,8 +1321,21 @@
 	    {
 		LOG(BF("supersede"));
 		// First write output to a temporary file and then rename it to the original on close
-		Pathname_sp temporaryFileSpec = af_pathname(filespec);
-		temporaryFileSpec->_Type = Str_O::create(temporaryFileSpec->_Type.as<Str_O>()->concat(Str_O::create("Temp")));
+		Pathname_sp temporaryFileSpec = af_makePathname(_Nil<T_O>(), // host 
+								false, // hostp 
+								_Nil<T_O>(), // device 
+								false, // devicep 
+								_Nil<T_O>(), // directory 
+								false, // directoryp 
+								_Nil<T_O>(), // name 
+								false, // namep 
+								Str_O::create(filespec->_Type.as<Str_O>()->get()+"Temp"), //type
+								true, // typep 
+								_Nil<T_O>(), // version 
+								false, // versionp 
+								kw::_sym_local, // scase 
+								filespec // defaults 
+		    );
 		if ( external_format == kw::_sym_default)
 		{
 		    LOG(BF("external_format is :default"));
@@ -1398,6 +1461,7 @@
     {
 	return(Values(_sym_CandoException_O));
     }
+    return Values(x->__class()->className());
     SIMPLE_ERROR(BF("Add af_type_to_symbol support for type: %s") % x->_instanceClass()->classNameAsString() );
 }
 
@@ -1489,13 +1553,9 @@
 	    t = cl::_sym_array;
 	} else t = cl::_sym_simple_array;
 	return (ql::list(_lisp) << t << cl::_sym_bit << Cons_O::createList(Fixnum_O::create(1),Fixnum_O::create(af_length(bx)))).cons();
-#ifndef CLOS
-    } else if ( af_structureObjectP(x) )
+    } else if ( af_structurep(x) )
     {
-	
-	IMPLEMENT_MEF(BF("Handle type-of for StructureObject"));
-//	return x.as<StructureObject_O>()->structureClass();
-#endif
+	return x.as<StructureObject_O>()->structureType();
     } else if ( af_streamp(x) )
     {
 	if ( x.isA<SynonymStream_O>() ) 		return cl::_sym_SynonymStream_O;
@@ -1561,6 +1621,8 @@
 
 
 
+
+
 // --------------------------------------------------
 // --------------------------------------------------
 // --------------------------------------------------
@@ -1677,6 +1739,7 @@
 
 	SYMBOL_SC_(CorePkg,gdb);
 	Defun(gdb);
+	Defun(break);
 	SYMBOL_SC_(CorePkg,gdbInspect);
 	Defun(gdbInspect);
 
@@ -1737,6 +1800,12 @@
 	SYMBOL_EXPORT_SC_(CorePkg,getEnv);
 	Defun(getEnv);
 
+	SYMBOL_EXPORT_SC_(CorePkg,toTaggedFixnum);
+	SYMBOL_EXPORT_SC_(CorePkg,fromTaggedFixnum);
+	SYMBOL_EXPORT_SC_(CorePkg,dumpTaggedFixnum);
+	Defun(toTaggedFixnum);
+	Defun(fromTaggedFixnum);
+	Defun(dumpTaggedFixnum);
     }
 
 
Index: primitives.h
===================================================================
--- primitives.h	(revision 4737)
+++ primitives.h	(working copy)
@@ -18,6 +18,8 @@
 
     extern T_mv af_read_delimited_list(Character_sp chr, T_sp input_stream_designator, T_sp recursive_p);
 
+    T_sp af_read(T_sp input_stream_designator, T_sp eof_error_p=_Nil<T_O>(), T_sp eof_value=_Nil<T_O>(), T_sp recursive_p=_Nil<T_O>());
+
     extern void af_ensure_single_dispatch_method(Symbol_sp gfname, Class_sp receiver_class, LambdaListHandler_sp lambda_list_handler, Cons_sp declares, Str_sp docstring, CompiledBody_sp body );
 
 
Index: print.cc
===================================================================
--- print.cc	(revision 4737)
+++ print.cc	(working copy)
@@ -5,6 +5,7 @@
 #include "core/cons.h"
 #include "core/symbolTable.h"
 #include "core/designators.h"
+#include "core/evaluator.h"
 #include "core/lispStream.h"
 #include "core/primitives.h"
 #include "core/write_object.h"
Index: readtable.cc
===================================================================
--- readtable.cc	(revision 4738)
+++ readtable.cc	(working copy)
@@ -7,6 +7,7 @@
 #include "core/evaluator.h"
 #include "core/character.h"
 #include "core/str.h"
+#include "core/bitVector.h"
 #include "core/package.h"
 #include "core/predicates.h"
 #include "core/multipleValues.h"
@@ -461,7 +462,55 @@
 #define DECL_af_sharp_asterisk ""    
     T_mv af_sharp_asterisk(Stream_sp sin, Character_sp ch, T_sp num)
     {_G();
-	IMPLEMENT_MEF(BF("Implement sharp_asterisk"));
+	int dimcount, dim =0;
+	stringstream pattern;
+	ReadTable_sp rtbl = cl::_sym_STARreadtableSTAR->symbolValue().as<ReadTable_O>();
+	
+	if ( cl::_sym_STARread_suppressSTAR->symbolValue().isTrue() ) {
+	    read_lisp_object(sin,true,_Nil<T_O>(),true);
+	    return Values(_Nil<T_O>());
+	}
+	for (dimcount = 0 ; ; dimcount++) {
+	    ch = af_readChar(sin,BRCL_NIL,BRCL_NIL,BRCL_T).as<Character_O>();
+	    if (ch.nilp()) break;
+	    Symbol_sp syntaxType = rtbl->syntax_type(ch);
+	    if (syntaxType == kw::_sym_terminating_macro_character
+		|| syntaxType == kw::_sym_whitespace_character) {
+		unread_ch(sin,ch);
+		break;
+	    }
+	    unlikely_if (syntaxType == kw::_sym_single_escape_character ||
+			 syntaxType == kw::_sym_multiple_escape_character ||
+			 ( ch->asChar() != '0' && ch->asChar() != '1')) {
+		READER_ERROR(Str_O::create("Character ~:C is not allowed after #*"),Cons_O::create(ch),sin);
+	    }
+	    pattern << ch->asChar();
+	}
+	if (Null(num)) {
+	    dim = dimcount;
+	} else if (num.isA<Fixnum_O>()) {
+	    dim = num.as<Fixnum_O>()->get();
+	    unlikely_if ( dim < 0 ||
+			  (dim > BRCL_ARRAY_DIMENSION_LIMIT))
+	{
+		READER_ERROR(Str_O::create("Wrong vector dimension size ~D in #*."), Cons_O::create(num), sin);
+	    }
+	    unlikely_if (dimcount > dim)
+		READER_ERROR(Str_O::create("Too many elements in #*."),_Nil<Cons_O>(),sin);
+	    unlikely_if (dim && (dimcount == 0))
+		READER_ERROR(Str_O::create("Cannot fill the bit-vector #*."),_Nil<Cons_O>(),sin);
+	}
+	string bitPattern = pattern.str();
+	char last = bitPattern.size()>0 ? bitPattern[bitPattern.size()-1] : '0';
+	SimpleBitVector_sp x = SimpleBitVector_O::create(dim);
+	for (int i = 0; i < dim; i++) {
+	    char elt = (i < dimcount) ? bitPattern[i] : last;
+	    if (elt == '0')
+		x->setBit(i,0);
+	    else
+		x->setBit(i,1);
+	}
+	return Values(x);
     };
 
 
@@ -996,7 +1045,7 @@
 	{
 	    plist << kw::_sym_syntax << kw::_sym_terminating_macro_character;
 	}
-	Function_sp func = coerce::functionDesignator(funcDesig,_lisp);
+	Function_sp func = coerce::functionDesignator(funcDesig);
 	plist << kw::_sym_macro_function << func;
 	this->_Syntax->hash_table_setf_gethash(ch,plist.cons());
 	return _lisp->_true();
@@ -1081,7 +1130,7 @@
 	HashTable_sp dispatch_table = disp_char_plist->getf(kw::_sym_dispatch_table,_Nil<HashTable_O>() ).as<HashTable_O>();
 	ASSERTF(dispatch_table.notnilp(),BF("The dispatch table for the character[%s] is nil! - this shouldn't happen") % _rep_(disp_char) );
 	Character_sp upcase_sub_char = sub_char->char_upcase();
-	Function_sp new_func = coerce::functionDesignator(new_func_desig,_lisp);
+	Function_sp new_func = coerce::functionDesignator(new_func_desig);
 	dispatch_table->hash_table_setf_gethash(upcase_sub_char,new_func);
 	return _lisp->_true();
     }
Index: sequence.cc
===================================================================
--- sequence.cc	(revision 4737)
+++ sequence.cc	(working copy)
@@ -22,6 +22,7 @@
     uint af_length(T_sp arg)
     {_G();
 	if (arg.nilp()) return 0;
+	ASSERTF(arg.pointerp(),BF("The arg is not a pointer"));
 	if ( Sequence_sp seq = arg.asOrNull<Sequence_O>() )
 	{
 	    return seq->length();
@@ -186,13 +187,10 @@
 #endif
 #endif
 
-#if defined(XML_ARCHIVE)
     void Sequence_O::archiveBase(::core::ArchiveP node)
     {
-        this->Base::archiveBase(node);
-	// Archive other instance variables here
+	// do nothing
     }
-#endif // defined(XML_ARCHIVE)
 
 
     void Sequence_O::initialize()
Index: sequence.h
===================================================================
--- sequence.h	(revision 4737)
+++ sequence.h	(working copy)
@@ -16,10 +16,10 @@
     {
 	LISP_BASE1(T_O);
 	LISP_CLASS(core,ClPkg,Sequence_O,"Sequence");
-#if defined(XML_ARCHIVE)
-	DECLARE_ARCHIVE();
-#endif // defined(XML_ARCHIVE)
+
     public:
+	void archiveBase(SNode_sp node);
+    public:
 	explicit Sequence_O(): T_O() {}
 	virtual ~Sequence_O() {}
 
Index: singleDispatchEffectiveMethodFunction.cc
===================================================================
--- singleDispatchEffectiveMethodFunction.cc	(revision 4737)
+++ singleDispatchEffectiveMethodFunction.cc	(working copy)
@@ -86,7 +86,8 @@
     }
 
 
-    T_mv SingleDispatchEffectiveMethodFunction_O::INVOKE(const_ActivationFrame_spREF args)
+
+    T_mv SingleDispatchEffectiveMethodFunction_O::INVOKE(int nargs, ArgArray argArray )
     {_OF();
 	LOG(BF("My methods --> %s") % _rep_(this) );
 	IMPLEMENT_MEF(BF("Implement emf"));
Index: singleDispatchEffectiveMethodFunction.h
===================================================================
--- singleDispatchEffectiveMethodFunction.h	(revision 4737)
+++ singleDispatchEffectiveMethodFunction.h	(working copy)
@@ -30,7 +30,7 @@
 	Cons_sp	_Methods;
 
     private:
-	T_mv INVOKE(const_ActivationFrame_spREF args);
+	T_mv INVOKE(int nargs, ArgArray args);
 	
     public: // Functions here
 
Index: singleDispatchGenericFunction.cc
===================================================================
--- singleDispatchGenericFunction.cc	(revision 4737)
+++ singleDispatchGenericFunction.cc	(working copy)
@@ -50,13 +50,12 @@
 
 
 
-    SingleDispatchGenericFunction_sp SingleDispatchGenericFunction_O::create(T_sp name, LambdaListHandler_sp llh, int dispatch_on_required_argument_index, Lisp_sp lisp)
+    SingleDispatchGenericFunction_sp SingleDispatchGenericFunction_O::create(T_sp name, LambdaListHandler_sp llh, int dispatch_on_required_argument_index)
     {_G();
 	GC_RESERVE_BEGIN(SingleDispatchGenericFunction_O,gf ){
 	    GC_RESERVE_GET(SingleDispatchGenericFunction_O,gf );
 	} GC_RESERVE_END(gf );
 	gf->setFunctionName(name);
-	gf->_lambdaListHandler = llh;
 	gf->_DispatchOnIndex = dispatch_on_required_argument_index;
 	gf->_Kind = kw::_sym_function;
 	gf->_LambdaListHandler = llh;
@@ -105,15 +104,7 @@
 		if ( existing->receiver_class() == method->receiver_class() )
 		{
 		    LOG(BF("... and that matches the defmethod reciever class"));
-		    if ( !existing->can_be_redefined() )
-		    {
-			SIMPLE_ERROR(BF("You tried to overwrite a locked method with name[%s]") % _rep_(name));
-		    } else
-		    {
-			cur->setCar(method);
-			replacedMethod = true;
-			break;
-		    }
+		    SIMPLE_ERROR(BF("You tried to overwrite a locked method with name[%s]") % _rep_(name));
 		}
 	    }
 	}
@@ -126,12 +117,14 @@
     }
 
 
+
+
     /*! I think this fills the role of the lambda returned by
       std-compute-discriminating-function (gf) AMOP-303 top
     */
-    T_mv SingleDispatchGenericFunction_O::INVOKE(const_ActivationFrame_spREF args)
+    T_mv SingleDispatchGenericFunction_O::INVOKE(int nargs, ArgArray args)
     {_OF();
-	T_sp dispatchArg = args->entry(this->_DispatchOnIndex);
+	T_sp dispatchArg = args[this->_DispatchOnIndex];
 	ASSERTF(!dispatchArg.unboundp(),BF("The dispatch object is UNBOUND"));
 	Class_sp dispatchArgClass = lisp_instance_class(dispatchArg);
 	ASSERTF(!dispatchArgClass.nilp(),BF("The dispatch class is NIL!!!!"));
@@ -151,7 +144,7 @@
 	    LOG(BF("Found hashed effective method - using that"));
 	}
 	LOG(BF("Invoking the effective method function"));
-	return emf->INVOKE(args);
+	return emf->INVOKE(nargs,args);
     };
 
     class	SingleDispatch_OrderByClassPrecedence
@@ -167,47 +160,27 @@
     Function_sp SingleDispatchGenericFunction_O::slow_method_lookup(Class_sp mc)
     {_OF();
 	LOG(BF("Looking for applicable methods for receivers of class[%s]") % _rep_(mc) );
-	Vector0<SingleDispatchMethod_O>	applicable_methods;
+	SingleDispatchMethod_sp applicable_method(_Nil<SingleDispatchMethod_O>());
 	for ( Cons_sp cur = this->_Methods; cur.notnilp(); cur=cCdr(cur) )
 	{
 	    SingleDispatchMethod_sp sdm = oCar(cur).as<SingleDispatchMethod_O>();
 	    Class_sp ac = sdm->receiver_class();
-	    if ( mc->isSubClassOf(ac) )
+	    if ( UNLIKELY(mc->isSubClassOf(ac)) )
 	    {
 		LOG(BF("Found applicable method with receiver class[%s]") % _rep_(ac) );
-		applicable_methods.push_back(sdm);
-	    } else
-	    {
-		LOG(BF("%s is not a subclass of %s") % _rep_(mc) % _rep_(ac) );
+		if ( applicable_method.notnilp() ) {
+		    SIMPLE_ERROR(BF("There should only be one applicable_method for single-dispatch-generic-function %s with receiver class %s") % this->getFunctionName() % mc->instanceClassName() );
+		}
+		applicable_method = sdm;
 	    }
 	}
-	if ( applicable_methods.size() == 0 )
+	if ( UNLIKELY(applicable_method.nilp()) )
 	{
 	    SIMPLE_ERROR(BF("There are no applicable methods of %s for receiver class %s")
-			       % _rep_(this->getFunctionName())
-			       % mc->instanceClassName() );
+			 % _rep_(this->getFunctionName())
+			 % mc->instanceClassName() );
 	}
-	/* Sort the methods from most applicable to least applicable */
-	SingleDispatch_OrderByClassPrecedence sort_by_class_precedence;
-	sort::quickSort(applicable_methods.begin(),applicable_methods.end(),sort_by_class_precedence,_lisp);
-	if ( applicable_methods.size()>=2 )
-	{
-	    // Check if we got the sort order right - later take this check out
-	    Vector0<SingleDispatchMethod_O>::const_iterator am1 = applicable_methods.begin();
-	    Vector0<SingleDispatchMethod_O>::const_iterator am2 = am1+1;
-	    if ( !(*am1)->receiver_class()->isSubClassOf((*am2)->receiver_class()) )
-	    {
-		SIMPLE_ERROR(BF("Sort of applicable_methods got the order wrong"));
-	    }
-#if 0
-	    printf("%s:%d - Check of sorted order of applicable_methods for [%s] got "
-		   "first method receiver class[%s] and second method receiver class[%s]\n",
-		   __FILE__,__LINE__, this->getSymbol()->__repr__().c_str(),
-		   (*am1)->receiver_class()->__repr__().c_str(),(*am2)->receiver_class()->__repr__().c_str() );
-#endif
-	}
-	Cons_sp methods = applicable_methods.asCons();
-	Function_sp emf = this->compute_effective_method_function(methods);
+	Function_sp emf = this->compute_effective_method_function(applicable_method);
 	return emf;
     }
 
@@ -223,8 +196,6 @@
 	/*! Store the method_function that this emf invokes.
 	  This function takes two arguments: (args next-emfun) */
 	Function_sp		_method_function;
-	/*! Store the next-emfun that will be passed to the _method_function */
-	Function_sp		_next_emfun;
     public:
 	string describe() const { return "Lambda_emf";};
 	bool requires_activation_frame() const { return true;};
@@ -232,32 +203,32 @@
 	Lambda_emf(const string& name,
 		   SingleDispatchGenericFunction_sp gf,
 		   Symbol_sp emf_name,
-		   SingleDispatchMethod_sp cur_method,
-		   Cons_sp next_methods) : Functoid("Lambda_emf->"+name)
+		   SingleDispatchMethod_sp cur_method ) : Functoid("Lambda_emf->"+name)
 	{_G();
 	    this->_name = emf_name;
-	    this->_method_function = cur_method->_chainable_method_function;
-	    ASSERTF(this->_method_function->getLambdaListHandler().notnilp(),BF("The method-function should never have a nil LambdaListHandler"));
-	    // Calculate the function to call with call_next_method
-	    // Do this by recursively calling gf->compute_effective_method_function with next_methods
-	    if ( next_methods.nilp() )
-	    {
-		this->_next_emfun = _Nil<Function_O>();
-	    } else
-	    {
-		this->_next_emfun = gf->compute_effective_method_function(next_methods);
-	    }
+	    this->_method_function = cur_method->_method_builtin;
 	}
 
-	virtual T_mv activate(const_ActivationFrame_spREF frame)
+#if 0
+	// This is the diff of the new activate with the old activate - get rid of this once everything works
+-	virtual T_mv activate(const_ActivationFrame_spREF frame)
++	virtual T_mv activate( const_ActivationFrame_spREF closedEnv,int nargs, ArgArray args )
+ 	{
+ 	    // TODO:: Here I'm converting the ActivationFrame back into a Cons and passing it
+ 	    // as the first argument to the _method_function and the second argument is _next_emfun
+ 	    // I should pass (frame) within (method_function_args) [an ActivationFrame within an ActivationFrame ]
+ 	    // Then I don't need to convert it back into an activation frame on the receiving end
+-	    ValueFrame_sp method_function_args(ValueFrame_O::create_fill(frame,this->_next_emfun,_Nil<ActivationFrame_O>()));
+-	    return this->_method_function->INVOKE(method_function_args);
+-	    
++	    ValueFrame_sp method_function_args(ValueFrame_O::create_fill(_Nil<ActivationFrame_O>(),frame,this->_next_emfun));
++	    return this->_method_function->INVOKE(nargs,args);	    
+#endif
+	virtual T_mv activate( const_ActivationFrame_spREF closedEnv,int nargs, ArgArray args )
 	{
-	    // TODO:: Here I'm converting the ActivationFrame back into a Cons and passing it
-	    // as the first argument to the _method_function and the second argument is _next_emfun
-	    // I should pass (frame) within (method_function_args) [an ActivationFrame within an ActivationFrame ]
-	    // Then I don't need to convert it back into an activation frame on the receiving end
-	    ValueFrame_sp method_function_args(ValueFrame_O::create_fill(frame,this->_next_emfun,_Nil<ActivationFrame_O>()));
-	    return this->_method_function->INVOKE(method_function_args);
-	    
+	    // The closedEnv 
+	    ASSERTF(closedEnv.nilp(),BF("Since I don't pass the closedEnv forward it I expect that it should always be nil - this time it wasn't - figure out what is up with that"));
+	    return this->_method_function->INVOKE(nargs,args);	    
 	}
     };
 
@@ -266,13 +237,9 @@
 
 
 
-    Function_sp SingleDispatchGenericFunction_O::compute_effective_method_function(Cons_sp applicable_methods)
+    Function_sp SingleDispatchGenericFunction_O::compute_effective_method_function(SingleDispatchMethod_sp applicable_method)
     {_OF();
-	if ( applicable_methods.nilp() )
-	{
-	    SIMPLE_ERROR(BF("You cannot compute_effective_method_function for gf[%s] because there are no methods!") % _rep_(this->getFunctionName()) );
-	}
-	SingleDispatchMethod_sp cur_method = oCar(applicable_methods).as<SingleDispatchMethod_O>();
+	SingleDispatchMethod_sp cur_method = applicable_method;
 	ASSERTF(cur_method.notnilp(),BF("There is no method to compute_effective_method_function for"));
 	// Construct a name for the emf by stringing together the generic function name
 	// with the name of the receiver class - this is to help with debugging
@@ -284,11 +251,11 @@
 	string receiverClassName = receiverClassNameSymbol->symbolNameAsString();
 	emf_name_ss << gfname << "->" << receiverClassName;
 	Symbol_sp emf_name = _lisp->intern(emf_name_ss.str(),af_functionBlockName(this->getFunctionName())->getPackage());
-	Lambda_emf* l_emf = _NEW_(Lambda_emf(emf_name_ss.str(),this->sharedThis<SingleDispatchGenericFunction_O>(),
-					     emf_name, cur_method,cCdr(applicable_methods)));
-	CompiledBody_sp cb_l_emf = CompiledBody_O::create(l_emf,_Nil<T_O>(),_lisp);
+	Lambda_emf* l_emf = new Lambda_emf(emf_name_ss.str(),this->sharedThis<SingleDispatchGenericFunction_O>(),
+					     emf_name, cur_method);
+	CompiledBody_sp cb_l_emf = CompiledBody_O::create(l_emf,_Nil<T_O>());
 	Function_sp emf = BuiltIn_O::create(emf_name,
-					    _Nil<LambdaListHandler_O>(),
+					    _Nil<LambdaListHandler_O>(),// LambdaListHandler_O::create(method_llh->numberOfLexicalVariables()), // _Nil<LambdaListHandler_O>(),
 					    cb_l_emf,
 					    _Nil<ActivationFrame_O>(),
 					    kw::_sym_function );
Index: singleDispatchGenericFunction.h
===================================================================
--- singleDispatchGenericFunction.h	(revision 4737)
+++ singleDispatchGenericFunction.h	(working copy)
@@ -42,14 +42,10 @@
 
 	/*! Store the effective method functions hashed on the receiver class */
 	HashTable_sp	_classes_to_emf_table;
-	/*! Store the LambdaListHandler for this GenericFunction */
-	LambdaListHandler_sp 	_lambdaListHandler;
     private:
-	/*! Invoke the function which looks up the method combination for the
-	  class of the first argument or it creates one */
-	T_mv INVOKE(const_ActivationFrame_spREF args);
+	T_mv INVOKE(int nargs, ArgArray args);
     public:
-	static SingleDispatchGenericFunction_sp create(T_sp functionName, LambdaListHandler_sp llhandler, int dispatch_on_required_argument_index, Lisp_sp lisp);
+	static SingleDispatchGenericFunction_sp create(T_sp functionName, LambdaListHandler_sp llhandler, int dispatch_on_required_argument_index);
     public: // Functions here
 
 	/*! Return the index of the required argument that is dispatched on */
@@ -66,7 +62,7 @@
 	Function_sp slow_method_lookup(Class_sp mc);
 
 	/*! Calculate and effective method function */
-	Function_sp compute_effective_method_function(Cons_sp methods);
+	Function_sp compute_effective_method_function(SingleDispatchMethod_sp method);
 
 	/*! Return the Cons of methods attached to this SingleDispatchGenericFunction */
 	Cons_sp methods() const { return this->_Methods;};
@@ -86,9 +82,9 @@
 	SingleDispatchGenericFunction_sp 	_sdgf;
     public:
 	virtual string describe() const {return "SingleDispatchGenericFunctoid";};
-	virtual T_mv activate(const_ActivationFrame_spREF frame)
+	virtual T_mv activate( const_ActivationFrame_spREF closedEnv,int nargs, ArgArray args )
 	{
-	    return this->_sdgf->INVOKE(frame);
+	    return this->_sdgf->INVOKE(nargs,args);
 	}
     };
 
Index: singleDispatchMethod.cc
===================================================================
--- singleDispatchMethod.cc	(revision 4737)
+++ singleDispatchMethod.cc	(working copy)
@@ -127,33 +127,17 @@
 
 	/*! The argument list is: (args next-emfun)
 	  Use next-emfun to set up a FunctionValueEnvironment that defines call-next-method and next-method-p */
-	T_mv activate(const_ActivationFrame_spREF args)
+	T_mv activate( const_ActivationFrame_spREF closedEnv, int nargs, ArgArray args)
 	{_G();
+#if 0
 	    ASSERTF(this->_method->_body.notnilp(),BF("The method body should never by nil"));
 // TODO: Make this more efficient - this is crazy to put the arguments into a Cons and then
 // into an ActivationFrame and then back into a Cons for each method call - or am I really doing that?
 // Sep 21 2012
 	    // First argument is an ActivationFrame_sp
-	    ActivationFrame_sp function_args = args->entry(0).as<ActivationFrame_O>();
-	    Function_sp next_emfun = args->entry(1).as<Function_O>();
+	    ActivationFrame_sp function_args = args[0].as<ActivationFrame_O>();
+	    Function_sp next_emfun = args[1].as<Function_O>();
 	    
-	    //
-	    // Build a FunctionValueEnvironment that stores call-next-method and next-method-p
-	    //
-#if 0
-	    SYMBOL_EXPORT_SC_(ClPkg,call_next_method);
-	    SYMBOL_EXPORT_SC_(ClPkg,next_method_p);
-	    // I'm going to ignore the call_next_method and next_method_p stuff because C++ will handle this
-	    FunctionValueEnvironment_sp funcEnv = FunctionValueEnvironment_O::create(_Nil<Symbol_O>(),this->_method->_environment,_lisp);
-	    CompiledBody_sp cb_call_next_method = CompiledBody_O::create(_NEW_(Lambda_call_next_method(this->_method->_name,function_args,next_emfun)),_lisp);
-	    Function_sp fp_call_next_method = Function_O::make(cl::_sym_call_next_method,this->_method->method_lambda_list_handler(),cb_call_next_method);
-	    CompiledBody_sp cb_next_method_p = CompiledBody_O::create(_NEW_(Lambda_next_method_p(next_emfun)),_lisp);
-	    Function_sp fp_next_method_p = Function_O::make(cl::_sym_next_method_p,LambdaListHandler_O::create(0,_Nil<Environment_O>(),_lisp),cb_next_method_p);
-
-	    funcEnv->extend_function(cl::_sym_call_next_method,fp_call_next_method);
-	    funcEnv->extend_function(cl::_sym_next_method_p,fp_next_method_p);
-#endif
-	    // 
 	    // At this point I have a new environment that defines
 	    // the local function call-next-method
 	    // and the local function next-method-p
@@ -208,18 +192,22 @@
 		this->_temporary_function = tempFunc;
 	    }
 #endif
-	    return eval::apply(this->_temporary_function,function_args);
-	    // At this point tempFunc will fall out of scope and be dtor'd 
-	    // is that the cost of doing business?
+#endif
+	    Functoid* functoid = this->_method->_body->functoid();
+	    ValueFrame_sp frame(ValueFrame_O::createForLambdaListHandler(this->_method->_argument_handler,_Nil<ActivationFrame_O>()));
+	    ActivationFrameDynamicScopeManager scope(frame);
+	    this->_method->_argument_handler->createBindingsInScope_argArray(nargs,args,scope);
+//	    DBG_HOOK(BF("Check the new arguments"));
+	    return functoid->activate(_Nil<ActivationFrame_O>(),frame->length(),frame->argArray());
 	}
-
     };
 
 
 
 
 
-    SingleDispatchMethod_sp SingleDispatchMethod_O::create(Symbol_sp name, Class_sp receiverClass,
+    SingleDispatchMethod_sp SingleDispatchMethod_O::create(Symbol_sp name,
+							   Class_sp receiverClass,
 							   LambdaListHandler_sp llh,
 							   Cons_sp declares,
 							   Str_sp docstr,
@@ -235,16 +223,14 @@
 	method->_argument_handler = llh;
 	method->_declares = declares;
 	method->_docstring = docstr;
-	method->_can_be_redefined = true;
 	// method->_Function this is what we need to set up NOW.
 	// -- this function has to accept two arguments: (args next-emfun)
 	// So it's a chainable methoid, it can be called with a next-emfun argument
 	// which can be called by applying arguments to the local function "call-next-method"
-	CompiledBody_sp cb_method_function_primitive = CompiledBody_O::create(_NEW_(Lambda_method_function(name->fullName(),method)),_Nil<T_O>(),_lisp);
-	LambdaListHandler_sp llh_two_arguments = LambdaListHandler_O::create(2);
-	llh_two_arguments->setComment("Created in SingleDispatchMethod_O::create - chainable method - handles 2 arguments ");
-	method->_chainable_method_function = BuiltIn_O::make(name,llh_two_arguments,cb_method_function_primitive);
-
+	Functoid* method_functoid = new Lambda_method_function(name->fullName(),method);
+	CompiledBody_sp cb_method_function_primitive = CompiledBody_O::create(method_functoid,_Nil<T_O>());
+	LambdaListHandler_sp llh_pass_arguments_through(_Nil<LambdaListHandler_O>());
+	method->_method_builtin = BuiltIn_O::make(name,llh_pass_arguments_through,cb_method_function_primitive);
 	return method;
     }
 
@@ -257,45 +243,6 @@
 
 
 
-
-
-    
-    
-    ::core::T_sp SingleDispatchMethod_O::__init__(::core::Function_sp exec, ::core::Cons_sp args, ::core::Environment_sp env, ::core::Lisp_sp lisp)
-    {_G();
-//      this->!Base::__init__(exec,args,env,lisp);
-//      arg = translate::from_object<XXXX>::convert(env->lookup(this->Package(),"YYY"));
-	return _Nil<T_O>();
-    }
-    
-#if 0
-#if defined(OLD_SERIALIZE)
-    void SingleDispatchMethod_O::serialize(::serialize::SNodeP node)
-    {
-	IMPLEMENT_ME();
-        this->Bases::serialize(node);
-	// Archive other instance variables here
-    }
-#endif
-    
-#if defined(XML_ARCHIVE)
-    void SingleDispatchMethod_O::archiveBase(::core::ArchiveP node)
-    {
-	IMPLEMENT_ME();
-        this->Base1::archiveBase(node);
-	// Archive other instance variables here
-    }
-#endif // defined(XML_ARCHIVE)
-#endif
-    
-    
-    void SingleDispatchMethod_O::initialize()
-    {_OF();
-        this->Base::initialize();
-	this->_can_be_redefined = true;
-    }
-
-
     string SingleDispatchMethod_O::__repr__() const
     {
 	stringstream ss;
@@ -303,7 +250,7 @@
 	   << " :name " << _rep_(this->_name)
 	   << " :receiver-class " << _rep_(this->_receiver_class)
 	   << " :body " << _rep_(this->_body)
-	   << " :method_function " << _rep_(this->_chainable_method_function)
+	   << " :method_builtin " << _rep_(this->_method_builtin)
 	   << " >";
 	return ss.str();
     }
Index: singleDispatchMethod.h
===================================================================
--- singleDispatchMethod.h	(revision 4737)
+++ singleDispatchMethod.h	(working copy)
@@ -21,9 +21,6 @@
 	friend class Lambda_method_function;
     public: // Simple default ctor/dtor
 	DEFAULT_CTOR_DTOR(SingleDispatchMethod_O);
-    public:
-	void initialize();
-	
     private: // instance variables here
 		/*! Store the generic function name */
 	Symbol_sp	_name;
@@ -31,19 +28,12 @@
 	Class_sp	_receiver_class;
 	/*! Store the body of the method */
 	CompiledBody_sp		_body;
-	/*! Store the computed function for this method - this
-	  takes two arguments: (args next-emfun)
-	  (args) is the list of arguments passed to the method (first argument is the receiver)
-	  (next-emfun) is the next effective method function called with call-next-method.
-	*/
-	Function_sp	_chainable_method_function;
+	BuiltIn_sp	_method_builtin;
+	/*! This is the LambdaListHandler for the Builtin method */
 	LambdaListHandler_sp	_argument_handler;
 	Cons_sp 	_declares;
 	/*! Store the docstring */
 	Str_sp		_docstring;
-	/*! Store whether the method can be redefined */
-	bool		_can_be_redefined;
-
     public: // creation function
 	// The creates above are depreciated
 	static SingleDispatchMethod_sp create(Symbol_sp name,
@@ -51,14 +41,10 @@
 					      LambdaListHandler_sp lambda_list_handler,
 					      Cons_sp declares, Str_sp docstr,
 					      CompiledBody_sp body );
-
-
     public: // Functions here
 
 	Class_sp receiver_class() const { return this->_receiver_class; };
 	LambdaListHandler_sp method_lambda_list_handler() const { return this->_argument_handler;};
-	bool can_be_redefined() const { return this->_can_be_redefined;};
-
 	string __repr__() const;
 
 
Index: smart_pointers.h
===================================================================
--- smart_pointers.h	(revision 4737)
+++ smart_pointers.h	(working copy)
@@ -7,6 +7,10 @@
 #ifndef	_core_smart_pointers_H
 #define	_core_smart_pointers_H
 
+
+//#define POLYMORPHIC_SMART_PTR
+
+
 #include <boost/utility/binary.hpp>
 
 #include <iostream>
@@ -36,6 +40,9 @@
 
 
 
+#define	TAGGED_PTR core::T_O*
+
+
 namespace mem
 {
 
@@ -72,6 +79,7 @@
 	explicit smart_ptr(uintptr_t p) : BaseType(p) {}; // TODO: this converts ints to smart_ptr's - its dangerous
 	smart_ptr( T* objP) : BaseType(objP) {};
 	smart_ptr(const smart_ptr<T>& obj) : BaseType(obj) {};
+	smart_ptr(int f) : BaseType(f) {};
 	template <class Y> smart_ptr(const smart_ptr<Y>& yy) : BaseType(yy) {} ; //.get()) {};
 //	template <class Y> smart_ptr(const smart_ptr<const Y>& yy) : BaseType(/*const_cast<T*>*/(yy.pxget())) {} ; //.get()) {};
 #if defined(USE_MPS)
@@ -82,7 +90,25 @@
 	/*! Get the pointer typcast to an integer quantity for hashing */
 	cl_intptr_t intptr() const { return ((uintptr_t)(this->px));};
 
+
+	/*! Cast the px pointer to T_O* */
+	TAGGED_PTR _T() const { return static_cast<TAGGED_PTR>(this->px);};
+
 	template <class o_class>
+	inline smart_ptr<o_class> pointerAsUnsafe()
+	{
+	    o_class* new_px = dynamic_cast<o_class*>(this->px);
+	    return smart_ptr<o_class>(new_px);
+	}
+
+	template <class o_class>
+	inline smart_ptr<o_class> pointerAsUnsafe() const
+	{
+	    o_class* new_px = dynamic_cast<o_class*>(this->px);
+	    return smart_ptr<o_class>(new_px);
+	}
+
+	template <class o_class>
 	inline smart_ptr<o_class> asOrNull()
 	{
 	    /*! this->nilp() should only return nil for Null_O,Symbol_O,List_O,Sequence_O */
@@ -90,6 +116,9 @@
 		smart_ptr<o_class> ret(dynamic_cast<o_class*>(this->px));
 		return ret;
 	    }
+	    if ( this->BaseType::fixnump()) {
+		return smart_ptr<o_class>(reinterpret_cast<uintptr_t>(this->px));
+	    }
 	    if ( this->nilp()
 #if 0  // everything downcasts to nil
 		 && isNilDowncastableTo<o_class>()
@@ -106,6 +135,7 @@
 	    // unreachable
 	    smart_ptr<o_class> fail;
 	    return fail;
+
 	}
 
 
@@ -116,7 +146,10 @@
 		smart_ptr</* TODO: const */ o_class> ret(const_cast<o_class*>(dynamic_cast<const o_class*>(this->px)));
 		return ret;
 	    }
-// SYMBOL, LIST, SEQUENCE,NULL can downcast nil 
+	    if ( this->BaseType::fixnump()) {
+		return smart_ptr<o_class>(reinterpret_cast<uintptr_t>(this->px));
+	    }
+
 	    if ( this->nilp()
 #if 0  // everything downcasts to nil
 		 && isNilDowncastableTo<o_class>()
@@ -137,6 +170,14 @@
 
 
 
+
+
+
+
+
+
+
+
 	template <class o_class>
 	inline smart_ptr<o_class> as()
 	{
@@ -220,7 +261,10 @@
 	  of smart_ptr to make px protected */
 	int size_of_px() const { return sizeof(this->px); };
 
-	virtual int number_of_values() const { return this->get() ? 1 : 0;};
+#ifdef POLYMORPHIC_SMART_PTR
+	virtual
+#endif
+	int number_of_values() const { return this->_NULLp() ? 0 : 1;};
 
 	bool notnilp() const { return (!this->nilp());};
 	bool isTrue() const { return (!this->nilp() || internal_isTrue(this)); };
@@ -228,9 +272,43 @@
 	bool characterp() const {return lisp_characterP(*this);};
 
 
+#ifdef POLYMORPHIC_SMART_PTR
 	virtual ~smart_ptr() {};
+#endif
     };
 
+
+    };
+
+template <class T>
+mem::smart_ptr<T> _NULL()
+{
+    mem::smart_ptr<T> x(mem::smart_ptr<T>::BaseType::tagged_NULL);
+    return x;
+}
+
+template <class T>
+mem::smart_ptr<T> _Nil()
+{
+    mem::smart_ptr<T> x(mem::smart_ptr<T>::BaseType::tagged_nil);
+    return x;
+}
+
+
+template <class T>
+mem::smart_ptr<T> _Unbound()
+{
+    mem::smart_ptr<T> x(mem::smart_ptr<T>::BaseType::tagged_unbound);
+    return x;
+}
+
+
+template <class T>
+inline bool Null(const mem::smart_ptr<T>& ptr) { return ptr.nilp();};
+
+
+namespace mem {
+
 // LambdaListHandler_sp llh(ptr)
 
     template <class T>
@@ -252,7 +330,13 @@
 	weak_smart_ptr(T* objP) : BaseType(objP) {} ;
 	template <class Y> weak_smart_ptr(const smart_ptr<Y>& yy) : BaseType(yy) {} ;
 	template <class Y> weak_smart_ptr(const weak_smart_ptr<Y>& yy) : BaseType(yy) {} ;
-	smart_ptr<T> lock() const {return smart_ptr<T>(this->get());}
+	bool notnilp() const { return (!this->nilp());};
+	smart_ptr<T> lock() const
+	{
+	    if ( this->nilp() ) return _Nil<T>();
+	    if ( this->unboundp() ) return _Unbound<T>();
+	    return smart_ptr<T>(this->get());
+	}
 	virtual int number_of_values() const {return 1;};
 	virtual ~weak_smart_ptr() {};
     };
@@ -311,35 +395,9 @@
 };
 
 
-template <class T>
-mem::smart_ptr<T> _NULL()
-{
-    mem::smart_ptr<T> x(mem::smart_ptr<T>::BaseType::tagged_NULL);
-    return x;
-}
 
-template <class T>
-mem::smart_ptr<T> _Nil()
-{
-    mem::smart_ptr<T> x(mem::smart_ptr<T>::BaseType::tagged_nil);
-    return x;
-}
 
 
-template <class T>
-mem::smart_ptr<T> _Unbound()
-{
-    mem::smart_ptr<T> x(mem::smart_ptr<T>::BaseType::tagged_unbound);
-    return x;
-}
-
-
-template <class T>
-inline bool Null(const mem::smart_ptr<T>& ptr) { return ptr.nilp();};
-
-
-
-
 #endif
 
 
Index: specialForm.cc
===================================================================
--- specialForm.cc	(revision 4737)
+++ specialForm.cc	(working copy)
@@ -26,9 +26,9 @@
 }
 
 
-SpecialForm_sp SpecialForm_O::create(Symbol_sp symbol, SpecialFormCallback fptr, Lisp_sp env )
+SpecialForm_sp SpecialForm_O::create(Symbol_sp symbol, SpecialFormCallback fptr )
 {
-    SpecialForm_sp sf = env->create<SpecialForm_O>();
+    SpecialForm_sp sf = SpecialForm_O::create();
     sf->_SpecialSymbol = symbol;
     sf->_fptr = fptr;
     return sf;
Index: specialForm.h
===================================================================
--- specialForm.h	(revision 4737)
+++ specialForm.h	(working copy)
@@ -33,7 +33,7 @@
 	Symbol_sp		_SpecialSymbol;
 	SpecialFormCallback	_fptr;
 public:
-    static SpecialForm_sp create(Symbol_sp symbol, SpecialFormCallback cb, Lisp_sp);
+    static SpecialForm_sp create(Symbol_sp symbol, SpecialFormCallback cb);
 public:	// initialize
 
 	virtual bool isSpecialForm() { return true;};
Index: specializer.h
===================================================================
--- specializer.h	(revision 4737)
+++ specializer.h	(working copy)
@@ -25,8 +25,6 @@
 	LISP_CLASS(core,CorePkg,Specializer_O,"specializer");
     public:
 
-	Specializer_O( const Specializer_O& ss ); //!< Copy constructor
-
 	explicit Specializer_O();
 	virtual ~Specializer_O();
     };
Index: stacks.cc
===================================================================
--- stacks.cc	(revision 4739)
+++ stacks.cc	(working copy)
@@ -119,35 +119,31 @@
     }
 
 
-    CxxFunctionIHF::CxxFunctionIHF(IHFLeafKind kind, InvocationHistoryStack& stack, const char* sourceFilePath, const char* functionName, uint lineNumber, ActivationFrame_sp af, Function_sp func)
-	: InvocationHistoryFrame(kind,stack), _SourceFilePath(sourceFilePath), _FunctionName(functionName), _LineNumber(lineNumber), _ActivationFrame(af), _Function(func) {};
-
     CxxFunctionIHF::~CxxFunctionIHF() {};
 
-    void CxxFunctionIHF::setLineNumberColumnForCxxFunction(uint lineno, uint column, const char* functionName)
+
+    string CxxFunctionIHF::sourcePathName() const
     {
-	if ( this->_FunctionName == NULL )
-	{
-	    this->_FunctionName = functionName;
-	}
-	if ( this->_FunctionName == functionName ) // Can I use pointer identity for __FUNCTION__???
-	{
-	    this->_LineNumber = lineno;
-	}
+	return af_sourceFileInfo(this->_Function)->namestring();
     }
 
 
     string CxxFunctionIHF::asString() const
     {
-	return this->asStringLowLevel(this->typeName(),this->_FunctionName,this->_SourceFilePath,this->_LineNumber,0);
+	return this->asStringLowLevel(this->typeName(),_rep_(this->_Function->getFunctionName()),af_sourceFileInfo(this->_Function)->fileName(),this->_LineNumber,0);
     }
 
 
     void CxxFunctionIHF::setActivationFrame(ActivationFrame_sp af)
     {_G();
-	SIMPLE_ERROR(BF("CxxFunctionIHF::setActivationFrame should never be called"));
+	// Do nothing
     }
 
+    ActivationFrame_sp CxxFunctionIHF::activationFrame() const {
+	return _Nil<ActivationFrame_O>();
+//	IMPLEMENT_MEF(BF("Switch to ArgArray"));
+    }
+
     LispFunctionIHF::LispFunctionIHF(IHFLeafKind kind, InvocationHistoryStack& stack, Function_sp function)
 	: InvocationHistoryFrame(kind,stack),
 	  _Function(function),
Index: stacks.h
===================================================================
--- stacks.h	(revision 4739)
+++ stacks.h	(working copy)
@@ -113,25 +113,25 @@
     {
 	friend class InvocationHistoryStack;
     protected:
-	const char* 	_SourceFilePath;
-	const char*	_FunctionName;
-	uint		_LineNumber;
-	ActivationFrame_sp 	_ActivationFrame;
 	Function_sp 	_Function;
+	int			_Nargs;
+	ArgArray		_Args;
+	uint			_LineNumber;
     public:
-	CxxFunctionIHF(IHFLeafKind kind, InvocationHistoryStack& stack, const char* sourceFilePath, const char* functionName, uint lineNumber, ActivationFrame_sp af, Function_sp func);
+	CxxFunctionIHF(InvocationHistoryStack& stack, Function_sp function ) : InvocationHistoryFrame(CxxFunction,stack), _Function(function), _Nargs(0), _Args(NULL), _LineNumber(0) {};
+	CxxFunctionIHF(InvocationHistoryStack& stack, Function_sp function, int nargs, ArgArray args ) : InvocationHistoryFrame(CxxFunction,stack), _Function(function), _Nargs(nargs), _Args(args), _LineNumber(0) {};
 	virtual ~CxxFunctionIHF();
-	virtual void setLineNumberColumnForCxxFunction(uint lineNumber, uint column, const char* functionName);
+//	virtual void setLineNumberColumnForCxxFunction(uint lineNumber, uint column, const char* functionName);
 
 	void setLineNumberColumn(uint lineNumber, uint column)
 	{
 	    this->_LineNumber = lineNumber;
 	}
 	void setActivationFrame(ActivationFrame_sp af);
-	ActivationFrame_sp activationFrame() const { return this->_ActivationFrame;};
+	ActivationFrame_sp activationFrame() const;
 	virtual string typeName() const { return "      C++";};
 	virtual string asString() const;
-	virtual string sourcePathName() const { return this->_SourceFilePath;};
+	virtual string sourcePathName() const;
 	virtual int lineNumber() const {return this->_LineNumber;};
 	virtual int column() const {return 1;};
 	virtual Function_sp function() const { return this->_Function;};
@@ -180,8 +180,8 @@
     {
 	friend class InvocationHistoryStack;
     public:
-	MacroExpansionIHF(InvocationHistoryStack& stack, Function_sp function, ActivationFrame_sp af )
-	    : LispFunctionIHF(MacroExpansionFunction,stack, function, af ) {};
+	MacroExpansionIHF(InvocationHistoryStack& stack, Function_sp function )
+	    : LispFunctionIHF(MacroExpansionFunction,stack, function ) {};
 	virtual ~MacroExpansionIHF() {};
 	virtual string asString() const;
 	virtual string typeName() const { return "Macro.Lisp";};
Index: standardObject.h
===================================================================
--- standardObject.h	(revision 4737)
+++ standardObject.h	(working copy)
@@ -52,8 +52,6 @@
 //	void setInstanceVariableValue(Symbol_sp sym, T_sp obj);
 //	T_sp getInstanceVariableValue(Symbol_sp sym);
 	
-	StandardObject_O( const StandardObject_O& ss ); //!< Copy constructor
-
 	explicit StandardObject_O();
 	virtual ~StandardObject_O();
 };
Index: str.cc
===================================================================
--- str.cc	(revision 4738)
+++ str.cc	(working copy)
@@ -20,7 +20,7 @@
 
     string str_get(Str_sp str) { return str->get(); };
     string str_get(T_sp str) { return str.as<Str_O>()->get(); };
-    T_sp str_create(const string& str, Lisp_sp lisp) { return Str_O::create(str);};
+    T_sp str_create(const string& str) { return Str_O::create(str);};
     T_sp str_create(const char* str) { return Str_O::create(str);};
 
 
@@ -217,9 +217,11 @@
 	{
 	    bn = (bn<<7) | ((*cp) & 0x7f);
 	}
+#if 0
 	stringstream ss;
 	ss << bn;
 	LOG(BF("stringToBignum string[%s] bignum[%s]") % str % ss.str() ); 
+#endif
 	return bn;
     }
 	
@@ -464,7 +466,6 @@
 		.def("split", &Str_O::split)
 		.def("concat", &Str_O::concat)
 		.def("splitAtWhiteSpace", &Str_O::splitAtWhiteSpace)
-		.def("split-at-white-space", &Str_O::splitAtWhiteSpace)
 		.def("schar",&Str_O::schar)
 //		.def_raw("format", &Str_O::prim_format)
 //		.def_raw("%", &Str_O::prim_format)
Index: str.fwd.h
===================================================================
--- str.fwd.h	(revision 4737)
+++ str.fwd.h	(working copy)
@@ -12,7 +12,7 @@
     string str_get(Str_sp str);
 
     /*! Create a Str_O object */
-    T_sp str_create(const string& val, Lisp_sp lisp);
+    T_sp str_create(const string& val);
 
     /*! Create a Str_O object from a const char* */
     T_sp str_create(const char* val);
Index: stringList.h
===================================================================
--- stringList.h	(revision 4737)
+++ stringList.h	(working copy)
@@ -64,9 +64,6 @@
 	boost::python::list	python_asList();
 #endif
 
-	StringList_O( const StringList_O& ss ); //!< Copy constructor
-
-
 	DEFAULT_CTOR_DTOR(StringList_O);
     };
 
Index: stringSet.cc
===================================================================
--- stringSet.cc	(revision 4737)
+++ stringSet.cc	(working copy)
@@ -10,9 +10,11 @@
 #include "object.h"
 #include "lisp.h"
 #include "stringSet.h"
+#include "symbolTable.h"
 #include "multipleValues.h"
 #include "stringList.h"
 #include "str.h"
+#include "serialize.h"
 #include "cons.h"
 #include "numbers.h"
 #include "wrappers.h"
@@ -23,11 +25,11 @@
 
 
 /*
-__BEGIN_DOC(classes.StringSet.!class.StringSet)
-\requiredKeyed{entries:}{Cons::listOfStrings}
+  __BEGIN_DOC(classes.StringSet.!class.StringSet)
+  \requiredKeyed{entries:}{Cons::listOfStrings}
 
-Create a StringSet containing the strings in \sa{listOfStrings}.
-__END_DOC
+  Create a StringSet containing the strings in \sa{listOfStrings}.
+  __END_DOC
 */
 
 #if 0
@@ -43,93 +45,102 @@
 #endif
 
 
-StringSet_sp StringSet_O::insertConsStrings(Cons_sp vals)
-{
-    for ( Cons_sp p=vals; p.notnilp(); p=cCdr(p))
+    StringSet_sp StringSet_O::insertConsStrings(Cons_sp vals)
     {
-        Str_sp t = oCar(p).as<Str_O>();
-	this->insert(t->get());
+	for ( Cons_sp p=vals; p.notnilp(); p=cCdr(p))
+	{
+	    Str_sp t = oCar(p).as<Str_O>();
+	    this->insert(t->get());
+	}
+	return this->sharedThis<StringSet_O>();
     }
-    return this->sharedThis<StringSet_O>();
-}
 
-void	StringSet_O::insertVectorStrings(VectorStrings s )
-{
-VectorStrings::iterator	i;
-    for ( i=s.begin(); i!= s.end(); i++ ) {
-	this->insert(*i);
+    void	StringSet_O::insertVectorStrings(VectorStrings s )
+    {
+	VectorStrings::iterator	i;
+	for ( i=s.begin(); i!= s.end(); i++ ) {
+	    this->insert(*i);
+	}
     }
-}
 
-void	StringSet_O::insertStringSet(StringSet_sp s)
-{
-set<string>::iterator	si;
-    for ( si=s->strs.begin(); si!= s->strs.end(); si++ ) {
-	this->insert(*si);
+
+
+    void	StringSet_O::insertStringSet(StringSet_sp s)
+    {
+	set<string>::iterator	si;
+	for ( si=s->strs.begin(); si!= s->strs.end(); si++ ) {
+	    this->insert(*si);
+	}
     }
-}
 
-void	StringSet_O::insertStringList(StringList_sp s)
-{
-StringList_O::iterator	si;
-    for ( si=s->begin(); si!= s->end(); si++ ) {
-	this->insert(*si);
+    void	StringSet_O::insertStringList(StringList_sp s)
+    {
+	StringList_O::iterator	si;
+	for ( si=s->begin(); si!= s->end(); si++ ) {
+	    this->insert(*si);
+	}
     }
-}
 
 
-StringSet_sp	StringSet_O::copy()
-{_G();
-    StringSet_O::iterator	it;
-    GC_COPY(StringSet_O,snew,this);
-    snew->clear();
-    for ( it=this->begin(); it!=this->end(); it++ ) snew->insert(*it);
-    return snew;
-}
+    StringSet_sp	StringSet_O::copy()
+    {_G();
+	StringSet_O::iterator	it;
+	GC_COPY(StringSet_O,snew,this);
+	snew->clear();
+	for ( it=this->begin(); it!=this->end(); it++ ) snew->insert(*it);
+	return snew;
+    }
 
-string	StringSet_O::__repr__() const
-{
-stringstream 		ss;
-set<string>::iterator	si;
-string			nm;
-    ss.str("");
-    for ( si = this->strs.begin(); si!=this->strs.end(); si++ ) {
-	if ( si!=this->strs.begin() ) {
-	    ss << " ";
+    string	StringSet_O::__repr__() const
+    {
+	stringstream 		ss;
+	set<string>::iterator	si;
+	string			nm;
+	ss.str("");
+	for ( si = this->strs.begin(); si!=this->strs.end(); si++ ) {
+	    if ( si!=this->strs.begin() ) {
+		ss << " ";
+	    }
+	    ss << *si;
 	}
-	ss << *si;
+	return ss.str();
     }
-    return ss.str();
-}
-string	StringSet_O::asString()
-{
-stringstream 		ss;
-set<string>::iterator	si;
-string			nm;
-    ss.str("");
-    for ( si = this->strs.begin(); si!=this->strs.end(); si++ ) {
-	if ( si!=this->strs.begin() ) {
-	    ss << " ";
+    string	StringSet_O::asString()
+    {
+	stringstream 		ss;
+	set<string>::iterator	si;
+	string			nm;
+	ss.str("");
+	for ( si = this->strs.begin(); si!=this->strs.end(); si++ ) {
+	    if ( si!=this->strs.begin() ) {
+		ss << " ";
+	    }
+	    ss << *si;
 	}
-	ss << *si;
+	return ss.str();
     }
-    return ss.str();
-}
 
 
-#if defined(XML_ARCHIVE)
-void	StringSet_O::archiveBase(ArchiveP node)
-{
-    if ( node->loading() ) {
-	VectorStrings		vstrs;
-	node->getDataAsVectorOfStrings(vstrs);
-	this->strs.clear();
-	this->insertVectorStrings(vstrs);
-    } else {
-        node->setCharacters(this->asString());
+    void	StringSet_O::archiveBase(ArchiveP node)
+    {
+	if ( node->loading() ) {
+	    Vector_sp vec = node->getVectorSNodes();
+	    this->strs.clear();
+	    for ( int i(0),iEnd(vec->length()); i<iEnd; ++i ) {
+		LeafSNode_sp ln = vec->elt(i).as<LeafSNode_O>();
+		this->insert(ln->object().as<Str_O>()->get());
+	    }
+	} else {
+	    VectorObjects_sp vec = VectorObjects_O::create(_Nil<T_O>(),this->strs.size(),cl::_sym_LeafSNode_O);
+	    int i(0);
+	    set<string>::iterator	si;
+	    for ( si = this->strs.begin(); si!=this->strs.end(); si++ ) {
+		vec->setf_elt(i,LeafSNode_O::create(Str_O::create(*si)));
+		++i;
+	    }
+	    node->setVectorSNodesUnsafe(vec);
+	}
     }
-}
-#endif // defined(XML_ARCHIVE)
 
 
 
@@ -137,223 +148,240 @@
 
 
 
-bool	StringSet_O::contains(const string& s)
-{_G();
-bool	ye;
-    ye = this->strs.count(s);
-    return ye;
-}
+    bool	StringSet_O::contains(const string& s)
+    {_G();
+	bool	ye;
+	ye = this->strs.count(s);
+	return ye;
+    }
 
 
-bool	StringSet_O::containsSubset(StringSet_sp sub )
-{
-StringSet_O::iterator	si;
-    for ( si=sub->begin(); si!=sub->end(); si++ ) {
-	if ( !this->contains(*si) ) {
-	    return false;
+    bool	StringSet_O::containsSubset(StringSet_sp sub )
+    {
+	StringSet_O::iterator	si;
+	for ( si=sub->begin(); si!=sub->end(); si++ ) {
+	    if ( !this->contains(*si) ) {
+		return false;
+	    }
 	}
+	return true;
     }
-    return true;
-}
 
 
 
-void	StringSet_O::clear()
-{_OF();
-    LOG(BF("StringSet::clear size=%d") % (this->strs.size() ) );
-    if ( this->strs.size() == 0 ) return;
-    this->strs.clear();
-}
+    void	StringSet_O::clear()
+    {_OF();
+	LOG(BF("StringSet::clear size=%d") % (this->strs.size() ) );
+	if ( this->strs.size() == 0 ) return;
+	this->strs.clear();
+    }
 
 /*! Check if the StringSet contains the same strings as this
  */
-bool	StringSet_O::equal(T_sp obj) const
-{
-    if ( this->eq(obj) ) return true;
-    if ( obj.isA<StringSet_O>() )
+    bool	StringSet_O::equal(T_sp obj) const
     {
-    set<string>::iterator	si;
-        StringSet_sp ss = obj.as<StringSet_O>();
-	if ( this->strs.size() != ss->strs.size() ) return false;
-	for (si=this->strs.begin();si!=this->strs.end();si++)
+	if ( this->eq(obj) ) return true;
+	if ( obj.isA<StringSet_O>() )
 	{
-	    if ( !ss->contains(*si) ) 
+	    set<string>::iterator	si;
+	    StringSet_sp ss = obj.as<StringSet_O>();
+	    if ( this->strs.size() != ss->strs.size() ) return false;
+	    for (si=this->strs.begin();si!=this->strs.end();si++)
 	    {
-		return false;
+		if ( !ss->contains(*si) ) 
+		{
+		    return false;
+		}
 	    }
+	    return true;
 	}
-	return true;
+	return false;
     }
-    return false;
-}
 
 
-void	StringSet_O::remove(const string& s)
-{_OF();
+    void	StringSet_O::remove(const string& s)
+    {_OF();
 #ifdef 	DEBUG_ON
-    if ( this->strs.count(s)!=1 ) {
-	SIMPLE_ERROR(BF("The string: %s was not found in StringSet") % s );
+	if ( this->strs.count(s)!=1 ) {
+	    SIMPLE_ERROR(BF("The string: %s was not found in StringSet") % s );
+	}
+#endif
+	this->strs.erase(s);
     }
-#endif
-    this->strs.erase(s);
-}
 
 
 
 
     void StringSet_O::initialize()
-{
-    this->Base::initialize();
-    this->rest = false;
-}
+    {
+	this->Base::initialize();
+	this->rest = false;
+    }
 
-StringSet_O::StringSet_O(const StringSet_O& ss) : T_O(ss)
-{
-    this->rest = ss.rest;
-    this->strs = ss.strs;
-}
+    StringSet_O::StringSet_O(const StringSet_O& ss) : T_O(ss)
+    {
+	this->rest = ss.rest;
+	this->strs = ss.strs;
+    }
 
 
 
-void	StringSet_O::setFromString( const string& s )
-{_G();
-VectorStrings	words;
-    tokenize(s,words,"\t\n ");
-    this->clear();
-    this->insertVectorStrings(words);
-}
+    void	StringSet_O::setFromString( const string& s )
+    {_G();
+	VectorStrings	words;
+	tokenize(s,words,"\t\n ");
+	this->clear();
+	this->insertVectorStrings(words);
+    }
 
 
 
 
-StringSet_sp	StringSet_O::setUnion(StringSet_sp b)
-{_G();
-StringSet_sp		nset;
-set<string>::iterator	si;
-    nset = StringSet_O::create();
-    for (si=this->strs.begin();si!=this->strs.end();si++){
-	nset->insert(*si);
+    StringSet_sp	StringSet_O::setUnion(StringSet_sp b)
+    {_G();
+	StringSet_sp		nset;
+	set<string>::iterator	si;
+	nset = StringSet_O::create();
+	for (si=this->strs.begin();si!=this->strs.end();si++){
+	    nset->insert(*si);
+	}
+	for (si=b->strs.begin();si!=b->strs.end();si++){
+	    nset->insert(*si);
+	}
+	return nset;
     }
-    for (si=b->strs.begin();si!=b->strs.end();si++){
-	nset->insert(*si);
-    }
-    return nset;
-}
 
 
-StringSet_sp	StringSet_O::intersection(StringSet_sp b)
-{_G();
-StringSet_sp		nset;
-set<string>::iterator	si;
-    nset = StringSet_O::create();
-    for (si=this->strs.begin();si!=this->strs.end();si++){
-	LOG(BF("Looking for(%s)") % (*si).c_str() );
-	if ( b->contains(*si) ) {
-	    LOG(BF("Found it!!!") );
-	    nset->insert(*si);
-	} else {
-	    LOG(BF("Not found") );
+    StringSet_sp	StringSet_O::intersection(StringSet_sp b)
+    {_G();
+	StringSet_sp		nset;
+	set<string>::iterator	si;
+	nset = StringSet_O::create();
+	for (si=this->strs.begin();si!=this->strs.end();si++){
+	    LOG(BF("Looking for(%s)") % (*si).c_str() );
+	    if ( b->contains(*si) ) {
+		LOG(BF("Found it!!!") );
+		nset->insert(*si);
+	    } else {
+		LOG(BF("Not found") );
+	    }
 	}
+	return nset;
     }
-    return nset;
-}
 
 
-StringSet_sp	StringSet_O::relativeComplement(StringSet_sp b)
-{
-StringSet_sp		nset;
-set<string>::iterator	si;
-    nset = StringSet_O::create();
-    for (si=this->strs.begin();si!=this->strs.end();si++){
-	if ( !b->contains(*si) ) {
-	    nset->insert(*si);
+    StringSet_sp	StringSet_O::relativeComplement(StringSet_sp b)
+    {
+	StringSet_sp		nset;
+	set<string>::iterator	si;
+	nset = StringSet_O::create();
+	for (si=this->strs.begin();si!=this->strs.end();si++){
+	    if ( !b->contains(*si) ) {
+		nset->insert(*si);
+	    }
 	}
+	return nset;
     }
-    return nset;
-}
 
 
 /*! Return a new set that takes every element of (this) in combination
-	with every element in b separated by a comma
+  with every element in b separated by a comma
 */
-StringSet_sp	StringSet_O::cartesianProductInsert(string ins, StringSet_sp b)
-{_G();
-StringSet_sp		nset;
-set<string>::iterator	si,bi;
-stringstream		sstr;
-    nset = StringSet_O::create();
-    for (si=this->strs.begin();si!=this->strs.end();si++){
-        for (bi=b->strs.begin();bi!=b->strs.end();bi++){
-	    sstr.str("");
-	    sstr << (*si) << ins << (*bi);
-	    nset->insert(sstr.str());
+    StringSet_sp	StringSet_O::cartesianProductInsert(string ins, StringSet_sp b)
+    {_G();
+	StringSet_sp		nset;
+	set<string>::iterator	si,bi;
+	stringstream		sstr;
+	nset = StringSet_O::create();
+	for (si=this->strs.begin();si!=this->strs.end();si++){
+	    for (bi=b->strs.begin();bi!=b->strs.end();bi++){
+		sstr.str("");
+		sstr << (*si) << ins << (*bi);
+		nset->insert(sstr.str());
+	    }
 	}
+	return nset;
     }
-    return nset;
-}
 
-Cons_sp	StringSet_O::asCons()
-{_G();
-    Cons_sp cur = _Nil<Cons_O>();
-set<string>::iterator	si;
-    for (si=this->strs.begin();si!=this->strs.end();si++){
-	Str_sp s = Str_O::create(*si);
-	cur = Cons_O::create(s,cur,_lisp);
+    Cons_sp	StringSet_O::asCons() const
+    {_G();
+	Cons_sp cur = _Nil<Cons_O>();
+	set<string>::iterator	si;
+	for (si=this->strs.begin();si!=this->strs.end();si++){
+	    Str_sp s = Str_O::create(*si);
+	    cur = Cons_O::create(s,cur);
+	}
+	return cur;
     }
-    return cur;
-}
 
+    Vector_sp StringSet_O::asVector() const
+    {_G();
+	Vector_sp vec = af_make_vector(cl::_sym_Str_O,
+				       this->strs.size() /* dim */,
+				       true /* adjustable */,
+				       brcl_make_fixnum(0) /* fill pointer */ );
+	int i=0;
+	set<string>::iterator	si;
+	for ( si=this->strs.begin();si!=this->strs.end();si++) {
+	    Str_sp s = Str_O::create(*si);
+	    vec->setf_elt(i,s);
+	    ++i;
+	}
+	return vec;
+    }
 
+
+
     void StringSet_O::exposeCando(Lisp_sp lisp)
-{
-    class_<StringSet_O>()
-	.def("size", &StringSet_O::size)
-	.def("insertConsStrings", &StringSet_O::insertConsStrings)
-	.def("insertStringSet", &StringSet_O::insertStringSet)
-	.def("insert",&StringSet_O::insert)
-	.def("contains",&StringSet_O::contains)
-	.def("containsSubset",&StringSet_O::containsSubset)
-	.def("remove",&StringSet_O::remove)
-	.def("clear",&StringSet_O::clear)
-	.def("first",&StringSet_O::first)
-	.def("asString",&StringSet_O::asString)
-	.def("setFromString",&StringSet_O::setFromString)
-	.def("union",&StringSet_O::setUnion)
-	.def("intersection",&StringSet_O::intersection)
-	.def("relativeComplement",&StringSet_O::relativeComplement)
-	.def("removeAll",&StringSet_O::removeAll)
-	.def("cartesianProduct",&StringSet_O::cartesianProduct)
-	.def("cartesianProductInsert",&StringSet_O::cartesianProductInsert)
-	.def("asCons",&StringSet_O::asCons)
-	;
-}
+    {
+	class_<StringSet_O>()
+	    .def("size", &StringSet_O::size)
+	    .def("insertConsStrings", &StringSet_O::insertConsStrings)
+	    .def("insertStringSet", &StringSet_O::insertStringSet)
+	    .def("insert",&StringSet_O::insert)
+	    .def("contains",&StringSet_O::contains)
+	    .def("containsSubset",&StringSet_O::containsSubset)
+	    .def("remove",&StringSet_O::remove)
+	    .def("clear",&StringSet_O::clear)
+	    .def("first",&StringSet_O::first)
+	    .def("asString",&StringSet_O::asString)
+	    .def("setFromString",&StringSet_O::setFromString)
+	    .def("union",&StringSet_O::setUnion)
+	    .def("intersection",&StringSet_O::intersection)
+	    .def("relativeComplement",&StringSet_O::relativeComplement)
+	    .def("removeAll",&StringSet_O::removeAll)
+	    .def("cartesianProduct",&StringSet_O::cartesianProduct)
+	    .def("cartesianProductInsert",&StringSet_O::cartesianProductInsert)
+	    .def("asCons",&StringSet_O::asCons)
+	    ;
+    }
 
     void StringSet_O::exposePython(Lisp_sp lisp)
-{_G();
+    {_G();
 #ifdef	USEBOOSTPYTHON
-    PYTHON_CLASS(CorePkg,StringSet,INIT_ARGS_StringSet_O,DOCS_StringSet_O,_lisp)
-	.def("insertStringSet", &StringSet_O::insertStringSet)
-	.def("size", &StringSet_O::size)
-	.def("insert",&StringSet_O::insert)
-	.def("equals",&StringSet_O::equal)
-	.def("contains",&StringSet_O::contains)
-	.def("containsSubset",&StringSet_O::containsSubset)
-	.def("remove",&StringSet_O::remove)
-	.def("clear",&StringSet_O::clear)
-	.def("first",&StringSet_O::first)
-	.def("asString",&StringSet_O::asString)
-	.def("setFromString",&StringSet_O::setFromString)
-	.def("union",&StringSet_O::setUnion)
-	.def("intersection",&StringSet_O::intersection)
-	.def("relativeComplement",&StringSet_O::relativeComplement)
-	.def("cartesianProduct",&StringSet_O::cartesianProduct)
-	.def("cartesianProductInsert",&StringSet_O::cartesianProductInsert)
-	.add_property("iterate",
-		boost::python::range(&StringSet_O::begin,
-					&StringSet_O::end))
-	;
+	PYTHON_CLASS(CorePkg,StringSet,INIT_ARGS_StringSet_O,DOCS_StringSet_O,_lisp)
+	    .def("insertStringSet", &StringSet_O::insertStringSet)
+	    .def("size", &StringSet_O::size)
+	    .def("insert",&StringSet_O::insert)
+	    .def("equals",&StringSet_O::equal)
+	    .def("contains",&StringSet_O::contains)
+	    .def("containsSubset",&StringSet_O::containsSubset)
+	    .def("remove",&StringSet_O::remove)
+	    .def("clear",&StringSet_O::clear)
+	    .def("first",&StringSet_O::first)
+	    .def("asString",&StringSet_O::asString)
+	    .def("setFromString",&StringSet_O::setFromString)
+	    .def("union",&StringSet_O::setUnion)
+	    .def("intersection",&StringSet_O::intersection)
+	    .def("relativeComplement",&StringSet_O::relativeComplement)
+	    .def("cartesianProduct",&StringSet_O::cartesianProduct)
+	    .def("cartesianProductInsert",&StringSet_O::cartesianProductInsert)
+	    .add_property("iterate",
+			  boost::python::range(&StringSet_O::begin,
+					       &StringSet_O::end))
+	    ;
 #endif
-}
+    }
 
 
 
@@ -361,51 +389,51 @@
 
 #if 0
 #ifdef	USEBOOSTPYTHON
-void	StringSet_O::python_setFromList(boost::python::list res) {
+    void	StringSet_O::python_setFromList(boost::python::list res) {
 //string		i;
 //boost::python::str		lval;
 //VectorStrings	vs;
 //VectorStrings::iterator vi;
-int			ll;
-string			x;
+	int			ll;
+	string			x;
 
-    ll = boost::python::extract<int>(res.attr("__len__")());
-    for ( int i=0; i<ll; i++ ) {
-	x = boost::python::extract<string>(res[i]);
+	ll = boost::python::extract<int>(res.attr("__len__")());
+	for ( int i=0; i<ll; i++ ) {
+	    x = boost::python::extract<string>(res[i]);
 //	printf( "Extracted element: %d = %s\n", i, x.c_str() );
-	this->strs.insert(x);
+	    this->strs.insert(x);
+	}
     }
-}
 
 
 
-boost::python::list StringSet_O::python_asList() {
-string		i;
-int		id;
-boost::python::list	res;
-boost::python::str		lval;
-VectorStrings	vs;
-set<string>::iterator vi;
+    boost::python::list StringSet_O::python_asList() {
+	string		i;
+	int		id;
+	boost::python::list	res;
+	boost::python::str		lval;
+	VectorStrings	vs;
+	set<string>::iterator vi;
 
-    for ( vi=this->strs.begin(); vi!=this->strs.end(); vi++ ) {
-	i = *vi;
-        LOG(BF("Appending %s to list") % (i.c_str() ) );
-	lval = boost::python::str(i);
-	res.append(lval);
+	for ( vi=this->strs.begin(); vi!=this->strs.end(); vi++ ) {
+	    i = *vi;
+	    LOG(BF("Appending %s to list") % (i.c_str() ) );
+	    lval = boost::python::str(i);
+	    res.append(lval);
+	}
+	return res;
     }
-    return res;
-}
 #endif
 #endif
 
 
 
 
-StringSet_O::~StringSet_O()
-{
+    StringSet_O::~StringSet_O()
+    {
 // nothing
-}
-EXPOSE_CLASS(core,StringSet_O);
+    }
+    EXPOSE_CLASS(core,StringSet_O);
 
 };
 
Index: stringSet.h
===================================================================
--- stringSet.h	(revision 4737)
+++ stringSet.h	(working copy)
@@ -14,6 +14,7 @@
 #include "foundation.h"
 #include "object.h"
 #include "holder.h"
+#include "lispVector.h"
 #include "cons.h"
 
 
@@ -36,9 +37,7 @@
     DECLARE_INIT();
 public:
     void initialize();
-#if defined(XML_ARCHIVE)
     void	archiveBase(ArchiveP node);
-#endif // defined(XML_ARCHIVE)
 
 private:
 	set<string>	strs;
@@ -89,7 +88,8 @@
 	StringSet_sp insertConsStrings(Cons_sp list);
 	void	clear();
 
-	Cons_sp	asCons();
+	Cons_sp	asCons() const;
+    Vector_sp asVector() const;
 
 	bool	equal(T_sp ss) const;
 
Index: structureObject.cc
===================================================================
--- structureObject.cc	(revision 4737)
+++ structureObject.cc	(working copy)
@@ -5,9 +5,12 @@
 #include "symbolTable.h"
 #include "numbers.h"
 #include "evaluator.h"
+#include "str.h"
 #include "builtInClass.h"
+#include "sysprop.h"
 #include "instance.h"
 #include "structureClass.h"
+#include "primitives.h"
 #include "wrappers.h"
 
 
@@ -22,28 +25,29 @@
 #define ARGS_af_makeStructure "(type &rest slot_values)"
 #define DECL_af_makeStructure ""
 #define DOCS_af_makeStructure "makeStructure"
-    T_sp af_makeStructure(Class_sp type, Cons_sp slot_values)  
+    T_sp af_makeStructure(T_sp type, Cons_sp slot_values)  
     {_G();
 	if ( type.nilp() )
 	{
 	    SIMPLE_ERROR(BF("You cannot makeStructure of type nil"));
 	}
-#if defined(CLOS)
-	ASSERTF(!type.nilp(), BF("Tried to make-structure with type = nil"));
+#ifdef CLOS
+	if ( Class_sp ctype = type.asOrNull<Class_O>() ) {
+	    ASSERTF(!type.nilp(), BF("Tried to make-structure with type = nil"));
 //	printf("%s:%d  af_makeStructure of %s  slot_values: %s\n",
 //	       __FILE__, __LINE__, _rep_(type).c_str(), _rep_(slot_values).c_str());
-	Instance_sp so = Instance_O::allocateInstance(type,af_length(slot_values));
-	int idx = 0;
-	for ( Cons_sp slot=slot_values; !slot.nilp(); slot=cCdr(slot) )
-	{
-	    so->instanceSet(idx,oCar(slot));
-	    ++idx;
+	    Instance_sp so = Instance_O::allocateInstance(ctype,af_length(slot_values));
+	    int idx = 0;
+	    for ( Cons_sp slot=slot_values; !slot.nilp(); slot=cCdr(slot) )
+	    {
+		so->instanceSet(idx,oCar(slot));
+		++idx;
+	    }
+	    return so;
 	}
-	return so;
-#else
+#endif // CLOS
 	StructureObject_sp so = StructureObject_O::create(type,slot_values);
 	return so;
-#endif // CLOS
     };
 
 
@@ -59,19 +63,17 @@
 	{
 	    SIMPLE_ERROR(BF("You cannot copyStructure nil"));
 	}
-#if defined(CLOS)
+#ifdef CLOS
 	if ( Instance_sp iarg=arg.asOrNull<Instance_O>() )
 	{
 	    return iarg->copyInstance();
 	}
-	SIMPLE_ERROR(BF("You cannot copy-structure a %s") % _rep_(arg));
-#else
+#endif
 	if ( StructureObject_sp so = arg.asOrNull<StructureObject_O>() )
 	{
 	    return so->copyStructure();
 	}
 	SIMPLE_ERROR(BF("You cannot copy-structure a %s") % _rep_(arg));
-#endif
     };
 
 
@@ -95,18 +97,17 @@
 	    }
 	    return so->instanceRef(idx);
 	}
-	TYPE_ERROR(obj,type);
-#else
+#endif
 	if ( StructureObject_sp so = obj.asOrNull<StructureObject_O>() )
 	{
-	    if ( !af_structureSubtypep(af_classOf(so),type) )
+	    T_sp soclass = af_type_of(so);
+	    if ( !af_structureSubtypep(soclass,type) )
 	    {
 		WRONG_TYPE_NTH_ARG(1,obj,type);
 	    }
-	    return so->structure_ref(idx);
+	    return so->structureRef(idx);
 	}
 	TYPE_ERROR(obj,type);
-#endif
     };
 
 
@@ -129,16 +130,16 @@
 	    }
 	    return so->instanceSet(idx,val);
 	}
-#else
+#endif
 	if ( StructureObject_sp so = obj.asOrNull<StructureObject_O>() )
 	{
-	    if ( !af_structureSubtypep(so->_instanceClass(),type) )
+	    T_sp sotype = af_type_of(so);
+	    if ( !af_structureSubtypep(sotype,type) )
 	    {
 		WRONG_TYPE_NTH_ARG(1,obj,type);
 	    }
 	    return so->structureSet(idx,val);
 	}
-#endif
 	TYPE_ERROR(obj,type);
     };
 
@@ -162,14 +163,12 @@
 	{
 	    if ( af_structureSubtypep(io->_instanceClass(),cl::_sym_StructureObject_O) ) return true;
 	}
-	return false;
-#else
+#endif
 	if ( StructureObject_sp so = arg.asOrNull<StructureObject_O>() )
 	{
 	    return true;
 	}
 	return false;
-#endif
     };
 
 
@@ -179,32 +178,33 @@
     
 #define ARGS_af_structureSubtypep "(x y)"
 #define DECL_af_structureSubtypep ""
-#define DOCS_af_structureSubtypep "structureSubtypep"
-    bool af_structureSubtypep(Class_sp x, Symbol_sp y)
+#define DOCS_af_structureSubtypep "structureSubtypep checks if the structure type Y is a subtype of X"
+    bool af_structureSubtypep(T_sp x, Symbol_sp y)
     {_G();
 	if ( x.nilp() ) return false;
 #ifdef CLOS
-	if (x->className() == y) {
-	    return true;
-	} else {
-	    Cons_sp superiors = x->directSuperclasses();
-	    for ( Cons_sp sup = superiors; !sup.nilp(); sup=cCdr(sup))
-	    {
-		if (af_structureSubtypep(oCar(sup).as<Class_O>(),y) ) return true;
+	if ( Class_sp cx = x.asOrNull<Class_O>() ) {
+	    if (cx->className() == y) {
+		return true;
+	    } else {
+		Cons_sp superiors = cx->directSuperclasses();
+		for ( Cons_sp sup = superiors; !sup.nilp(); sup=cCdr(sup))
+		{
+		    if (af_structureSubtypep(oCar(sup).as<Class_O>(),y) ) return true;
+		}
+		return false;
 	    }
+	}
+#endif
+	if ( Symbol_sp sx = x.asOrNull<Symbol_O>() ) {
+	    do {
+		if (sx == y) return true;
+		SYMBOL_EXPORT_SC_(CorePkg,structure_include);
+		sx = af_get_sysprop(x,_sym_structure_include).as<Symbol_O>();
+	    } while (!sx.nilp());
 	    return false;
 	}
-#else
-	do {
-	    if (Symbol_sp sx = x.asOrNull<Symbol_O>())
-	    {
-		if (x == y) return true;
-	    } else return false
-		       SYMBOL_EXPORT_SC_(CorePkg,structure_include);
-	    x = af_get_sysprop(x,_sym_structure_include);
-	} while (!x.nilp());
 	return false;
-#endif /* CLOS */
     }
 
 
@@ -213,15 +213,14 @@
 
 
 
-
     StructureObject_O::StructureObject_O() : StructureObject_O::Base() {};
 
     StructureObject_O::~StructureObject_O() {};
 
-    StructureObject_sp StructureObject_O::create(Class_sp structureClass, Cons_sp slot_values)
+    StructureObject_sp StructureObject_O::create(T_sp type, Cons_sp slot_values)
     {_G();
 	StructureObject_sp co = StructureObject_O::create();
-	co->_StructureClass = structureClass.as<StructureClass_O>();
+	co->_Type = type;
 	co->_Slots.resize(af_length(slot_values));
 	int i=0;
 	for ( Cons_sp cur=slot_values; cur.notnilp(); cur = cCdr(cur), i++ )
@@ -237,7 +236,7 @@
     {_G();
 	LOG(BF("Initializing StructureObject"));
 	this->Base::initialize();
-	this->_StructureClass = _Nil<StructureClass_O>();
+	this->_Type = _Nil<T_O>();
 	this->_Slots.clear();
     }
 
@@ -265,6 +264,31 @@
 
 
 
+    T_sp StructureObject_O::structureAsList() const
+    {
+	Cons_O::CdrType_sp first(_Nil<Cons_O::CdrType_O>());
+	Cons_O::CdrType_sp* cur = &first;
+	Cons_sp head = Cons_O::create(this->_Type);
+	*cur = head;
+	cur = head->cdrPtr();
+	SYMBOL_EXPORT_SC_(CorePkg,structure_slot_descriptions);
+	Cons_sp slots = af_get_sysprop(this->_Type,_sym_structure_slot_descriptions).as<Cons_O>();
+	for ( ; slots.notnilp(); slots = cCdr(slots) ) {
+	    Cons_sp slotDesc = oCar(slots).as<Cons_O>();
+	    Cons_sp slotNameCons = Cons_O::create(_lisp->internKeyword(oCar(slotDesc).as<Symbol_O>()->symbolName()->get()));
+	    *cur = slotNameCons;
+	    cur = slotNameCons->cdrPtr();
+	    int idx = oFifth(slotDesc).as<Fixnum_O>()->get();
+	    T_sp val = this->structureRef(idx);
+	    Cons_sp slotValueCons = Cons_O::create(val);
+	    *cur = slotValueCons;
+	    cur = slotValueCons->cdrPtr();
+	}
+	return first;
+    }
+
+
+
     T_sp StructureObject_O::structureRef( int index) const
     {_OF();
 	ASSERTF(index >=0 && index < this->_Slots.size(),BF("Illegal slot index[%d] - must be less than %d") % index % this->_Slots.size() );
@@ -280,16 +304,11 @@
 
 
 
-#if defined(XML_ARCHIVE)
     void	StructureObject_O::archiveBase(ArchiveP node)
     {
-	IMPLEMENT_ME(); // handle slots properly so that they are indexed by name
-#if 0
-	this->Base::archiveBase(node); 
-	node->archiveObject("slots",this->_SlotBinder);
-#endif
+	// Call out to core:serialize
+	IMPLEMENT_MEF(BF("Call out to core::serialize me node")); // handle slots properly so that they are indexed by name
     }
-#endif // defined(XML_ARCHIVE)
 
 
 
@@ -305,18 +324,20 @@
 	stringstream ss;
 	ss << "#< ";
 	ss << this->_instanceClass()->classNameAsString() << " ";
-	ASSERT(this->_StructureClass);
-	if ( this->_StructureClass.unboundp() )
+	ASSERT(this->_Type);
+	if ( this->_Type.unboundp() )
 	{
-	    ss << ":class - UNBOUND -" << endl;
+	    ss << ":type - UNBOUND -" << endl;
 	} else
 	{
-	    ss << ":class " << _rep_(this->_StructureClass) << endl;
+	    ss << ":type " << _rep_(this->_Type) << endl;
 	}
 	ss << "[slots ";
 	for ( int i=0; i<this->_Slots.size(); i++ )
 	{
-	    if ( this->_Slots[i].get() == this )
+	    if ( this->_Slots[i].nilp() ) {
+		ss << "NIL ";
+	    } else if ( this->_Slots[i].get() == this )
 	    {
 		ss << "SELF_REFERENCE!!!! ";
 	    } else
Index: structureObject.h
===================================================================
--- structureObject.h	(revision 4737)
+++ structureObject.h	(working copy)
@@ -34,30 +34,31 @@
 #if defined(OLD_SERIALIZE)
 	void	serialize(serialize::SNode node);
 #endif
-#if defined(XML_ARCHIVE)
 	void	archiveBase(ArchiveP node);
-#endif // defined(XML_ARCHIVE)
 	void	initialize();
     private:
-	StructureClass_sp 		_StructureClass;
+	T_sp 		_Type;
 	Vector0<T_O>	_Slots;
     public:
-	static StructureObject_sp create(Class_sp structureClass, Cons_sp slotNames);
+	static StructureObject_sp create(T_sp type, Cons_sp slotNames);
     public:
 
 	T_sp structureRef(int index) const;
 	T_sp structureSet(int index, T_sp value);
 
+	/*! Convert this structure to a list (type {slot-name slot-value}*) */
+	T_sp structureAsList() const;
 #if 0
 	static bool static_supportsSlots() {return true;};
 	T_sp& slot_ref( Symbol_sp sym ) throw(SlotRefFailed);
 #endif
 
 
-	StructureClass_sp structureClass() const { return this->_StructureClass;};
+	T_sp structureType() const { return this->_Type;};
 
 	void allocate_slot_storage(uint numberOfSlots, T_sp initialValue);
 
+	void __write__(Stream_sp stream) const;
 
 	string __repr__() const;
 
@@ -74,12 +75,12 @@
     };
 
 
-    T_sp af_makeStructure(Class_sp type, Cons_sp slot_values);
+    T_sp af_makeStructure(T_sp type, Cons_sp slot_values);
     T_sp af_copyStructure(T_sp arg);
     T_sp af_structureRef(T_sp obj, Symbol_sp type, int idx);
     T_sp af_structureSet(T_sp obj, Symbol_sp type, int idx, T_sp val);
     bool af_structurep(T_sp arg);
-    bool af_structureSubtypep(Class_sp x, Symbol_sp y);
+    bool af_structureSubtypep(T_sp x, Symbol_sp y);
 };
 TRANSLATE(core::StructureObject_O);
 #endif //]
Index: symbol.cc
===================================================================
--- symbol.cc	(revision 4737)
+++ symbol.cc	(working copy)
@@ -88,6 +88,9 @@
 	if ( arg.nilp() )
 	{
 	    return cl::_sym_nil->symbolValue();
+	} else if ( arg.unboundp() )
+	{
+	    SIMPLE_ERROR(BF("Symbol %s is unbound") % _rep_(arg));
 	}
 	return arg->symbolValue();
     };
@@ -163,7 +166,6 @@
 	this->_HomePackage = pkg;
 	pkg->_add_symbol_to_package(this->sharedThis<Symbol_O>(),exportp);
 	this->_PropertyList = _Nil<Cons_O>();
-	this->_Value.reset();
 	this->_Function = _Nil<Function_O>();
     }
 
@@ -309,6 +311,12 @@
     }
 
 
+    void Symbol_O::makeSpecial()
+    {
+	this->_IsSpecial = true;
+    }
+
+
     void Symbol_O::makeConstant(T_sp val)
     {_G();
 	this->_Value = val;
@@ -344,15 +352,11 @@
 
     T_sp Symbol_O::symbolValue() const
     {
-	if ( !this->_Value)
-	{
-	    SIMPLE_ERROR(BF("Symbol %s is UNDEFINED!") % this->_Name->_contents() );
-	}
+	ASSERTF(this->_Value,BF("NULL symbol-value for %s") % this->_Name->_contents() );
 	if ( this->_Value.unboundp() )
 	{
-	    SIMPLE_ERROR(BF("Unbound symbol %s") % this->_Name->_contents() );
+	    SIMPLE_ERROR(BF("Unbound symbol-value for %s") % this->_Name->_contents() );
 	}
-	ASSERT(this->_Value);
 	return this->_Value;
     }
 
Index: symbol.h
===================================================================
--- symbol.h	(revision 4737)
+++ symbol.h	(working copy)
@@ -18,8 +18,8 @@
 
 
 
+#define KW(s) (_lisp->internKeyword(s))
 
-
 namespace core {
 
     SMART(Package);
@@ -98,7 +98,8 @@
 	template <class T>
 	mem::smart_ptr<T> dyn() { return this->symbolValue().as<T>(); };
 
-	void makeSpecial() { this->_IsSpecial = true;};
+	void makeSpecial();
+
 	void makeConstant(T_sp val);
 
 	bool boundP() const;
Index: symbolSet.cc
===================================================================
--- symbolSet.cc	(revision 4737)
+++ symbolSet.cc	(working copy)
@@ -156,10 +156,19 @@
     }
 
 
+    void SymbolSet_O::insertVector(Vector_sp vec)
+    {
+	for ( int i=0, iEnd(vec->length()); i<iEnd; ++i ) {
+	    Symbol_sp sym = vec->elt(i).as<Symbol_O>();
+	    this->insert(sym);
+	}
+    }
 
 
 
 
+
+
 bool	SymbolSet_O::contains(Symbol_sp s)
 {_G();
 bool	ye;
Index: symbolSet.h
===================================================================
--- symbolSet.h	(revision 4737)
+++ symbolSet.h	(working copy)
@@ -13,6 +13,7 @@
 #include <set>
 #include "foundation.h"
 #include "object.h"
+#include "lispVector.h"
 #include "cons.h"
 
 
@@ -110,6 +111,7 @@
 	void	insertSymbolList(SymbolList_sp ss);
 	SymbolSet_sp insertConsSymbols(Cons_sp list);
 	void	insertVectorStrings(const VectorStrings& symbolsAsStrings);
+	void	insertVector(Vector_sp objs);
 	void	clear();
 
 	Cons_sp	asCons();
Index: symbolToEnumConverter.cc
===================================================================
--- symbolToEnumConverter.cc	(revision 4737)
+++ symbolToEnumConverter.cc	(working copy)
@@ -37,25 +37,36 @@
     return c;
 }
 
-void SymbolToEnumConverter_O::setWhatTheEnumsRepresent(const string& what)
-{_OF();
-    this->_WhatTheEnumsRepresent = what;
-}
 
-Symbol_sp SymbolToEnumConverter_O::addSymbolEnumPair(Symbol_cp asym, Symbol_cp& archiveSym, int enumIndex )
-{_OF();
-    Symbol_sp sym = asym;
-    if ( sym.nilp() )
-    {
-	sym = archiveSym;
+    SymbolToEnumConverter_sp SymbolToEnumConverter_O::create(const string& whatDoesEnumRepresent, string const& packageName, NullTerminatedEnumAssociation assoc[])
+    {_G();
+	SymbolToEnumConverter_sp c = SymbolToEnumConverter_O::create(whatDoesEnumRepresent);
+	for (int i=0; assoc[i]._Key!=""; ++i ) {
+	    Symbol_sp sym = _lisp->internWithPackageName(packageName,assoc[i]._Key);
+	    c->addSymbolEnumPair(sym,sym,assoc[i]._Enum);
+	}
+	return c;
     }
-    this->_EnumToSymbol[enumIndex] = sym;
-    this->_ArchiveSymbolToEnum[archiveSym] = enumIndex;
-    this->_EnumToArchiveSymbol[enumIndex] = archiveSym;
-    this->_SymbolToEnum->extend(sym,Fixnum_O::create(enumIndex));
-    return sym;
-}
 
+    void SymbolToEnumConverter_O::setWhatTheEnumsRepresent(const string& what)
+    {_OF();
+	this->_WhatTheEnumsRepresent = what;
+    }
+
+    Symbol_sp SymbolToEnumConverter_O::addSymbolEnumPair(Symbol_cp asym, Symbol_cp& archiveSym, int enumIndex )
+    {_OF();
+	Symbol_sp sym = asym;
+	if ( sym.nilp() )
+	{
+	    sym = archiveSym;
+	}
+	this->_EnumToSymbol[enumIndex] = sym;
+	this->_ArchiveSymbolToEnum[archiveSym] = enumIndex;
+	this->_EnumToArchiveSymbol[enumIndex] = archiveSym;
+	this->_SymbolToEnum->extend(sym,Fixnum_O::create(enumIndex));
+	return sym;
+    }
+
 int SymbolToEnumConverter_O::enumIndexForSymbol(Symbol_sp sym)
 {_OF();
     if ( !this->_SymbolToEnum->contains(sym) ) {
Index: symbolToEnumConverter.h
===================================================================
--- symbolToEnumConverter.h	(revision 4737)
+++ symbolToEnumConverter.h	(working copy)
@@ -22,6 +22,7 @@
     LISP_CLASS(core,CorePkg,SymbolToEnumConverter_O,"SymbolToEnumConverter");
 public:
     static SymbolToEnumConverter_sp create(const string& whatDoesEnumRepresent);
+    static SymbolToEnumConverter_sp create(const string& whatDoesEnumRepresent, string const& packageName, NullTerminatedEnumAssociation  assoc[]);
 public: // virtual functions inherited from Object
 	void	initialize();
 
@@ -79,8 +80,6 @@
     string __repr__() const;
 
 
-	SymbolToEnumConverter_O( const SymbolToEnumConverter_O& ss ); //!< Copy constructor
-
 	DEFAULT_CTOR_DTOR(SymbolToEnumConverter_O);
 
 
@@ -89,4 +88,48 @@
 
 };
 TRANSLATE(core::SymbolToEnumConverter_O);
+
+
+
+#define ENUM_TRANSLATOR(enumType,converterSymbol) \
+namespace translate {	\
+    template <> struct to_object<enumType>				\
+    {									\
+	typedef	enumType	GivenType;				\
+	static core::T_mv convert(const GivenType& val)			\
+	{_G();								\
+	    core::SymbolToEnumConverter_sp converter =			\
+		converterSymbol->symbolValue().as<core::SymbolToEnumConverter_O>(); \
+	    return Values(converter->symbolForEnum(val));		\
+	}								\
+    };									\
+									\
+    template <>								\
+    struct from_object<enumType>					\
+    {									\
+	typedef	enumType 	ExpectedType;				\
+	typedef	enumType 	DeclareType;				\
+	DeclareType _v;							\
+	from_object(mem::smart_ptr<core::T_O> o) {			\
+	    core::SymbolToEnumConverter_sp converter = converterSymbol->symbolValue().as<core::SymbolToEnumConverter_O>(); \
+	    _v = converter->enumForSymbol<enumType>(o.as<core::Symbol_O>()); \
+	}								\
+    };									\
+									\
+									\
+};	
+
+
+
+#define DECLARE_SYMBOL_TO_ENUM_CONVERTER(assocArray,description,package,converterSymbol) { \
+	core::SymbolToEnumConverter_sp enumConverter =			\
+	    core::SymbolToEnumConverter_O::create(description,package,assocArray); \
+	(converterSymbol)->defparameter(enumConverter);			\
+    }
+
+
+
+
+
+
 #endif //]
Index: symbolVector.h
===================================================================
--- symbolVector.h	(revision 4737)
+++ symbolVector.h	(working copy)
@@ -49,8 +49,6 @@
 
 	Cons_sp asCons();
 
-	SymbolVector_O( const SymbolVector_O& ss ); //!< Copy constructor
-
 	DEFAULT_CTOR_DTOR(SymbolVector_O);
     };
 
@@ -90,8 +88,6 @@
 	bool contains(SymbolVector_sp key);
 	Cons_sp keysAsCons();
     public:
-	SymbolVectorMap_O( const SymbolVectorMap_O& ss ); //!< Copy constructor
-
 	DEFAULT_CTOR_DTOR(SymbolVectorMap_O);
     };
 
Index: sysprop.cc
===================================================================
--- sysprop.cc	(revision 4737)
+++ sysprop.cc	(working copy)
@@ -53,11 +53,9 @@
     {_G();
 	if ( _lisp->_Roots._SystemProperties.pointerp() ) 
 	{
-	    bool foundHashTable;
-	    HashTable_sp hashTable;
 	    T_mv values = _lisp->_Roots._SystemProperties->gethash(area,_Nil<T_O>());
-	    hashTable = values.as<HashTable_O>();
-	    foundHashTable = values.valueGet(1).as<T_O>().isTrue();
+	    HashTable_sp hashTable = values.as<HashTable_O>();
+	    bool foundHashTable = values.valueGet(1).as<T_O>().isTrue();
 	    if ( foundHashTable )
 	    {
 		return hashTable->gethash(key,_Nil<T_O>());
@@ -68,10 +66,27 @@
 
 
 
+    
+    
+#define ARGS_af_rem_sysprop "(key area)"
+#define DECL_af_rem_sysprop ""
+#define DOCS_af_rem_sysprop "rem_sysprop"
+    T_sp af_rem_sysprop(T_sp key, T_sp area)
+    {_G();
+	T_mv mv_values = _lisp->_Roots._SystemProperties->gethash(area,_Nil<T_O>());
+	HashTable_sp hashTable = mv_values.as<HashTable_O>();
+	bool foundHashTable = mv_values.valueGet(1).as<T_O>().isTrue();
+	if (foundHashTable) {
+	    bool found = hashTable->remhash(key);
+	    return _lisp->_boolean(found);
+	}
+	return _Nil<T_O>();
+    }
 
 
 
 
+
     void initialize_sysprop()
     {_G();
 	SYMBOL_SC_(CorePkg,put_sysprop);
@@ -79,6 +94,9 @@
 
 	SYMBOL_SC_(CorePkg,get_sysprop);
 	Defun(get_sysprop);
+
+	SYMBOL_SC_(CorePkg,rem_sysprop);
+	Defun(rem_sysprop);
     }
 
 
Index: tagged_intrusive_ptr.h
===================================================================
--- tagged_intrusive_ptr.h	(revision 4737)
+++ tagged_intrusive_ptr.h	(working copy)
@@ -56,10 +56,11 @@
     typedef T* PointerType;
     typedef tagged_intrusive_ptr this_type;
 
-protected:
+public:
     static const uintptr_t tag_mask 	  = BOOST_BINARY(0011);
     static const uintptr_t ptr_tag        = BOOST_BINARY(0000); // xxx00 means ptr
     static const uintptr_t special_tag    = BOOST_BINARY(0001); // xxx01 means special val
+    static const uintptr_t character_tag  = BOOST_BINARY(0010); // xxx10 means character
     static const uintptr_t fixnum_tag     = BOOST_BINARY(0011); // xxx11 means fixnum
     static const uintptr_t ptr_mask = ~tag_mask;
 public:
@@ -91,12 +92,10 @@
     }
 
 
-    tagged_intrusive_ptr( int p ): px( (p<<2) | fixnum_tag) 
-    {
-	// Do nothing for fixnums
-    }
+    explicit tagged_intrusive_ptr( brclChar c) : px(reinterpret_cast<T*>((c<<2) | character_tag)) {};
+    explicit tagged_intrusive_ptr( int p ): px( reinterpret_cast<T*>((p<<2) | fixnum_tag)) {};
 
-    tagged_intrusive_ptr(uintptr_t p) : px((T*)p)
+    explicit tagged_intrusive_ptr(uintptr_t p) : px(reinterpret_cast<T*>(p))
     {
     }
 
@@ -201,7 +200,8 @@
     /*! THROW exception if px is not a pointer */
     void assert_pointer() const { BOOST_ASSERT(this->pointerp());}
 
-    bool taggedp() const { return (this->px&&tag_mask);};
+    uintptr_t tag() const { return reinterpret_cast<uintptr_t>(this->px)&tag_mask;};
+    bool taggedp() const { return (this->px&tag_mask);};
 
     bool _NULLp() const { return (uintptr_t)this->px == tagged_NULL;};
 
@@ -209,10 +209,14 @@
 
     bool nilp() const { return (uintptr_t)this->px == tagged_nil;};
 
-    bool fixnump() const { return ((this->px&tag_mask)==fixnum_tag);};
+    bool characterp() const { return ((reinterpret_cast<uintptr_t>(this->px)&tag_mask)==character_tag);};
+    bool fixnump() const { return ((reinterpret_cast<uintptr_t>(this->px)&tag_mask)==fixnum_tag);};
     // Handle get_fixnum
 
 
+    inline brclChar character() const { return ((reinterpret_cast<uintptr_t>(this->px)>>2));};
+    inline Fixnum fixnum() const { return ((reinterpret_cast<uintptr_t>(this->px)>>2));};
+
     T * pxget() const
     {
 	return px;
@@ -265,41 +269,46 @@
 
 template<class T, class U> inline bool operator==(tagged_intrusive_ptr<T> const & a, tagged_intrusive_ptr<U> const & b)
 {
-    return a.pxget() == b.pxget();
-#if 0
-    if ( a.pointerp() && b.pointerp() )
-    {
-	return a.get() == b.get();
+    bool anilp = a.nilp();
+    bool bnilp = b.nilp();
+    if ( anilp || bnilp ) {
+	return anilp && bnilp;
     }
-    uintptr_t ua = (uintptr_t)(a.pxget());
-    uintptr_t ub = (uintptr_t)(b.pxget());
-    return ua == ub;
-#endif
+    return dynamic_cast<void*>(a.pxget()) == dynamic_cast<void*>(b.pxget());
 }
 
 template<class T, class U> inline bool operator!=(tagged_intrusive_ptr<T> const & a, tagged_intrusive_ptr<U> const & b)
 {
-    return a.pxget() != b.pxget();
+    bool anilp = a.nilp();
+    bool bnilp = b.nilp();
+    if ( anilp || bnilp ) {
+	return !(anilp && bnilp);
+    }
+    return (dynamic_cast<void*>(a.pxget()) != dynamic_cast<void*>(b.pxget()));
 }
 
 template<class T, class U> inline bool operator==(tagged_intrusive_ptr<T> const & a, U * b)
 {
-    return a.get() == b;
+    if ( a.nilp() ) return false;
+    return dynamic_cast<void*>(a.get()) == dynamic_cast<void*>(b);
 }
 
 template<class T, class U> inline bool operator!=(tagged_intrusive_ptr<T> const & a, U * b)
 {
-    return a.pxget() != b;
+    if ( a.nilp() ) return true;
+    return dynamic_cast<void*>(a.pxget()) != dynamic_cast<void*>(b);
 }
 
 template<class T, class U> inline bool operator==(T * a, tagged_intrusive_ptr<U> const & b)
 {
-    return a == b.pxget();
+    if ( b.nilp() ) return false;
+    return dynamic_cast<void*>(const_cast<T*>(a)) == dynamic_cast<void*>(const_cast<U*>(b.pxget()));
 }
 
 template<class T, class U> inline bool operator!=(T * a, tagged_intrusive_ptr<U> const & b)
 {
-    return a != b.pxget();
+    if ( b.nilp() ) return true;
+    return dynamic_cast<void*>(a) != dynamic_cast<const void*>(const_cast<U*>(b.pxget()));
 }
 
 #if __GNUC__ == 2 && __GNUC_MINOR__ <= 96
@@ -308,7 +317,7 @@
 
 template<class T> inline bool operator!=(tagged_intrusive_ptr<T> const & a, tagged_intrusive_ptr<T> const & b)
 {
-    return a.pxget() != b.pxget();
+    return dynamic_cast<void*>(a.pxget()) != dynamic_cast<void*>(b.pxget());
 }
 
 #endif
Index: tagged_ptr.h
===================================================================
--- tagged_ptr.h	(revision 4737)
+++ tagged_ptr.h	(working copy)
@@ -84,12 +84,12 @@
     }
 
 
-    tagged_ptr( int p ): px( (p<<2) | fixnum_tag) 
+    explicit tagged_ptr( int p ): px( (p<<2) | fixnum_tag) 
     {
 	// Do nothing for fixnums
     }
 
-    tagged_ptr(uintptr_t p) : px((T*)p)
+    explicit tagged_ptr(uintptr_t p) : px((T*)p)
     {
     }
 
@@ -196,7 +196,10 @@
     bool fixnump() const { return ((this->px&tag_mask)==fixnum_tag);};
     // Handle get_fixnum
 
+    inline Fixnum fixnum() const {return (this->px)>>2;}
 
+
+
     T * pxget() const
     {
 	return px;
@@ -254,6 +257,9 @@
     mutable PointerType px;
 };
 
+
+
+
 template<class T, class U> inline bool operator==(tagged_ptr<T> const & a, tagged_ptr<U> const & b)
 {
     return a.pxget() == b.pxget();
Index: translators.h
===================================================================
--- translators.h	(revision 4737)
+++ translators.h	(working copy)
@@ -329,7 +329,7 @@
 	typedef	string 		GivenType;
 	static core::T_mv convert(const string& v)
 	{_G();
-	    core::T_sp oi = core::str_create(v,_lisp);
+	    core::T_sp oi = core::str_create(v);
 	    return Values(oi);
 	}
     };
@@ -342,7 +342,7 @@
 	typedef	core::Str_sp		DeclareType;
 	static core::T_sp convert(const string& v)
 	{_G();
-	    core::T_sp oi = core::str_create(v,_lisp);
+	    core::T_sp oi = core::str_create(v);
 	    return Values(oi);
 	}
     };
@@ -355,7 +355,7 @@
 	typedef	const std::string& GivenType;
 	static core::T_mv convert(GivenType v)
 	{_G();
-	    core::T_sp oi = core::str_create(v,_lisp);
+	    core::T_sp oi = core::str_create(v);
 	    return Values(oi);
 	}
     };
Index: unixfsys.cc
===================================================================
--- unixfsys.cc	(revision 4737)
+++ unixfsys.cc	(working copy)
@@ -746,7 +746,10 @@
 {
     size_t i;
     Str_sp namestring;
-    const char *h, *d;
+    const char *h;
+#if defined(ECL_MS_WINDOWS_HOST)
+    const char *d;
+#endif
     if (!Null(user)) {
 #ifdef HAVE_PWD_H
 	struct passwd *pwent = NULL;
@@ -1325,8 +1328,59 @@
 #endif  // working
 
 
+
+
+
+#define ARGS_af_unixDaylightSavingTime "(unix-time)"
+#define DECL_af_unixDaylightSavingTime ""
+#define DOCS_af_unixDaylightSavingTime "unixDaylightSavingTime return true if in daylight saving time"
+bool af_unixDaylightSavingTime(Integer_sp unix_time)
+{_G();
+    time_t when = unix_time->as_uint64();
+    struct tm *ltm = localtime(&when);
+    return ltm->tm_isdst;
+}
+
+
+
+
+
+
+#define ARGS_af_unixGetLocalTimeZone "()"
+#define DECL_af_unixGetLocalTimeZone ""
+#define DOCS_af_unixGetLocalTimeZone "unixGetLocalTimeZone"
+Ratio_sp af_unixGetLocalTimeZone()
+{_G();
+  cl_fixnum mw;
+#if 0 && defined(HAVE_TZSET)
+  tzset();
+  mw = timezone/60;
+#else
+  struct tm ltm, gtm;
+  time_t when = time(0) /*0L*/;
+
+  ltm = *localtime(&when);
+  gtm = *gmtime(&when);
+
+  mw = (gtm.tm_min + 60 * gtm.tm_hour) - (ltm.tm_min + 60 * ltm.tm_hour);
+
+  if ((gtm.tm_wday + 1) % 7 == ltm.tm_wday)
+    mw -= 24*60;
+  else if (gtm.tm_wday == (ltm.tm_wday + 1) % 7)
+    mw += 24*60;
+#endif
+  return Ratio_O::create(Fixnum_O::create(mw),Fixnum_O::create(60));
+}
+
+
+
+
+
+
 void initialize_unixfsys()
 {
+    Defun(unixGetLocalTimeZone);
+    Defun(unixDaylightSavingTime);
     SYMBOL_EXPORT_SC_(CorePkg,currentDir);
     Defun(currentDir);
     SYMBOL_EXPORT_SC_(CorePkg,file_kind);
Index: vectorObjects.cc
===================================================================
--- vectorObjects.cc	(revision 4738)
+++ vectorObjects.cc	(working copy)
@@ -3,7 +3,8 @@
 #include "core/common.h"
 #include "core/environment.h"
 #include "core/symbolTable.h"
-#include "vectorObjects.h"
+#include "core/vectorObjects.h"
+#include "core/serialize.h"
 #include "core/wrappers.h"
 namespace core
 {
@@ -133,13 +134,16 @@
 
 
 
-#if defined(XML_ARCHIVE)
     void VectorObjects_O::archiveBase(::core::ArchiveP node)
     {
         this->Base::archiveBase(node);
+	SYMBOL_EXPORT_SC_(KeywordPkg,elementType);
+	SYMBOL_EXPORT_SC_(KeywordPkg,adjustable);
+	node->attribute(kw::_sym_elementType,this->_ElementType);
+	node->attribute(kw::_sym_adjustable,this->_Adjustable);
+	node->vector(this->_Values);
 	// Archive other instance variables here
     }
-#endif // defined(XML_ARCHIVE)
 
 
     void VectorObjects_O::initialize()
@@ -180,7 +184,7 @@
 
 
 
-    void VectorObjects_O::setf_rowMajorAref(int idx, T_sp value)
+    void VectorObjects_O::rowMajorAset(int idx, T_sp value)
     {_G();
 	ASSERTF(idx<this->length(),BF("Index %d is out of range (<%d)") % idx % this->length() );
 	this->_Values[idx] = value;
@@ -203,6 +207,9 @@
 
     T_sp VectorObjects_O::elt(int index) const
     {_G();
+	if ( index >= this->length() ) {
+	    SIMPLE_ERROR(BF("Index too large %d must be less than %d") % index % this->length());
+	}
 	return this->_Values[index];
     }
 
Index: vectorObjects.h
===================================================================
--- vectorObjects.h	(revision 4738)
+++ vectorObjects.h	(working copy)
@@ -14,9 +14,8 @@
 	LISP_BASE1(Vector_O);
 	LISP_CLASS(core,CorePkg,VectorObjects_O,"VectorObjects");
 	DECLARE_INIT();
-#if defined(XML_ARCHIVE)
-	DECLARE_ARCHIVE();
-#endif // defined(XML_ARCHIVE)
+
+	void archiveBase(SNode_sp node);
     public:
 	VectorObjects_O();
 	virtual ~VectorObjects_O() {};
@@ -45,7 +44,7 @@
 	bool adjustableArrayP() const { return this->_Adjustable; };
 
 	uint dimension() const { return this->_Values.size(); };
-	virtual void setf_rowMajorAref( int idx, T_sp value);
+	virtual void rowMajorAset( int idx, T_sp value);
 	virtual T_sp rowMajorAref(int idx) const;
 	virtual int arrayRowMajorIndex(Cons_sp indices) const;
 
Index: vectorObjectsWithFillPtr.cc
===================================================================
--- vectorObjectsWithFillPtr.cc	(revision 4738)
+++ vectorObjectsWithFillPtr.cc	(working copy)
@@ -2,7 +2,9 @@
 
 #include "core/common.h"
 #include "core/environment.h"
-#include "vectorObjectsWithFillPtr.h"
+#include "core/symbolTable.h"
+#include "core/vectorObjectsWithFillPtr.h"
+#include "core/serialize.h"
 #include "core/wrappers.h"
 namespace core
 {
@@ -55,13 +57,12 @@
 
 
 
-#if defined(XML_ARCHIVE)
     void VectorObjectsWithFillPtr_O::archiveBase(::core::ArchiveP node)
     {
         this->Base::archiveBase(node);
-	// Archive other instance variables here
+	SYMBOL_EXPORT_SC_(KeywordPkg,fillPointer);
+	node->attribute(kw::_sym_fillPointer,this->_FillPtr);
     }
-#endif // defined(XML_ARCHIVE)
 
 
     void VectorObjectsWithFillPtr_O::initialize()
Index: vectorObjectsWithFillPtr.h
===================================================================
--- vectorObjectsWithFillPtr.h	(revision 4738)
+++ vectorObjectsWithFillPtr.h	(working copy)
@@ -13,16 +13,12 @@
     {
 	LISP_BASE1(VectorObjects_O);
 	LISP_CLASS(core,CorePkg,VectorObjectsWithFillPtr_O,"VectorObjectsWithFillPtr");
-#if defined(XML_ARCHIVE)
-	DECLARE_ARCHIVE();
-#endif // defined(XML_ARCHIVE)
+	void archiveBase(SNode_sp node);
     public:
 	VectorObjectsWithFillPtr_O();
 	virtual ~VectorObjectsWithFillPtr_O() {};
     public:
 	void initialize();
-
-
     private: // instance variables here
 	int 		_FillPtr;
     public:
@@ -44,7 +40,7 @@
 	void setf_fillPointer(int fp);
 
 	Fixnum_sp vectorPush(T_sp newElement);
-	Fixnum_sp vectorPushExtend(T_sp newElement, int extension);
+	Fixnum_sp vectorPushExtend(T_sp newElement, int extension=16);
 
     };
 
Index: wrappers.h
===================================================================
--- wrappers.h	(revision 4737)
+++ wrappers.h	(working copy)
@@ -1,15 +1,154 @@
-#ifndef	wrappers_H
-#define wrappers_H
+#ifndef	core_wrappers_H
+#define core_wrappers_H
 
-
+#include <functional>
 #include "lispDefinitions.h"
 #include "symbolToEnumConverter.h"
 #include "activationFrame.h"
 
+//#define DEBUG_METHOIDS 1
 
+
 namespace core
 {
 
+    template<class RT, class OT, typename... ARGS>
+    class MemberFunction {
+    public:
+	typedef std::function<RT(OT&,ARGS...)> 		MethodPtrType;
+	MethodPtrType			mfn;
+    public:
+	MemberFunction(MethodPtrType fn) : mfn(fn) {};
+	T_mv operator()(OT& receiver, ARGS...args) {
+	    RT retval = mfn(receiver,args...);
+	    return translate::to_object<RT>::convert(retval);
+	}
+    };
+
+    template<class OT, typename... ARGS>
+    class MemberFunction<void,OT,ARGS...> {
+    public:
+	typedef std::function<void(OT&,ARGS...)> 	MethodPtrType;
+	MethodPtrType 					mfn;
+    public:
+	MemberFunction(MethodPtrType fn) : mfn(fn) {};
+	T_mv operator()(OT& receiver, ARGS...args) {
+	    mfn(receiver,args...);
+	    return Values0<T_O>();
+	}
+    };
+
+
+
+	    
+	
+    template<class RT, class OT, class... ARGS>
+    class VariadicMethoid : public SingleDispatchMethoid {
+    public:
+	typedef MemberFunction<RT,OT,ARGS...> 	HolderType;
+	typedef typename MemberFunction<RT,OT,ARGS...>::MethodPtrType 	Type;
+	HolderType				mptr;
+    public:
+	string describe() const { return "VariadicMethoid";}
+	enum { NumParams = sizeof...(ARGS) };
+	VariadicMethoid(const string& name, Type ptr) :
+	    SingleDispatchMethoid(name), mptr(ptr) {
+	};
+    private:
+	T_mv activate( const_ActivationFrame_spREF closedEnv, int nargs, ArgArray argArray )
+	{_G();
+	    if ( nargs-1 != sizeof...(ARGS) )
+	    {
+		stringstream ss;
+		ss << "Method expected "<< (sizeof...(ARGS)) << " argument(s) but was passed " << nargs << " argument(s).";
+		SIMPLE_ERROR_BF(ss.str());
+	    }
+	    mem::smart_ptr<OT> ot(argArray[this->_SingleDispatchArgumentIndex].template as<OT>());
+	    int arg_idx(-1);
+	    this->incIdx(arg_idx);
+	    return mptr(*(ot.get()),translate::from_object<ARGS>(argArray[this->incIdx(arg_idx)])._v...);
+//	    return translate::to_object<RT>::convert(res);
+	}
+    };
+
+
+
+    template<class RT, typename... ARGS>
+    class FunctionWrapper {
+    public:
+	typedef std::function<RT(ARGS...)> 	Type;
+	Type					fn;
+    public:
+	FunctionWrapper(Type f) : fn(f) {};
+	T_mv operator()(ARGS...args) {
+	    RT retval = fn(args...);
+	    return translate::to_object<RT>::convert(retval);
+	}
+    };
+
+    template<typename... ARGS>
+    class FunctionWrapper<void,ARGS...> {
+    public:
+	typedef std::function<void(ARGS...)> 	Type;
+	Type 					fn;
+    public:
+	FunctionWrapper(Type f) : fn(f) {};
+	T_mv operator()(ARGS...args) {
+	    fn(args...);
+	    return Values0<T_O>();
+	}
+    };
+
+
+
+    template<typename RT,class... ARGS>
+    class VariadicFunctoid : public Functoid {
+    public:
+	typedef FunctionWrapper<RT,ARGS...> 		FunctionWrapperType;
+	typedef typename FunctionWrapper<RT,ARGS...>::Type 	Type;
+	FunctionWrapperType 				fptr;
+    public:
+	string describe() const { return "VariadicFunctoid";}
+	enum { NumParams = sizeof...(ARGS) };
+	VariadicFunctoid(const string& name, Type ptr) : Functoid(name), fptr(ptr) {};
+
+	T_mv activate( const_ActivationFrame_spREF closedEnv, int nargs, ArgArray argArray)
+	{_G();
+	    if ( nargs != sizeof...(ARGS) )
+	    {
+		stringstream ss;
+		ss << "Function expected "<< (sizeof...(ARGS)) << " argument(s) but was passed " << nargs << " argument(s).";
+		SIMPLE_ERROR_BF(ss.str());
+	    }
+	    int arg_idx(0);
+	    return fptr(translate::from_object<ARGS>(argArray[arg_idx++])._v...);
+	}
+
+    };
+
+
+
+    template <typename RT,typename... ARGS>
+    void af_def(const string& packageName, const string& name, RT (*fp)(ARGS...) , const string& arguments="", const string& declares="", const string& docstring="", int locked=1 )
+    {_G();
+        Functoid* f = new VariadicFunctoid<RT,ARGS...>(packageName+"::"+name,fp);
+        lisp_defun_lispify_name(packageName,name,f,arguments,declares,docstring,locked,true,sizeof...(ARGS));
+    }
+
+
+
+    
+
+
+
+
+};
+
+
+
+
+namespace core {
+
     template <class oclass,typename D>
     class MemberDataReader : public SingleDispatchMethoid
     {
@@ -21,7 +160,7 @@
 	MemberDataReader(const string& name,const MemberDataPtrType d) : SingleDispatchMethoid(name), _memberDataPtr(d) {};
 	virtual ~MemberDataReader() {};
 	virtual string describe() const {return "MemberDataReader";};
-	virtual T_mv activate(const_ActivationFrame_spREF frame)
+	virtual T_mv activate( const_ActivationFrame_spREF closedEnv,const_ActivationFrame_spREF frame)
 	{
 	    T_sp receiver = frame->entry(0);
 	    ObjectClass* objPtr = receiver.as<ObjectClass>().get();
@@ -43,7 +182,7 @@
 	virtual ~MemberDataWriter() {};
 
 	virtual string describe() const {return "MemberDataWriter";};
-	virtual T_mv activate(const_ActivationFrame_spREF frame)
+	virtual T_mv activate( const_ActivationFrame_spREF closedEnv,const_ActivationFrame_spREF frame)
 	{
 	    ObjectClass* objPtr = frame->entry(0).as<ObjectClass>().get();
 	    T_sp newValue = frame->entry(1);
@@ -63,14 +202,8 @@
 
 
 
-namespace core
-{
+namespace core {
 
-// New way
-#define af_methodptrt_H
-#include "af_method_templates.h"
-#undef af_methodptrt_H
-
 #define	DEF(ClassName,FunctionName) def(#FunctionName,&ClassName::FunctionName,ARGS_##ClassName##_##FunctionName,DECL_##ClassName##_##FunctionName,DOCS_##ClassName##_##FunctionName,true)
 #define DEF_DONT_EXPORT(ClassName,FunctionName) def(#FunctionName,&ClassName::FunctionName,ARGS_##ClassName##_##FunctionName,DECL_##ClassName##_##FunctionName,DOCS_##ClassName##_##FunctionName,false)
 
@@ -78,48 +211,34 @@
 
 
 
-// This is needed by def_raw
-//
-#include "methodptr.h"
-
-
-
 namespace core {
 
-class Function_O;    
+    class Function_O;    
 
 
-#include "af_function_templates.h"
-
-
-
-
-
-
-
 // -----------------------------------
 //
 // Macro stuff
 //
 //
 // Wrapper for ActivationFrameMacroPtr
-class ActivationFrameMacroWrapPtr : public Functoid {
-private:
-    typedef	T_mv (*MacroPtr)(Cons_sp,Environment_sp);
-    MacroPtr	mptr;
-public:
-    virtual string describe() const {return "ActivationFrameMacroWrapPtr";};
+    class ActivationFrameMacroWrapPtr : public Functoid {
+    private:
+	typedef	T_mv (*MacroPtr)(Cons_sp,Environment_sp);
+	MacroPtr	mptr;
+    public:
+	virtual string describe() const {return "ActivationFrameMacroWrapPtr";};
 // constructor
-    ActivationFrameMacroWrapPtr(const string& name, MacroPtr ptr) : Functoid(name),mptr(ptr) {}
+	ActivationFrameMacroWrapPtr(const string& name, MacroPtr ptr) : Functoid(name),mptr(ptr) {}
 
-    T_mv activate(const_ActivationFrame_spREF af)
-    {_G();
-	Cons_sp form = af->entry(0).as_or_nil<Cons_O>();
-	Environment_sp env = af->entry(1).as_or_nil<Environment_O>();
-	T_mv retval = (this->mptr)(form,env);
-	return retval;
+	T_mv activate( const_ActivationFrame_spREF closedEnv, int nargs, ArgArray argArray)
+	{_G();
+	    Cons_sp form = argArray[0].as_or_nil<Cons_O>();
+	    Environment_sp env = argArray[1].as_or_nil<Environment_O>();
+	    T_mv retval = (this->mptr)(form,env);
+	    return retval;
+	};
     };
-};
 
 
     inline void defmacro(const string& packageName, const string& name, T_mv (*mp)(Cons_sp,Environment_sp env),const string& arguments="", const string& declares="", const string& docstring="", bool autoExport=true)
@@ -137,267 +256,156 @@
 
 
 
-#if 0
-template <typename RT>
-inline void defInPackage(const string& package, const string& name, RT (*fp)(Lisp_sp), Lisp_sp lisp )
-{
-    Functoid* functoid = new FunctionWrapPtr<RT>(fp);
-    lisp_defun_lispify_name(lisp,package,name,functoid,"","");
-}
 
-template <typename RT, typename P1>
-    inline void defInPackage(const string& package, const string& name, RT (*fp)(P1,Lisp_sp), Lisp_sp lisp )
-{
-    Functoid* functoid = new FunctionWrapPtr<RT,P1>(fp);
-    lisp_defun_lispify_name(lisp,package,name,functoid,"","");
-}
 
-template <typename RT, typename P1, typename P2>
-    inline void defInPackage(const string& package, const string& name, RT (*fp)(P1,P2,Lisp_sp), Lisp_sp lisp )
-{
-    Functoid* functoid = new FunctionWrapPtr<RT,P1,P2>(fp);
-    lisp_defun_lispify_name(lisp,package,name,functoid,"","");
-}
 
-template <typename RT, typename P1, typename P2, typename P3>
-    inline void defInPackage(const string& package, const string& name, RT (*fp)(P1,P2,P3,Lisp_sp), Lisp_sp lisp )
-{
-    Functoid* functoid = new FunctionWrapPtr<RT,P1,P2,P3>(fp);
-    lisp_defun_lispify_name(lisp,package,name,functoid,"","");
-}
 
-/*! Define a function without arguments would be converted into a lambda-list
- - return the functions Symbol */
-template <typename RT, typename P1, typename P2, typename P3, typename P4>
-    inline void defInPackage(const string& package, const string& name, RT (*fp)(P1,P2,P3,P4,Lisp_sp), Lisp_sp lisp )
-{
-    Functoid* functoid = new FunctionWrapPtr<RT,P1,P2,P3,P4>(fp);
-    lisp_defun_lispify_name(lisp,package,name,functoid,"","");
-}
-
-
-/*! Define a function without arguments would be converted into a lambda-list
- - return the functions Symbol */
-inline void defNoWrapPackage(const string& package, const string& name, FormCallback fp, Lisp_sp lisp)
-{_G();
-    Functoid* functoid = new FunctionPtr(fp);
-    lisp_defun_lispify_name(lisp, package, name, functoid);
-}
-
-/*! define a function with arguments - return the function Symbol */
-inline void defNoWrapPackageWithArguments(const string& package, const string& name, FormCallback fp, const string& arguments, Lisp_sp lisp)
-{_G();
-    Functoid* functoid = new FunctionPtr(fp);
-    lisp_defun_lispify_name(lisp, package, name,functoid,arguments);
-}
-#endif
-
-
-
-
-
-
-#if 0
-/*! MODERN WAY TO defun!  Define a function with arguments - setup a Symbol */
-    inline void defun(const string& package, const string& name, FormCallback fp, const string& arguments, string const& declarestring, string const& docString, int locked, Lisp_sp lisp)
-{_G();
-    Functoid* functoid = new FunctionPtr(fp);
-    lisp_defun_lispify_name(lisp, package, name,functoid,arguments,declarestring,docString,locked);
-}
-
-
-
-/*! MODERN WAY TO defgeneric!!! Define a generic function with arguments - return the generic functions Symbol */
-inline void defgeneric(const string& package, const string& name, FormCallback fp, const string& arguments, const string& docstring, Lisp_sp lisp)
-{_G();
-    Functoid* functoid = new FunctionPtr(fp);
-    lisp_defgeneric(lisp, package, name,functoid,arguments,docstring);
-}
-
-
-
-/*! define a generic function with arguments - return the generic functions Symbol */
-    inline void defmethod(Symbol_sp gfSymbol, FormCallback fp, const string& arguments, string const& declarestring, const string& docstring, Lisp_sp lisp)
-{_G();
-    Functoid* functoid = new FunctionPtr(fp);
-    lisp_defmethod(lisp, gfSymbol, functoid, arguments, docstring );
-}
-#endif
-
-
-
 // ----------------------------------------
 // ----------------------------------------
 // ----------------------------------------
 // ----------------------------------------
 
-struct	MethodDefinition {
+    struct	MethodDefinition {
 	string		_Name;
 	int		_ClassSymbol;
 	Functoid*	_Methoid;
-};
+    };
 
 //    typedef	enum { no_init,class_name_init, make_class_name_init } maker_enum;
 
 
     extern Symbol_sp _sym_STARallCxxClassesSTAR;
 
-template < typename OT>
-class class_
-{
-public:
-    typedef OT wrapped_type;
-private:
+    template < typename OT>
+    class class_
+    {
+    public:
+	typedef OT wrapped_type;
+    private:
 	Symbol_sp	_ClassSymbol;
-public:
+    public:
 
-    void setup_class(const string& makerName = "")
-    {_G();
-	if ( IS_SYMBOL_UNDEFINED(OT::static_classSymbol()) )
-	{
-	    SIMPLE_ERROR(BF("Attempting to add methods for "
-				  "class that isn't defined yet"));
-	}
+	void setup_class(const string& makerName = "")
+	{_G();
+	    if ( IS_SYMBOL_UNDEFINED(OT::static_classSymbol()) )
+	    {
+		SIMPLE_ERROR(BF("Attempting to add methods for "
+				"class that isn't defined yet"));
+	    }
 
-        this->_ClassSymbol = OT::static_classSymbol();
-	/*! Accumulate all of the classes in reverse order of how they were initialized
-	  in the core::*all-cxx-classes* variable */
-	if ( _sym_STARallCxxClassesSTAR->symbolValueUnsafe() ) {
-	    _sym_STARallCxxClassesSTAR->setf_symbolValue(Cons_O::create(OT::static_classSymbol(),_sym_STARallCxxClassesSTAR->symbolValue()));
+	    this->_ClassSymbol = OT::static_classSymbol();
+	    /*! Accumulate all of the classes in reverse order of how they were initialized
+	      in the core::*all-cxx-classes* variable */
+	    if ( _sym_STARallCxxClassesSTAR->symbolValueUnsafe() ) {
+		_sym_STARallCxxClassesSTAR->setf_symbolValue(Cons_O::create(OT::static_classSymbol(),_sym_STARallCxxClassesSTAR->symbolValue()));
+	    }
+	    // 
+	    // If the class isn't in the class table then add it
+	    //
+	    if ( lisp_boot_findClassBySymbolOrNil(OT::static_classSymbol()).nilp())
+	    {
+		LOG(BF("Adding class(%s) to environment")% OT::static_className() );
+		lisp_addClass(/*_lisp,OT::static_packageName(),
+				OT::static_className(), */
+		    OT::static_classSymbol(),
+		    OT::static_newNil_callback(),
+		    OT::Bases::baseClass1Id(),
+		    OT::Bases::baseClass2Id() );
+	    }
+	    if (makerName != "")
+	    {
+		// use make-<className>
+		af_def(OT::static_packageName(),makerName,&new_LispObject<OT>);
+	    }
 	}
-	// 
-	// If the class isn't in the class table then add it
-	//
-	if ( lisp_boot_findClassBySymbolOrNil(OT::static_classSymbol()).nilp())
-	{
-	    LOG(BF("Adding class(%s) to environment")% OT::static_className() );
-	    lisp_addClass(/*_lisp,OT::static_packageName(),
-			    OT::static_className(), */
-			  OT::static_classSymbol(),
-			  OT::static_newNil_callback(),
-			  OT::Bases::baseClass1Id(),
-			  OT::Bases::baseClass2Id() );
-	}
-	if (makerName != "")
-	{
-	// use make-<className>
-	    af_def(OT::static_packageName(),makerName,&new_LispObject<OT>);
-	}
-    }
 
 
-    //
-    //
-    // ctor
-    //
-    //
+	//
+	//
+	// ctor
+	//
+	//
 
-    class_()
-    {_G();
-	this->setup_class("");
-    }
+	class_()
+	{_G();
+	    this->setup_class("");
+	}
 
-    class_(const string& makerName)
-    {_G();
-	this->setup_class(makerName);
-    }
+	class_(const string& makerName)
+	{_G();
+	    this->setup_class(makerName);
+	}
 
 
+	template <typename RT,class... ARGS>
+	class_& def( string const& name, RT (OT::*mp)(ARGS...), string const& lambda_list="", const string& declares="", const string& docstring="",bool autoExport=true)
+	{_G();
+	    VariadicMethoid<RT,OT,ARGS...>* m = new VariadicMethoid<RT,OT,ARGS...>(name,std::mem_fn(mp));
+	    lisp_defineSingleDispatchMethod(name,this->_ClassSymbol,m,lambda_list,declares,docstring,autoExport,sizeof...(ARGS)+1);
+	    return *this;
+	}
 
-// new way
-#define af_method_def_H
-#include "af_method_templates.h"
-#undef af_method_def_H
+	template <typename RT,class... ARGS>
+	class_& def( string const& name, RT (OT::*mp)(ARGS...) const,
+		     string const& lambda_list="", const string& declares="", const string& docstring="",bool autoExport=true)
+	{_G();
+//	    ConstVariadicMethoid<RT,OT,ARGS...>* m = new ConstVariadicMethoid<RT,OT,ARGS...>(name,mp);
+	    VariadicMethoid<RT,OT,ARGS...>* m = new VariadicMethoid<RT,OT,ARGS...>(name,std::mem_fn(mp));
+	    lisp_defineSingleDispatchMethod(name,this->_ClassSymbol,m,lambda_list,declares,docstring,autoExport,sizeof...(ARGS)+1);
+	    return *this;
+	}
 
 
 
-    class_& def_raw(const string& name, T_sp (OT::*mp)(Function_sp,Cons_sp, Environment_sp, Lisp_sp ), const string& arguments="", string const& declarestring="", string const& docstring="", bool autoExport=true )
-    {_OF();
-	SingleDispatchMethoid* m = new OldStyleMethoid<OT>(name,mp);
-	lisp_defineSingleDispatchMethod(name,this->_ClassSymbol,m,arguments,declarestring,docstring,autoExport);
-	return *this;
-    }
+    };
 
 
 
 
-
-
-
-
-    /*! Define readonly member data access for an instance variable */
-    template <typename D>
-	class_& def_readonly(const string& name, D ptr_to_member_data, const string& doc = "")
-    {
-	SingleDispatchMethoid* reader = new MemberDataReader<OT,D>(name,ptr_to_member_data);
-	lisp_defineSingleDispatchMethod(name,this->_ClassSymbol,reader,"","",doc,false,1);
-	return *this;
+    template <typename oclass>
+    void defaultExposeCando(Lisp_sp lisp)
+    {_G();
+	// Only expose the class, don't create any methods
+	// By default put class in the Cl package
+	class_<oclass>();
     }
 
 
-#if 0
-    /*! Define read/write member data access for an instance variable */
-    template <typename V,typename D>
-	class_& def_readwrite(const string& name, D ptr_to_member_data, FunctionPtr setf, const string& doc = "")
-    {
-	Functoid* reader = new MemberDataReader<OT,D>(name,ptr_to_member_data);
-	lisp_defineSingleDispatchMethod(name,this->_ClassSymbol,reader,"",doc);
-	Functoid* writer = new MemberDataWriter<OT,D,V>(name,ptr_to_member_data);
-	lisp_defineSetf(_lisp,name,this->_ClassSymbol,writer,"",doc);
-	return *this;
-    }
-#endif
-
-};
-
-
-
-
-
-template <typename oclass>
-void defaultExposeCando(Lisp_sp lisp)
-{_G();
-    		// Only expose the class, don't create any methods
-		// By default put class in the Cl package
-    class_<oclass>();
-}
-
-
-struct	EnumValueDefinition {
+    struct	EnumValueDefinition {
 	string		_Name;
 	int		_Value;
-};
+    };
 
 
-template <typename X>
-class enum_
-{
-private:
-    SymbolToEnumConverter_sp	_Converter;
-    Symbol_sp		_PredefinedConverterSymbolId;
-public:
-    enum_(Symbol_sp symbol, const string& title)
-    {_G();
-	this->_PredefinedConverterSymbolId = symbol;
-	this->_Converter = SymbolToEnumConverter_O::create(title);
-	symbol->setf_symbolValue(this->_Converter);
-    }
+    template <typename X>
+    class enum_
+    {
+    private:
+	SymbolToEnumConverter_sp	_Converter;
+	Symbol_sp		_PredefinedConverterSymbolId;
+    public:
+	enum_(Symbol_sp symbol, const string& title)
+	{_G();
+	    this->_PredefinedConverterSymbolId = symbol;
+	    this->_Converter = SymbolToEnumConverter_O::create(title);
+	    symbol->setf_symbolValue(this->_Converter);
+	}
 
-    enum_& value(Symbol_sp const& sym, X value )
-    {_G();
-	lisp_extendSymbolToEnumConverter(this->_Converter,sym,sym,value);
-	return *this;
-    }
-    enum_& value(Symbol_sp const& name, Symbol_sp const& archiveName, X value )
-    {_G();
-	lisp_extendSymbolToEnumConverter(this->_Converter,name,archiveName,value);
-	return *this;
-    }
-    Symbol_sp symbolFromEnum(int value)
-    {_G();
-	return lisp_lookupSymbolForEnum(this->_PredefinedConverterSymbolId,(int)(value));
-    }
-};
+	enum_& value(Symbol_sp const& sym, X value )
+	{_G();
+	    lisp_extendSymbolToEnumConverter(this->_Converter,sym,sym,value);
+	    return *this;
+	}
+	enum_& value(Symbol_sp const& name, Symbol_sp const& archiveName, X value )
+	{_G();
+	    lisp_extendSymbolToEnumConverter(this->_Converter,name,archiveName,value);
+	    return *this;
+	}
+	Symbol_sp symbolFromEnum(int value)
+	{_G();
+	    return lisp_lookupSymbolForEnum(this->_PredefinedConverterSymbolId,(int)(value));
+	}
+    };
 
 };
 
Index: write_ugly.cc
===================================================================
--- write_ugly.cc	(revision 4737)
+++ write_ugly.cc	(working copy)
@@ -33,6 +33,8 @@
 #include "core/lispStream.h"
 #include "core/instance.h"
 #include "core/strWithFillPtr.h"
+#include "core/structureObject.h"
+#include "core/sysprop.h"
 #include "core/numberToString.h"
 #include "core/evaluator.h"
 #include "core/arguments.h"
@@ -106,11 +108,33 @@
 
     void Instance_O::__write__(Stream_sp stream) const
     {
-	eval::apply(cl::_sym_printObject, this->const_sharedThis<Instance_O>(), stream, _Nil<Cons_O>() );
+	eval::funcall(cl::_sym_printObject, this->const_sharedThis<Instance_O>(), stream );
     }
 
 
 
+
+    void StructureObject_O::__write__(Stream_sp stream) const
+    {
+        if (UNLIKELY(!this->_Type.isA<Symbol_O>()) )
+	    SIMPLE_ERROR(BF("Found a corrupt structure with an invalid type name~%  ~S") % _rep_(this->_Type));
+	SYMBOL_EXPORT_SC_(CorePkg,structure_print_function);
+	SYMBOL_EXPORT_SC_(CorePkg,STARprint_structureSTAR);
+        T_sp print_function = af_get_sysprop(this->_Type,_sym_structure_print_function);
+        if (Null(print_function) || !_sym_STARprint_structureSTAR->symbolValue().isTrue()) {
+	    stream->writeStr("#S");
+	    /* structure_to_list conses slot names and values into
+	     * a list to be printed.  print shouldn't allocate
+	     * memory - Beppe
+	     */
+	    T_sp x = this->structureAsList();
+	    write_object(x,stream);
+        } else {
+	    eval::funcall(print_function,this->asSmartPtr(),stream,Fixnum_O::create(0));
+        }
+    }
+
+
     void Integer_O::__write__(Stream_sp stream) const
     {
 	StrWithFillPtr_sp buffer = StrWithFillPtr_O::createBufferString(128);
@@ -125,20 +149,20 @@
 
 #if 0 // working
 
-void
-_ecl_write_fixnum(cl_fixnum i, T_sp stream)
-{
+    void
+    _ecl_write_fixnum(cl_fixnum i, T_sp stream)
+    {
         T_sp s = si_get_buffer_string();
         si_integer_to_string(s, ecl_make_fixnum(i), ecl_make_fixnum(10), ECL_NIL, ECL_NIL);
         si_do_write_sequence(s, stream, ecl_make_fixnum(0), ECL_NIL);
         si_put_buffer_string(s);
-}
+    }
 
 
 
-static void
-write_ratio(T_sp r, T_sp stream)
-{
+    static void
+    write_ratio(T_sp r, T_sp stream)
+    {
         T_sp s = si_get_buffer_string();
         int print_base = ecl_print_base();
         si_integer_to_string(s, r->ratio.num, ecl_make_fixnum(print_base),
@@ -150,87 +174,87 @@
                              ECL_NIL, ECL_NIL);
         si_do_write_sequence(s, stream, ecl_make_fixnum(0), ECL_NIL);
         si_put_buffer_string(s);
-}
+    }
 
-static void
-write_complex(T_sp x, T_sp stream)
-{
+    static void
+    write_complex(T_sp x, T_sp stream)
+    {
         writestr_stream("#C(", stream);
         si_write_ugly_object(x->complex.real, stream);
         ecl_write_char(' ', stream);
         si_write_ugly_object(x->complex.imag, stream);
         ecl_write_char(')', stream);
-}
+    }
 
-static void
-write_float(T_sp f, T_sp stream)
-{
+    static void
+    write_float(T_sp f, T_sp stream)
+    {
         T_sp s = si_get_buffer_string();
         s = si_float_to_string_free(s, f, ecl_make_fixnum(-3), ecl_make_fixnum(8));
         si_do_write_sequence(s, stream, ecl_make_fixnum(0), ECL_NIL);
         si_put_buffer_string(s);
-}
+    }
 
-static void
-write_character(T_sp x, T_sp stream)
-{
+    static void
+    write_character(T_sp x, T_sp stream)
+    {
         int i = ECL_CHAR_CODE(x);
 	if (!ecl_print_escape() && !ecl_print_readably()) {
+	    ecl_write_char(i, stream);
+	} else {
+	    writestr_stream("#\\", stream);
+	    if (i < 32 || i >= 127) {
+		T_sp name = cl_char_name(ECL_CODE_CHAR(i));
+		writestr_stream((char*)name->base_string.self, stream);
+	    } else {
 		ecl_write_char(i, stream);
-	} else {
-		writestr_stream("#\\", stream);
-		if (i < 32 || i >= 127) {
-			T_sp name = cl_char_name(ECL_CODE_CHAR(i));
-			writestr_stream((char*)name->base_string.self, stream);
-		} else {
-			ecl_write_char(i, stream);
-		}
+	    }
 	}
-}
+    }
 
-static void
-write_package(T_sp x, T_sp stream)
-{
+    static void
+    write_package(T_sp x, T_sp stream)
+    {
         if (ecl_print_readably()) FEprint_not_readable(x);
         writestr_stream("#<", stream);
         si_write_ugly_object(x->pack.name, stream);
         writestr_stream(" package>", stream);
-}
+    }
 
-static void
-write_hashtable(T_sp x, T_sp stream)
-{
+    static void
+    write_hashtable(T_sp x, T_sp stream)
+    {
 	if (ecl_print_readably() && !Null(ecl_symbol_value(@'*read-eval*'))) {
-		T_sp make =
-			cl_list(9, @'make-hash-table',
-				@':size', cl_hash_table_size(x),
-				@':rehash-size', cl_hash_table_rehash_size(x),
-				@':rehash-threshold', cl_hash_table_rehash_threshold(x),
-				@':test', cl_hash_table_test(x));
-		T_sp init =
-			cl_list(3, @'ext::hash-table-fill', make,
-				cl_list(2, @'quote', si_hash_table_content(x)));
-		writestr_stream("#.", stream);
-		si_write_ugly_object(init, stream);
+	    T_sp make =
+		cl_list(9, @'make-hash-table',
+			@':size', cl_hash_table_size(x),
+			@':rehash-size', cl_hash_table_rehash_size(x),
+			@':rehash-threshold', cl_hash_table_rehash_threshold(x),
+			@':test', cl_hash_table_test(x));
+	    T_sp init =
+		cl_list(3, @'ext::hash-table-fill', make,
+			cl_list(2, @'quote', si_hash_table_content(x)));
+	    writestr_stream("#.", stream);
+	    si_write_ugly_object(init, stream);
 	} else {
-		_ecl_write_unreadable(x, "hash-table", ECL_NIL, stream);
+	    _ecl_write_unreadable(x, "hash-table", ECL_NIL, stream);
 	}
-}
+    }
 
-static void
-write_random(T_sp x, T_sp stream)
-{
+    static void
+    write_random(T_sp x, T_sp stream)
+    {
         if (ecl_print_readably()) {
-                writestr_stream("#$", stream);
-                _ecl_write_vector(x->random.value, stream);
+	    writestr_stream("#$", stream);
+	    _ecl_write_vector(x->random.value, stream);
         } else {
-                _ecl_write_unreadable(x->random.value, "random-state", ECL_NIL, stream);
+	    _ecl_write_unreadable(x->random.value, "random-state", ECL_NIL, stream);
         }
-}
+    }
 
-static void
-write_stream(T_sp x, T_sp stream)
-{
+    static void
+    write_stream(T_sp x, T_sp stream)
+    {
         const char *prefix;
         T_sp tag;
         union cl_lispunion str;
@@ -241,165 +265,205 @@
 #endif
         switch ((enum ecl_smmode)x->stream.mode) {
         case ecl_smm_input_file:
-                prefix = "closed input file";
-                tag = IO_STREAM_FILENAME(x);
-                break;
+	    prefix = "closed input file";
+	    tag = IO_STREAM_FILENAME(x);
+	    break;
         case ecl_smm_input:
-                prefix = "closed input stream";
-                tag = IO_STREAM_FILENAME(x);
-                break;
+	    prefix = "closed input stream";
+	    tag = IO_STREAM_FILENAME(x);
+	    break;
         case ecl_smm_output_file:
-                prefix = "closed output file";
-                tag = IO_STREAM_FILENAME(x);
-                break;
+	    prefix = "closed output file";
+	    tag = IO_STREAM_FILENAME(x);
+	    break;
         case ecl_smm_output:
-                prefix = "closed output stream";
-                tag = IO_STREAM_FILENAME(x);
-                break;
+	    prefix = "closed output stream";
+	    tag = IO_STREAM_FILENAME(x);
+	    break;
 #ifdef ECL_MS_WINDOWS_HOST
         case ecl_smm_input_wsock:
-                prefix = "closed input win32 socket stream";
-                tag = IO_STREAM_FILENAME(x);
-                break;
+	    prefix = "closed input win32 socket stream";
+	    tag = IO_STREAM_FILENAME(x);
+	    break;
         case ecl_smm_output_wsock:
-                prefix = "closed output win32 socket stream";
-                tag = IO_STREAM_FILENAME(x);
-                break;
+	    prefix = "closed output win32 socket stream";
+	    tag = IO_STREAM_FILENAME(x);
+	    break;
         case ecl_smm_io_wsock:
-                prefix = "closed i/o win32 socket stream";
-                tag = IO_STREAM_FILENAME(x);
-                break;
+	    prefix = "closed i/o win32 socket stream";
+	    tag = IO_STREAM_FILENAME(x);
+	    break;
         case ecl_smm_io_wcon:
-                prefix = "closed i/o win32 console stream";
-                tag = IO_STREAM_FILENAME(x);
-                break;
+	    prefix = "closed i/o win32 console stream";
+	    tag = IO_STREAM_FILENAME(x);
+	    break;
 #endif
         case ecl_smm_io_file:
-                prefix = "closed io file";
-                tag = IO_STREAM_FILENAME(x);
-                break;
+	    prefix = "closed io file";
+	    tag = IO_STREAM_FILENAME(x);
+	    break;
         case ecl_smm_io:
-                prefix = "closed io stream";
-                tag = IO_STREAM_FILENAME(x);
-                break;
+	    prefix = "closed io stream";
+	    tag = IO_STREAM_FILENAME(x);
+	    break;
         case ecl_smm_probe:
-                prefix = "closed probe stream";
-                tag = IO_STREAM_FILENAME(x);
-                break;
+	    prefix = "closed probe stream";
+	    tag = IO_STREAM_FILENAME(x);
+	    break;
         case ecl_smm_synonym:
-                prefix = "closed synonym stream to";
-                tag = SYNONYM_STREAM_SYMBOL(x);
-                break;
+	    prefix = "closed synonym stream to";
+	    tag = SYNONYM_STREAM_SYMBOL(x);
+	    break;
         case ecl_smm_broadcast:
-                prefix = "closed broadcast stream";
-                tag = ECL_NIL;
-                break;
+	    prefix = "closed broadcast stream";
+	    tag = ECL_NIL;
+	    break;
         case ecl_smm_concatenated:
-                prefix = "closed concatenated stream";
-                tag = ECL_NIL;
-                break;
+	    prefix = "closed concatenated stream";
+	    tag = ECL_NIL;
+	    break;
         case ecl_smm_two_way:
-                prefix = "closed two-way stream";
-                tag = ECL_NIL;
-                break;
+	    prefix = "closed two-way stream";
+	    tag = ECL_NIL;
+	    break;
         case ecl_smm_echo:
-                prefix = "closed echo stream";
-                tag = ECL_NIL;
-                break;
+	    prefix = "closed echo stream";
+	    tag = ECL_NIL;
+	    break;
         case ecl_smm_string_input: {
-                T_sp text = x->stream.object0;
-                cl_index ndx, l = ecl_length(text);
-                for (ndx = 0; (ndx < 8) && (ndx < l); ndx++) {
-                        buffer[ndx] = ecl_char(text, ndx);
-                }
-                if (l > ndx) {
-                        buffer[ndx-1] = '.';
-                        buffer[ndx-2] = '.';
-                        buffer[ndx-3] = '.';
-                }
-                buffer[ndx++] = 0;
-                prefix = "closed string-input stream from";
-                tag = &str;
+	    T_sp text = x->stream.object0;
+	    cl_index ndx, l = ecl_length(text);
+	    for (ndx = 0; (ndx < 8) && (ndx < l); ndx++) {
+		buffer[ndx] = ecl_char(text, ndx);
+	    }
+	    if (l > ndx) {
+		buffer[ndx-1] = '.';
+		buffer[ndx-2] = '.';
+		buffer[ndx-3] = '.';
+	    }
+	    buffer[ndx++] = 0;
+	    prefix = "closed string-input stream from";
+	    tag = &str;
 #ifdef ECL_UNICODE
-                tag->string.t = t_string;
-                tag->string.self = buffer;
+	    tag->string.t = t_string;
+	    tag->string.self = buffer;
 #else
-                tag->base_string.t = t_base_string;
-                tag->base_string.self = buffer;
+	    tag->base_string.t = t_base_string;
+	    tag->base_string.self = buffer;
 #endif
-                tag->base_string.dim = ndx;
-                tag->base_string.fillp = ndx-1;
-                break;
+	    tag->base_string.dim = ndx;
+	    tag->base_string.fillp = ndx-1;
+	    break;
         }
         case ecl_smm_string_output:
-                prefix = "closed string-output stream";
-                tag = ECL_NIL;
-                break;
+	    prefix = "closed string-output stream";
+	    tag = ECL_NIL;
+	    break;
         case ecl_smm_sequence_input:
-                prefix = "closed sequence-input stream";
-                tag = ECL_NIL;
-                break;
+	    prefix = "closed sequence-input stream";
+	    tag = ECL_NIL;
+	    break;
         case ecl_smm_sequence_output:
-                prefix = "closed sequence-output stream";
-                tag = ECL_NIL;
-                break;
+	    prefix = "closed sequence-output stream";
+	    tag = ECL_NIL;
+	    break;
         default:
-                ecl_internal_error("illegal stream mode");
+	    ecl_internal_error("illegal stream mode");
         }
         if (!x->stream.closed)
-                prefix = prefix + 7;
+	    prefix = prefix + 7;
         _ecl_write_unreadable(x, prefix, tag, stream);
-}
+    }
 
 #ifdef CLOS
-static void
-write_instance(T_sp x, T_sp stream)
-{
+    static void
+    write_instance(T_sp x, T_sp stream)
+    {
         _ecl_funcall3(@'print-object', x, stream);
-}
-#else
-static void
-write_structure(T_sp x, T_sp stream)
-{
+    }
+#endif
+    static void
+    write_structure(T_sp x, T_sp stream)
+    {
         T_sp print_function;
         unlikely_if (ecl_t_of(x->str.name) != t_symbol)
-                FEerror("Found a corrupt structure with an invalid type name~%"
-                        "  ~S", x->str.name);
+	    FEerror("Found a corrupt structure with an invalid type name~%"
+		    "  ~S", x->str.name);
         print_function = si_get_sysprop(x->str.name, @'si::structure-print-function');
         if (Null(print_function) || !ecl_print_structure()) {
-                writestr_stream("#S", stream);
-                /* structure_to_list conses slot names and values into
-                 * a list to be printed.  print shouldn't allocate
-                 * memory - Beppe
-                 */
-                x = structure_to_list(x);
-                si_write_object(x, stream);
+	    writestr_stream("#S", stream);
+	    /* structure_to_list conses slot names and values into
+	     * a list to be printed.  print shouldn't allocate
+	     * memory - Beppe
+	     */
+	    x = structure_to_list(x);
+	    si_write_object(x, stream);
         } else {
-                _ecl_funcall4(print_function, x, stream, ecl_make_fixnum(0));
+	    _ecl_funcall4(print_function, x, stream, ecl_make_fixnum(0));
         }
-}
-#endif /* !CLOS */
+    }
+//#endif /* !CLOS */
 
 
 #endif // working
 
 
+    void write_fixnum(Stream_sp strm, T_sp i)
+    {
+	Fixnum_sp fn = Fixnum_O::create(i.fixnum());
+	fn->__write__(strm);
+    }
+
+
+    void write_character(Stream_sp strm, T_sp chr)
+    {
+        brclChar i = chr.character();
+	if (!brcl_print_escape() && !brcl_print_readably()) {
+	    strm->writeChar(i);
+	} else {
+	    strm->writeStr("#\\");
+	    if (i < 32 || i >= 127) {
+		Str_sp name = cl_char_name(Character_O::create(i));
+		strm->writeStr(name->get());
+	    } else {
+		strm->writeChar(i);
+	    }
+	}
+    }
+
+
     T_sp write_ugly_object(T_sp x, Stream_sp stream)
     {
-	if ( !x )
-	{
+	if ( !x ) {
 	    if (brcl_print_readably())
 		PRINT_NOT_READABLE_ERROR(x);
 	    stream->writeStr("#<OBJNULL>");
-	} else if ( x.nilp() ) { // ECL appears to shunt this off to write_list
-	    cl::_sym_nil->__write__(stream);
-	} else if ( x.unboundp() ) {
-	    stream->writeStr("unbound");
-	} else {
+	    goto DONE;
+	}	
+	switch (x.tag()) {
+	case mem::smart_ptr<T_O>::BaseType::ptr_tag:
 	    x->__write__(stream);
-        }
+	    break;
+	case mem::smart_ptr<T_O>::special_tag:
+	    if ( x.nilp() ) { // ECL appears to shunt this off to write_list
+		cl::_sym_nil->__write__(stream);
+	    } else if ( x.unboundp() ) {
+		stream->writeStr("unbound");
+	    }
+	    break;
+	case mem::smart_ptr<T_O>::character_tag:
+	    write_character(stream,x);
+	    break;
+	case mem::smart_ptr<T_O>::fixnum_tag:
+	    write_fixnum(stream,x);
+	    break;
+	default:
+	    SIMPLE_ERROR(BF("Could not write object with tag: %ul") % x.tag());
+	    break;
+	}
+    DONE:
 	return x;
-}
+    }
 
 
 };
