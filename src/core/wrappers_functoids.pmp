$$ Three kinds of return values for the wrapped functions    single-value, multiple-value and void
$$ I'm screwing everything up for variadic arguments
$var ReturnTypeCount = 3 
$var RetSV = 0
$var RetVoid = 1
$var RetMV = 2
$var NumArgs = 16
$var InnerCount = NumArgs+1
$var Templates = InnerCount*ReturnTypeCount-1
$range template_ 0..Templates
$for template_ [[
        $var numVoids = template_ % InnerCount
        $var numArgs = NumArgs - numVoids
        $var ret = template_ // InnerCount
        $range Args_ 0..numArgs-1
        // ret = $ret  $if ret==RetVoid [[RetVoid
        ]] $elif ret==RetSV [[RetSV
        ]] $else [[RetMV
        ]]
        // numArgs = $numArgs 
        // numVoids = $numVoids    
    /* Specialization */
    template <$if ret==RetVoid [[]] $else [[typename RT $if numArgs [[,]] ]] $for Args_ ,[[typename ARG$Args_]] >
        class VariadicFunctoid
    <$if ret==RetVoid [[void]] $elif ret==RetSV [[RT ]] $else [[gctools::multiple_values<RT>]]($for Args_ , [[ARG$Args_]]) >
        : public Functoid {
        public:
            typedef Functoid TemplatedBase;
        public:
        typedef $if ret==RetVoid [[void]] $elif ret==RetSV [[RT]] $else [[gctools::multiple_values<RT>]](*Type) ($for Args_ , [[ARG$Args_]]);
        Type fptr;
        public:
        enum { NumParams = $numArgs };
        VariadicFunctoid(const string& name, Type ptr) : Functoid(name), fptr(ptr) {};
        DISABLE_NEW();
        virtual size_t templatedSizeof() const { return sizeof(*this); };
        LISP_CALLING_CONVENTION()
        {
            if ( lcc_nargs != (NumParams) )
            {
                core::wrongNumberOfArguments(lcc_nargs,NumParams);
            }
            LCC_VA_START$numArgs();
            $for Args_ [[translate::from_object<ARG$Args_> a$Args_(LCC_ARG$Args_());
            ]]
            LCC_VA_END$numArgs();
     $$ Do the call
            $if ret==RetVoid [[]] $elif ret==RetSV [[ RT retval = ]] $else [[ gctools::multiple_values<RT> retval = ]] fptr($for Args_ ,[[a$Args_._v]]);
            $if ret==RetVoid [[
                *lcc_resultP = Values0<core::T_O>();
            ]] $elif ret==RetMV [[
                *lcc_resultP = retval;
            ]] $else [[
                *lcc_resultP = Values(translate::to_object<RT>::convert(retval));
            ]]
            return;
        }

        };
        ]]



